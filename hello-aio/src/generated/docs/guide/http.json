{
  "id": "guide/http",
  "title": "HttpClient",
  "contents": "\n<div class=\"content\">\n<h1 id=\"httpclient\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#httpclient\"><i class=\"material-icons\">link</i></a>HttpClient</h1>\n<p>Most front-end applications communicate with backend services over the HTTP protocol. Modern browsers support two different APIs for making HTTP requests: the <code>XMLHttpRequest</code> interface and the <code>fetch()</code> API.</p>\n<p>With <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code>, <code>@angular/common/http</code> provides a simplified API for HTTP functionality for use with Angular applications, building on top of the <code>XMLHttpRequest</code> interface exposed by browsers.\nAdditional benefits of <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> include testability support, strong typing of request and response objects, request and response interceptor support, and better error handling via apis based on Observables.</p>\n<h2 id=\"setup-installing-the-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setup-installing-the-module\"><i class=\"material-icons\">link</i></a>Setup: installing the module</h2>\n<p>Before you can use the <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code>, you need to install the <code><a href=\"api/common/http/HttpClientModule\">HttpClientModule</a></code> which provides it. This can be done in your application module, and is only necessary once.</p>\n<code-example language=\"javascript\">\n// app.module.ts:\n\nimport {NgModule} from '@angular/core';\nimport {BrowserModule} from '@angular/platform-browser';\n\n// Import HttpClientModule from @angular/common/http\nimport {HttpClientModule} from '@angular/common/http';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    // Include it under 'imports' in your application module\n    // after BrowserModule.\n    HttpClientModule,\n  ],\n})\nexport class MyAppModule {}\n</code-example>\n<p>Once you import <code><a href=\"api/common/http/HttpClientModule\">HttpClientModule</a></code> into your app module, you can inject <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code>\ninto your components and services.</p>\n<h2 id=\"making-a-request-for-json-data\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#making-a-request-for-json-data\"><i class=\"material-icons\">link</i></a>Making a request for JSON data</h2>\n<p>The most common type of request applications make to a backend is to request JSON data. For example, suppose you have an API endpoint that lists items, <code>/api/items</code>, which returns a JSON object of the form:</p>\n<code-example language=\"json\">\n{\n  \"results\": [\n    \"Item 1\",\n    \"Item 2\",\n  ]\n}\n</code-example>\n<p>The <code>get()</code> method on <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> makes accessing this data straightforward.</p>\n<code-example language=\"javascript\">\n@Component(...)\nexport class MyComponent implements NgOnInit {\n  // Inject HttpClient into your component or service.\n  constructor(private http: HttpClient) {}\n  \n  ngOnInit(): void {\n    // Make the HTTP request:\n    this.http.get('/api/items').subscribe(data => {\n      // Read the result field from the JSON response.\n      this.results = data['results'];\n    });\n  }\n}\n</code-example>\n<h3 id=\"typechecking-the-response\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#typechecking-the-response\"><i class=\"material-icons\">link</i></a>Typechecking the response</h3>\n<p>In the above example, the <code>data['results']</code> field access stands out because you use bracket notation to access the results field. If you tried to write <code>data.results</code>, TypeScript would correctly complain that the <code>Object</code> coming back from HTTP does not have a <code>results</code> property. That's because while <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> parsed the JSON response into an <code>Object</code>, it doesn't know what shape that object is.</p>\n<p>You can, however, tell <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> what type the response will be, which is recommended.\nTo do so, first you define an interface with the correct shape:</p>\n<code-example language=\"javascript\">\ninterface DevelopersResponse {\n  results: string[];\n}\n</code-example>\n<p>Then, when you make the <code>HttpClient.get</code> call, pass a type parameter:</p>\n<code-example language=\"javascript\">\nhttp.get&#x3C;ItemsResponse>('/api/items').subscribe(data => {\n  // data is now an instance of type ItemsResponse, so you can do this:\n  this.results = data.results;\n});\n</code-example>\n<h3 id=\"reading-the-full-response\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#reading-the-full-response\"><i class=\"material-icons\">link</i></a>Reading the full response</h3>\n<p>The response body doesn't return all the data you may need. Sometimes servers return special headers or status codes to indicate certain conditions, and inspecting those can be necessary. To do this, you can tell <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> you want the full response instead of just the body with the <code>observe</code> option:</p>\n<code-example language=\"javascript\">\nhttp\n  .get&#x3C;MyJsonData>('/data.json', {observe: 'response'})\n  .subscribe(resp => {\n    // Here, resp is of type HttpResponse&#x3C;MyJsonData>.\n    // You can inspect its headers:\n    console.log(resp.headers.get('X-Custom-Header'));\n    // And access the body directly, which is typed as MyJsonData as requested.\n    console.log(resp.body.someField);\n  });\n</code-example>\n<p>As you can see, the resulting object has a <code>body</code> property of the correct type.</p>\n<h3 id=\"error-handling\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#error-handling\"><i class=\"material-icons\">link</i></a>Error handling</h3>\n<p>What happens if the request fails on the server, or if a poor network connection prevents it from even reaching the server? <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> will return an <em>error</em> instead of a successful response.</p>\n<p>To handle it, add an error handler to your <code>.subscribe()</code> call:</p>\n<code-example language=\"javascript\">\nhttp\n  .get&#x3C;ItemsResponse>('/api/items')\n  .subscribe(\n    // Successful responses call the first callback.\n    data => {...},\n    // Errors will call this callback instead:\n    err => {\n      console.log('Something went wrong!');\n    }\n  });\n</code-example>\n<h4 id=\"getting-error-details\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#getting-error-details\"><i class=\"material-icons\">link</i></a>Getting error details</h4>\n<p>Detecting that an error occurred is one thing, but it's more useful to know what error actually occurred. The <code>err</code> parameter to the callback above is of type <code><a href=\"api/common/http/HttpErrorResponse\">HttpErrorResponse</a></code>, and contains useful information on what went wrong.</p>\n<p>There are two types of errors that can occur. If the backend returns an unsuccessful response code (404, 500, etc.), it gets returned as an error. Also, if something goes wrong client-side, such as an exception gets thrown in an RxJS operator, or if a network error prevents the request from completing successfully, an actual <code>Error</code> will be thrown.</p>\n<p>In both cases, you can look at the <code><a href=\"api/common/http/HttpErrorResponse\">HttpErrorResponse</a></code> to figure out what happened.</p>\n<code-example language=\"javascript\">\nhttp\n  .get&#x3C;ItemsResponse>('/api/items')\n  .subscribe(\n  \tdata => {...},\n    (err: HttpErrorResponse) => {\n      if (err.error instanceof Error) {\n        // A client-side or network error occurred. Handle it accordingly.\n        console.log('An error occurred:', err.error.message);\n      } else {\n        // The backend returned an unsuccessful response code.\n        // The response body may contain clues as to what went wrong,\n        console.log(`Backend returned code ${err.status}, body was: ${err.error}`);\n      }\n    }\n  });\n</code-example>\n<h4 id=\"retry\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#retry\"><i class=\"material-icons\">link</i></a><code>.retry()</code></h4>\n<p>One way to deal with errors is to simply retry the request. This strategy can be useful when the errors are transient and unlikely to repeat.</p>\n<p>RxJS has a useful operator called <code>.retry()</code>, which automatically resubscribes to an Observable, thus reissuing the request, upon encountering an error.</p>\n<p>First, import it:</p>\n<code-example language=\"js\">\nimport 'rxjs/add/operator/retry';\n</code-example>\n<p>Then, you can use it with HTTP Observables like this:</p>\n<code-example language=\"javascript\">\nhttp\n  .get&#x3C;ItemsResponse>('/api/items')\n  // Retry this request up to 3 times.\n  .retry(3)\n  // Any errors after the 3rd retry will fall through to the app.\n  .subscribe(...);\n</code-example>\n<h3 id=\"requesting-non-json-data\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#requesting-non-json-data\"><i class=\"material-icons\">link</i></a>Requesting non-JSON data</h3>\n<p>Not all APIs return JSON data. Suppose you want to read a text file on the server. You have to tell <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> that you expect a textual response:</p>\n<code-example language=\"javascript\">\nhttp\n  .get('/textfile.txt', {responseType: 'text'})\n  // The Observable returned by get() is of type Observable&#x3C;string>\n  // because a text response was specified. There's no need to pass\n  // a &#x3C;string> type parameter to get().\n  .subscribe(data => console.log(data));\n</code-example>\n<h2 id=\"sending-data-to-the-server\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#sending-data-to-the-server\"><i class=\"material-icons\">link</i></a>Sending data to the server</h2>\n<p>In addition to fetching data from the server, <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> supports mutating requests, that is, sending data to the server in various forms.</p>\n<h3 id=\"making-a-post-request\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#making-a-post-request\"><i class=\"material-icons\">link</i></a>Making a POST request</h3>\n<p>One common operation is to POST data to a server; for example when submitting a form. The code for\nsending a POST request is very similar to the code for GET:</p>\n<code-example language=\"javascript\">\nconst body = {name: 'Brad'};\n\nhttp\n  .post('/api/developers/add', body)\n  // See below - subscribe() is still necessary when using post().\n  .subscribe(...);\n</code-example>\n<div class=\"alert is-important\">\n<p><em>Note the <code>subscribe()</code> method.</em> All Observables returned from <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> are <em>cold</em>, which is to say that they are <em>blueprints</em> for making requests. Nothing will happen until you call <code>subscribe()</code>, and every such call will make a separate request. For example, this code sends a POST request with the same data twice:</p>\n<code-example language=\"javascript\">\nconst req = http.post('/api/items/add', body);\n// 0 requests made - .subscribe() not called.\nreq.subscribe();\n// 1 request made.\nreq.subscribe();\n// 2 requests made.\n</code-example>\n</div>\n<h3 id=\"configuring-other-parts-of-the-request\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#configuring-other-parts-of-the-request\"><i class=\"material-icons\">link</i></a>Configuring other parts of the request</h3>\n<p>Besides the URL and a possible request body, there are other aspects of an outgoing request which you may wish to configure. All of these are available via an options object, which you pass to the request.</p>\n<h4 id=\"headers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#headers\"><i class=\"material-icons\">link</i></a>Headers</h4>\n<p>One common task is adding an <code>Authorization</code> header to outgoing requests. Here's how you do that:</p>\n<code-example language=\"javascript\">\nhttp\n  .post('/api/items/add', body, {\n    headers: new HttpHeaders().set('Authorization', 'my-auth-token'),\n  })\n  .subscribe();\n</code-example>\n<p>The <code><a href=\"api/common/http/HttpHeaders\">HttpHeaders</a></code> class is immutable, so every <code>set()</code> returns a new instance and applies the changes.</p>\n<h4 id=\"url-parameters\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#url-parameters\"><i class=\"material-icons\">link</i></a>URL Parameters</h4>\n<p>Adding URL parameters works in the same way. To send a request with the <code>id</code> parameter set to <code>3</code>, you would do:</p>\n<code-example language=\"javascript\">\nhttp\n  .post('/api/items/add', body, {\n    params: new HttpParams().set('id', '3'),\n  })\n  .subscribe();\n</code-example>\n<p>In this way, you send the POST request to the URL <code>/api/items/add?id=3</code>.</p>\n<h2 id=\"advanced-usage\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#advanced-usage\"><i class=\"material-icons\">link</i></a>Advanced usage</h2>\n<p>The above sections detail how to use the basic HTTP functionality in <code>@angular/common/http</code>, but sometimes you need to do more than just make requests and get data back.</p>\n<h3 id=\"intercepting-all-requests-or-responses\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#intercepting-all-requests-or-responses\"><i class=\"material-icons\">link</i></a>Intercepting all requests or responses</h3>\n<p>A major feature of <code>@angular/common/http</code> is <em>interception</em>, the ability to declare interceptors which sit in between your application and the backend. When your application makes a request, interceptors transform it\nbefore sending it to the server, and the interceptors can transform the response on its way back before your application sees it. This is useful for everything from authentication to logging.</p>\n<h4 id=\"writing-an-interceptor\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#writing-an-interceptor\"><i class=\"material-icons\">link</i></a>Writing an interceptor</h4>\n<p>To implement an interceptor, you declare a class that implements <code><a href=\"api/common/http/HttpInterceptor\">HttpInterceptor</a></code>, which\nhas a single <code>intercept()</code> method. Here is a simple interceptor which does nothing but forward the request through without altering it:</p>\n<code-example language=\"javascript\">\nimport {Injectable} from '@angular/core';\nimport {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest) from '@angular/common/http';\n\n@Injectable()\nexport class NoopInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest&#x3C;any>, next: HttpHandler): Observable&#x3C;HttpEvent&#x3C;any>> {\n    return next.handle(Req);\n  }\n}\n</code-example>\n<p><code>intercept</code> is a method which transforms a request into an Observable that eventually returns the response. In this sense, each interceptor is entirely responsible for handling the request by itself.</p>\n<p>Most of the time, though, interceptors will make some minor change to the request and forward it to the rest of the chain. That's where the <code>next</code> parameter comes in. <code>next</code> is an <code><a href=\"api/common/http/HttpHandler\">HttpHandler</a></code>, an interface that, similar to <code>intercept</code>, transforms a request into an Observable for the response. In an interceptor, <code>next</code> always represents the next interceptor in the chain, if any, or the final backend if there are no more interceptors. So most interceptors will end by calling <code>next</code> on the request they transformed.</p>\n<p>Our do-nothing handler simply calls <code>next.handle</code> on the original request, forwarding it without mutating it at all.</p>\n<p>This pattern is similar to those in middleware frameworks such as Express.js.</p>\n<h5 id=\"providing-your-interceptor\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#providing-your-interceptor\"><i class=\"material-icons\">link</i></a>Providing your interceptor</h5>\n<p>Simply declaring the <code>NoopInterceptor</code> above doesn't cause your app to use it. You need to wire it up in your app module by providing it as an interceptor, as follows:</p>\n<code-example language=\"javascript\">\nimport {NgModule} from '@angular/core';\nimport {HTTP_INTERCEPTORS} from '@angular/common/http';\n\n@NgModule({\n  providers: [{\n    provide: HTTP_INTERCEPTORS,\n    useClass: NoopInterceptor,\n    multi: true,\n  }],\n})\nexport class AppModule {}\n</code-example>\n<p>Note the <code>multi: true</code> option. This is required and tells Angular that <code><a href=\"api/common/http/HTTP_INTERCEPTORS\">HTTP_INTERCEPTORS</a></code> is an array of values, rather than a single value.</p>\n<h5 id=\"events\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#events\"><i class=\"material-icons\">link</i></a>Events</h5>\n<p>You may have also noticed that the Observable returned by <code>intercept</code> and <code>HttpHandler.handle</code> is not an <code>Observable&#x3C;HttpResponse&#x3C;any>></code> but an <code>Observable&#x3C;HttpEvent&#x3C;any>></code>. That's because interceptors work at a lower level than the <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> interface. A single request can generate multiple events, including upload and download progress events. The <code><a href=\"api/common/http/HttpResponse\">HttpResponse</a></code> class is actually an event itself, with a <code>type</code> of <code>HttpEventType.HttpResponseEvent</code>.</p>\n<p>An interceptor must pass through all events that it does not understand or intend to modify. It must not filter out events it didn't expect to process. Many interceptors are only concerned with the outgoing request, though, and will simply return the event stream from <code>next</code> without modifying it.</p>\n<h5 id=\"ordering\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#ordering\"><i class=\"material-icons\">link</i></a>Ordering</h5>\n<p>When you provide multiple interceptors in an application, Angular applies them in the order that you\nprovided them.</p>\n<h5 id=\"immutability\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#immutability\"><i class=\"material-icons\">link</i></a>Immutability</h5>\n<p>Interceptors exist to examine and mutate outgoing requests and incoming responses. However, it may be surprising to learn that the <code><a href=\"api/common/http/HttpRequest\">HttpRequest</a></code> and <code><a href=\"api/common/http/HttpResponse\">HttpResponse</a></code> classes are largely immutable.</p>\n<p>This is for a reason: because the app may retry requests, the interceptor chain may process an individual request multiple times. If requests were mutable, a retried request would be different than the original request. Immutability ensures the interceptors see the same request for each try.</p>\n<p>There is one case where type safety cannot protect you when writing interceptors—the request body. It is invalid to mutate a request body within an interceptor, but this is not checked by the type system.</p>\n<p>If you have a need to mutate the request body, you need to copy the request body, mutate the copy, and then use <code>clone()</code> to copy the request and set the new body.</p>\n<p>Since requests are immutable, they cannot be modified directly. To mutate them, use <code>clone()</code>:</p>\n<code-example language=\"javascript\">\nintercept(req: HttpRequest&#x3C;any>, next: HttpHandler): Observable&#x3C;HttpError&#x3C;any>> {\n  // This is a duplicate. It is exactly the same as the original.\n  const dupReq = req.clone();\n  \n  // Change the URL and replace 'http://' with 'https://'\n  const secureReq = req.clone({url: req.url.replace('http://', 'https://')});\n}\n</code-example>\n<p>As you can see, the hash accepted by <code>clone()</code> allows you to mutate specific properties of the request while copying the others.</p>\n<h4 id=\"setting-new-headers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setting-new-headers\"><i class=\"material-icons\">link</i></a>Setting new headers</h4>\n<p>A common use of interceptors is to set default headers on outgoing responses. For example, assuming you have an injectable <code>AuthService</code> which can provide an authentication token, here is how you would write an interceptor which adds it to all outgoing requests:</p>\n<code-example language=\"javascript\">\nimport {Injectable} from '@angular/core';\nimport {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest) from '@angular/common/http';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(private auth: AuthService) {}\n \n  intercept(req: HttpRequest&#x3C;any>, next: HttpHandler): Observable&#x3C;HttpEvent&#x3C;any>> {\n    // Get the auth header from the service.\n    const authHeader: this.auth.getAuthorizationHeader();\n    // Clone the request to add the new header.\n    const authReq = req.clone({headers: req.headers.set('Authorization', authHeader)});\n    // Pass on the cloned request instead of the original request.\n    return next.handle(authReq);\n  }\n}\n</code-example>\n<p>The practice of cloning a request to set new headers is so common that there's actually a shortcut for it:</p>\n<code-example language=\"javascript\">\nconst authReq = req.clone({setHeaders: {Authorization: authHeader}});\n</code-example>\n<p>An interceptor that alters headers can be used for a number of different operations, including:</p>\n<ul>\n<li>Authentication/authorization</li>\n<li>Caching behavior; for example, If-Modified-Since</li>\n<li>XSRF protection</li>\n</ul>\n<h4 id=\"logging\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#logging\"><i class=\"material-icons\">link</i></a>Logging</h4>\n<p>Because interceptors can process the request and response <em>together</em>, they can do things like log or time requests. Consider this interceptor which uses <code>console.log</code> to show how long each request takes:</p>\n<code-example language=\"javascript\">\nimport 'rxjs/add/operator/do';\n\nexport class TimingInterceptor implements HttpInterceptor {\n  constructor(private auth: AuthService) {}\n \n  intercept(req: HttpRequest&#x3C;any>, next: HttpHandler): Observable&#x3C;HttpEvent&#x3C;any>> {\n  \tconst elapsed = Date.now();\n    return next\n      .handle(req)\n      .do(event => {\n        if (event instanceof HttpResponse) {\n          const time = Date.now() - started;\n          console.log(`Request for ${req.urlWithParams} took ${elapsed} ms.`); \n        }\n      });\n  }\n}\n</code-example>\n<p>Notice the RxJS <code>do()</code> operator—it adds a side effect to an Observable without affecting the values on the stream. Here, it detects the <code><a href=\"api/common/http/HttpResponse\">HttpResponse</a></code> event and logs the time the request took.</p>\n<h4 id=\"caching\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#caching\"><i class=\"material-icons\">link</i></a>Caching</h4>\n<p>You can also use interceptors to implement caching. For this example, assume that you've written an HTTP cache with a simple interface:</p>\n<code-example language=\"javascript\">\nabstract class HttpCache {\n  /**\n   * Returns a cached response, if any, or null if not present.\n   */\n  abstract get(req: HttpRequest&#x3C;any>): HttpResponse&#x3C;any>|null;\n  \n  /**\n   * Adds or updates the response in the cache.\n   */\n  abstract put(req: HttpRequest&#x3C;any>, resp: HttpResponse&#x3C;any>): void;\n}\n</code-example>\n<p>An interceptor can apply this cache to outgoing requests.</p>\n<code-example language=\"javascript\">\n@Injectable()\nexport class CachingInterceptor implements HttpInterceptor {\n  constructor(private cache: HttpCache) {}\n \n  intercept(req: HttpRequest&#x3C;any>, next: HttpHandler): Observable&#x3C;HttpEvent&#x3C;any>> {\n  \t// Before doing anything, it's important to only cache GET requests.\n    // Skip this interceptor if the request method isn't GET.\n    if (req.method !== 'GET') {\n      return next.handle(req);\n    }\n  \n    // First, check the cache to see if this request exists.\n    const cachedResponse = this.cache.get(req);\n    if (cachedResponse) {\n      // A cached response exists. Serve it instead of forwarding\n      // the request to the next handler.\n      return Observable.of(cachedResponse);\n    }\n    \n    // No cached response exists. Go to the network, and cache\n    // the response when it arrives.\n    return next.handle(req).do(event => {\n      // Remember, there may be other events besides just the response.\n      if (event instanceof HttpResponse) {\n      \t// Update the cache.\n      \tthis.cache.put(req, event);\n      }\n    });\n  }\n}\n</code-example>\n<p>Obviously this example glosses over request matching, cache invalidation, etc., but it's easy to see that interceptors have a lot of power beyond just transforming requests. If desired, they can be used to completely take over the request flow.</p>\n<p>To really demonstrate their flexibility, you can change the above example to return <em>two</em> response events if the request exists in cache—the cached response first, and an updated network response later.</p>\n<code-example language=\"javascript\">\nintercept(req: HttpRequest&#x3C;any>, next: HttpHandler): Observable&#x3C;HttpEvent&#x3C;any>> {\n  // Still skip non-GET requests.\n  if (req.method !== 'GET') {\n    return next.handle(req);\n  }\n  \n  // This will be an Observable of the cached value if there is one,\n  // or an empty Observable otherwise. It starts out empty.\n  let maybeCachedResponse: Observable&#x3C;HttpEvent&#x3C;any>> = Observable.empty();\n  \n  // Check the cache.\n  const cachedResponse = this.cache.get(req);\n  if (cachedResponse) {\n    maybeCachedResponse = Observable.of(cachedResponse);\n  }\n  \n  // Create an Observable (but don't subscribe) that represents making\n  // the network request and caching the value.\n  const networkResponse = next.handle(req).do(event => {\n    // Just like before, check for the HttpResponse event and cache it.\n    if (event instanceof HttpResponse) {\n      this.cache.put(req, event);\n    }\n  });\n  \n  // Now, combine the two and send the cached response first (if there is\n  // one), and the network response second.\n  return Observable.concat(maybeCachedResponse, networkResponse);\n}\n</code-example>\n<p>Now anyone doing <code>http.get(url)</code> will receive <em>two</em> responses if that URL has been cached before.</p>\n<h3 id=\"listening-to-progress-events\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#listening-to-progress-events\"><i class=\"material-icons\">link</i></a>Listening to progress events</h3>\n<p>Sometimes applications need to transfer large amounts of data, and those transfers can take time. It's a good user experience practice to provide feedback on the progress of such transfers; for example, uploading files—and <code>@angular/common/http</code> supports this.</p>\n<p>To make a request with progress events enabled, first create an instance of <code><a href=\"api/common/http/HttpRequest\">HttpRequest</a></code> with the special <code>reportProgress</code> option set:</p>\n<code-example language=\"javascript\">\nconst req = new HttpRequest('POST', '/upload/file', file, {\n  reportProgress: true,\n});\n</code-example>\n<p>This option enables tracking of progress events. Remember, every progress event triggers\nchange detection, so only turn them on if you intend to actually update the UI on each event.</p>\n<p>Next, make the request through the <code>request()</code> method of <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code>. The result will be an Observable of events, just like with interceptors:</p>\n<code-example language=\"javascript\">\nhttp.request(req).subscribe(event => {\n  // Via this API, you get access to the raw event stream.\n  // Look for upload progress events.\n  if (event.type === HttpEventType.UploadProgress) {\n    // This is an upload progress event. Compute and show the % done:\n    const percentDone = Math.round(100 * event.loaded / event.total);\n    console.log(`File is ${percentDone}% uploaded.`);\n  } else if (event instanceof HttpResponse) {\n    console.log('File is completely uploaded!');\n  }\n});\n</code-example>\n<h2 id=\"testing-http-requests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#testing-http-requests\"><i class=\"material-icons\">link</i></a>Testing HTTP requests</h2>\n<p>Like any external dependency, the HTTP backend needs to be mocked as part of good testing practice. <code>@angular/common/http</code> provides a testing library <code>@angular/common/http/testing</code> that makes setting up such mocking straightforward.</p>\n<h3 id=\"mocking-philosophy\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#mocking-philosophy\"><i class=\"material-icons\">link</i></a>Mocking philosophy</h3>\n<p>Angular's HTTP testing library is designed for a pattern of testing where the app executes code and makes requests first. After that, tests expect that certain requests have or have not been made, perform assertions against those requests, and finally provide responses by \"flushing\" each expected request, which may trigger more new requests, etc. At the end, tests can optionally verify that the app has made no unexpected requests.</p>\n<h3 id=\"setup\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#setup\"><i class=\"material-icons\">link</i></a>Setup</h3>\n<p>To begin testing requests made through <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code>, import <code><a href=\"api/common/http/testing/HttpClientTestingModule\">HttpClientTestingModule</a></code> and add it to your <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> setup, like so:</p>\n<code-example language=\"javascript\">\nimport {HttpClientTestingModule} from '@angular/common/http/testing';\n\nbeforeEach(() => {\n  TestBed.configureTestingModule({\n    ...,\n    imports: [\n      HttpClientTestingModule,\n    ],\n  })\n});\n</code-example>\n<p>That's it. Now requests made in the course of your tests will hit the testing backend instead of the normal backend.</p>\n<h3 id=\"expecting-and-answering-requests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#expecting-and-answering-requests\"><i class=\"material-icons\">link</i></a>Expecting and answering requests</h3>\n<p>With the mock installed via the module, you can write a test that expects a GET Request to occur and provides a mock response. The following example does this by injecting both the <code><a href=\"api/common/http/HttpClient\">HttpClient</a></code> into the test and a class called <code><a href=\"api/common/http/testing/HttpTestingController\">HttpTestingController</a></code></p>\n<code-example language=\"javascript\">\nit('expects a GET request', inject([HttpClient, HttpTestingController], (http: HttpClient, httpMock: HttpTestingController) => {\n  // Make an HTTP GET request, and expect that it return an object\n  // of the form {name: 'Test Data'}.\n  http\n    .get('/data')\n    .subscribe(data => expect(data['name']).toEqual('Test Data'));\n    \n  // At this point, the request is pending, and no response has been\n  // sent. The next step is to expect that the request happened.\n  const req = httpMock.expectOne('/test');\n  \n  // If no request with that URL was made, or if multiple requests match,\n  // expectOne() would throw. However this test makes only one request to\n  // this URL, so it will match and return a mock request. The mock request\n  // can be used to deliver a response or make assertions against the\n  // request. In this case, the test asserts that the request is a GET.\n  expect(req.request.method).toEqual('GET');\n  \n  // Next, fulfill the request by transmitting a response.\n  req.flush({name: 'Test Data'});\n  \n  // Finally, assert that there are no outstanding requests.\n  mockHttp.verify();\n}));\n</code-example>\n<p>The last step, verifying that no requests remain outstanding, is common enough for you to move it into an <code>afterEach()</code> step:</p>\n<code-example language=\"javascript\">\nafterEach(inject([HttpTestingController], (httpMock: HttpTestingController) => {\n  mockHttp.verify();\n}));\n</code-example>\n<h4 id=\"custom-request-expectations\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#custom-request-expectations\"><i class=\"material-icons\">link</i></a>Custom request expectations</h4>\n<p>If matching by URL isn't sufficient, it's possible to implement your own matching function. For example, you could look for an outgoing request that has an Authorization header:</p>\n<code-example language=\"javascript\">\nconst req = mockHttp.expectOne((req) => req.headers.has('Authorization'));\n</code-example>\n<p>Just as with the <code>expectOne()</code> by URL in the test above, if 0 or 2+ requests match this expectation, it will throw.</p>\n<h4 id=\"handling-more-than-one-request\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/http#handling-more-than-one-request\"><i class=\"material-icons\">link</i></a>Handling more than one request</h4>\n<p>If you need to respond to duplicate requests in your test, use the <code>match()</code> API instead of <code>expectOne()</code>, which takes the same arguments but returns an array of matching requests. Once returned, these requests are removed from future matching and are your responsibility to verify and flush.</p>\n<code-example language=\"javascript\">\n// Expect that 5 pings have been made and flush them.\nconst reqs = mockHttp.match('/ping');\nexpect(reqs.length).toBe(5);\nreqs.forEach(req => req.flush());\n</code-example>\n\n</div>"
}