{
  "id": "guide/ngmodule",
  "title": "NgModules",
  "contents": "\n<div class=\"content\">\n<h1 id=\"ngmodules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#ngmodules\"><i class=\"material-icons\">link</i></a>NgModules</h1>\n<p><strong>NgModules</strong> help organize an application into cohesive blocks of functionality.</p>\n<!-- CF: \"app\" and \"application\" are used interchangeably throughout this page.\nI'm not sure what's appropriate, so I left them as is for now.  -->\n<p>An NgModule is a class adorned with the <em>@NgModule</em> decorator function.\n<code>@NgModule</code> takes a metadata object that tells Angular how to compile and run module code.\nIt identifies the module's own components, directives, and pipes,\nmaking some of them public so external components can use them.\n<code>@NgModule</code> may add service providers to the application dependency injectors.\nAnd there are many more options covered here.</p>\n<p>Before reading this page, read the\n<a href=\"guide/bootstrapping\">The Root Module</a> page, which introduces NgModules and the essentials\nof creating and maintaining a single root <code>AppModule</code> for the entire application.</p>\n<p>This page covers NgModules in greater depth.</p>\n<!-- CF: See my comment in the \"Resolve directive conflicts\" section below proposing renaming or reorganizing that section.\n\n* [Angular modularity](guide/ngmodule#angular-modularity \"Add structure to the app with NgModule\")\n* [The application root module](guide/ngmodule#root-module \"The startup module that every app requires\")\n* [Bootstrap the root module](guide/ngmodule#bootstrap \"Launch the app in a browser with the root module as the entry point\")\n* [Declarations](guide/ngmodule#declarations \"Declare the components, directives, and pipes that belong to a module\")\n* [Providers](guide/ngmodule#providers \"Extend the app with additional services\")\n* [Imports](guide/ngmodule#imports \"Import components, directives, and pipes for use in component templates\")\n* [Resolve conflicts](guide/ngmodule#resolve-conflicts \"When two directives have the same selector\")\n* [Feature modules](guide/ngmodule#feature-modules \"Partition the app into feature modules\")\n* [Lazy loaded modules with the router](guide/ngmodule#lazy-load \"Load modules asynchronously\")\n* [Shared modules](guide/ngmodule#shared-module \"Create modules for commonly used components, directives, and pipes\")\n* [The Core module](guide/ngmodule#core-module \"Create a core module with app-wide singleton services and single-use components\")\n* [Configure core services with _forRoot_](guide/ngmodule#core-for-root \"Configure providers during module import\")\n* [Prevent reimport of the _CoreModule_](guide/ngmodule#prevent-reimport \"because bad things happen if a lazy loaded module imports Core\")\n<!--\n* [NgModule metadata properties](guide/ngmodule#ngmodule-properties \"A technical summary of the @NgModule metadata properties\")\n CF: This link goes to the top of this page. I would expect it to go to an \"NgModule metadata properties\"\n section at the end of this page, but that section doesn't exist. -->\n<h4 id=\"live-examples\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#live-examples\"><i class=\"material-icons\">link</i></a>Live examples</h4>\n<p>This page explains NgModules through a progression of improvements to a sample with a \"Tour of Heroes\" theme.\nHere's an index to live examples at key moments in the evolution of the sample:</p>\n<ul>\n<li><live-example plnkr=\"minimal.0\">A minimal NgModule app</live-example></li>\n<li><live-example plnkr=\"contact.1b\">The first contact module</live-example></li>\n<li><live-example plnkr=\"contact.2\">The revised contact module</live-example></li>\n<li><live-example plnkr=\"pre-shared.3\">Just before adding SharedModule</live-example></li>\n<li><live-example>The final version</live-example></li>\n</ul>\n<h4 id=\"frequently-asked-questions-faqs\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#frequently-asked-questions-faqs\"><i class=\"material-icons\">link</i></a>Frequently asked questions (FAQs)</h4>\n<p>This page covers NgModule concepts in a tutorial fashion.</p>\n<p>The companion <a href=\"guide/ngmodule-faq\" title=\"NgModule FAQs\">NgModule FAQs</a> guide\noffers answers to specific design and implementation questions.\nRead this page before reading those FAQs.</p>\n<hr>\n<a id=\"angular-modularity\"></a>\n<h2 id=\"angular-modularity\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#angular-modularity\"><i class=\"material-icons\">link</i></a>Angular modularity</h2>\n<p>Modules are a great way to organize an application and extend it with capabilities from external libraries.</p>\n<p>Many Angular libraries are modules (such as <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>, <code><a href=\"api/http/HttpModule\">HttpModule</a></code>, and <code><a href=\"api/router/RouterModule\">RouterModule</a></code>).\nMany third-party libraries are available as NgModules (such as\n<a href=\"https://material.angular.io/\">Material Design</a>,\n<a href=\"http://ionicframework.com/\">Ionic</a>,\n<a href=\"https://github.com/angular/angularfire2\">AngularFire2</a>).</p>\n<p>NgModules consolidate components, directives, and pipes into\ncohesive blocks of functionality, each focused on a\nfeature area, application business domain, workflow, or common collection of utilities.</p>\n<p>Modules can also add services to the application.\nSuch services might be internally developed, such as the application logger.\nServices can come from outside sources, such as the Angular router and Http client.</p>\n<p>Modules can be loaded eagerly when the application starts.\nThey can also be <em>lazy loaded</em> asynchronously by the router.</p>\n<p>An NgModule is a class decorated with <code>@NgModule</code> metadata. The metadata do the following:</p>\n<ul>\n<li>Declare which components, directives, and pipes belong to the module.</li>\n<li>Make some of those classes public so that other component templates can use them.</li>\n<li>Import other modules with the components, directives, and pipes needed by the components in <em>this</em> module.</li>\n<li>Provide services at the application level that any application component can use.</li>\n</ul>\n<p>Every Angular app has at least one module class, the <em>root module</em>.\nYou bootstrap that module to launch the application.</p>\n<p>The root module is all you need in a simple application with a few components.\nAs the app grows, you refactor the root module into <em>feature modules</em>\nthat represent collections of related functionality.\nYou then import these modules into the root module.</p>\n<p>Later in this page, you'll read about this process. For now, you'll start with the root module.</p>\n<a id=\"root-module\"></a>\n<h2 id=\"the-root-appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#the-root-appmodule\"><i class=\"material-icons\">link</i></a>The root <em>AppModule</em></h2>\n<p>Every Angular app has a <em>root module</em> class.\nBy convention, the <em>root module</em> class is called <code>AppModule</code> and it exists in a file named <code>app.module.ts</code>.</p>\n<p>The <code>AppModule</code> from the QuickStart seed on the <a href=\"guide/setup\">Setup</a> page is as minimal as possible:</p>\n<code-example path=\"setup/src/app/app.module.ts\" title=\"src/app/app.module.ts (minimal)\" linenums=\"false\">\nimport { NgModule }      from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AppComponent }  from './app.component';\n\n@NgModule({\n  imports:      [ BrowserModule ],\n  declarations: [ AppComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<p>The <code>@NgModule</code> decorator defines the metadata for the module.\nThis page takes an intuitive approach to understanding the metadata and fills in details as it progresses.</p>\n<p>The metadata imports a single helper module, <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code>, which every browser app must import.</p>\n<p><code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> registers critical application service providers.\nIt also includes common directives like <code><a href=\"api/common/NgIf\">NgIf</a></code> and <code><a href=\"api/common/NgFor\">NgFor</a></code>, which become immediately visible and usable\nin any of this module's component templates.</p>\n<p>The <code>declarations</code> list identifies the application's only component,\nthe <em>root component</em>, the top of the app's rather bare component tree.</p>\n<p>The example <code>AppComponent</code> simply displays a data-bound title:</p>\n<code-example path=\"ngmodule/src/app/app.component.0.ts\" title=\"src/app/app.component.ts (minimal)\" linenums=\"false\">\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'my-app',\n  template: '&#x3C;h1>{{title}}&#x3C;/h1>',\n})\nexport class AppComponent {\n  title = 'Minimal NgModule';\n}\n\n\n</code-example>\n<p>Lastly, the <code>@NgModule.bootstrap</code> property identifies this <code>AppComponent</code> as the <em>bootstrap component</em>.\nWhen Angular launches the app, it places the HTML rendering of <code>AppComponent</code> in the DOM,\ninside the <code>&#x3C;my-app></code> element tags of the <code>index.html</code>.</p>\n<a id=\"bootstrap\"></a>\n<h2 id=\"bootstrapping-in-maints\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#bootstrapping-in-maints\"><i class=\"material-icons\">link</i></a>Bootstrapping in <em>main.ts</em></h2>\n<p>You launch the application by bootstrapping the <code>AppModule</code> in the <code>main.ts</code> file.</p>\n<p>Angular offers a variety of bootstrapping options targeting multiple platforms.\nThis page describes two options, both targeting the browser.</p>\n<h3 id=\"compile-just-in-time-jit\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#compile-just-in-time-jit\"><i class=\"material-icons\">link</i></a>Compile just-in-time (JIT)</h3>\n<p>In the first, <em>dynamic</em> option, the <a href=\"guide/ngmodule-faq#q-angular-compiler\" title=\"About the Angular Compiler\">Angular compiler</a>\ncompiles the application in the browser and then launches the app.</p>\n<code-example path=\"ngmodule/src/main.ts\" title=\"src/main.ts (dynamic)\" linenums=\"false\">\n// The browser platform with a compiler\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\n// The app module\nimport { AppModule } from './app/app.module';\n\n// Compile and launch the module\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n\n</code-example>\n<p>The samples in this page demonstrate the dynamic bootstrapping approach.</p>\n<p><live-example embedded=\"\" plnkr=\"minimal.0\" img=\"guide/ngmodule/minimal-plunker.png\">Try the live example.</live-example></p>\n<h3 id=\"compile-ahead-of-time-aot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#compile-ahead-of-time-aot\"><i class=\"material-icons\">link</i></a>Compile ahead-of-time (AOT)</h3>\n<p>Consider the static alternative which can produce a much smaller application that\nlaunches faster, especially on mobile devices and high latency networks.</p>\n<p>In the <em>static</em> option, the Angular compiler runs ahead of time as part of the build process,\nproducing a collection of class factories in their own files.\nAmong them is the <code>AppModuleNgFactory</code>.</p>\n<p>The syntax for bootstrapping the pre-compiled <code>AppModuleNgFactory</code> is similar to\nthe dynamic version that bootstraps the <code>AppModule</code> class.</p>\n<code-example path=\"ngmodule/src/main-static.ts\" title=\"src/main.ts (static)\" linenums=\"false\">\n// The browser platform without a compiler\nimport { platformBrowser } from '@angular/platform-browser';\n\n// The app module factory produced by the static offline compiler\nimport { AppModuleNgFactory } from './app/app.module.ngfactory';\n\n// Launch with the app module factory.\nplatformBrowser().bootstrapModuleFactory(AppModuleNgFactory);\n\n</code-example>\n<p>Because the entire application was pre-compiled,\nAngular doesn't ship the Angular compiler to the browser and doesn't compile in the browser.</p>\n<p>The application code downloaded to the browser is much smaller than the dynamic equivalent\nand it's ready to execute immediately. The performance boost can be significant.</p>\n<p>Both the JIT and AOT compilers generate an <code>AppModuleNgFactory</code> class from the same <code>AppModule</code>\nsource code.\nThe JIT compiler creates that factory class on the fly, in memory, in the browser.\nThe AOT compiler outputs the factory to a physical file\nthat is imported here in the static version of <code>main.ts</code>.</p>\n<p>In general, the <code>AppModule</code> should neither know nor care how it is bootstrapped.</p>\n<p>Although the <code>AppModule</code> evolves as the app grows, the bootstrap code in <code>main.ts</code> doesn't change.\nThis is the last time you'll look at <code>main.ts</code>.</p>\n<hr>\n<a id=\"declarations\"></a>\n<h2 id=\"declare-directives-and-components\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#declare-directives-and-components\"><i class=\"material-icons\">link</i></a>Declare directives and components</h2>\n<p>As the app evolves,\nthe first addition is a <code>HighlightDirective</code>, an <a href=\"guide/attribute-directives\">attribute directive</a>\nthat sets the background color of the attached element.</p>\n<code-example path=\"ngmodule/src/app/highlight.directive.ts\" title=\"src/app/highlight.directive.ts\" linenums=\"false\">\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({ selector: '[highlight]' })\n/** Highlight the attached element in gold */\nexport class HighlightDirective {\n  constructor(el: ElementRef) {\n    el.nativeElement.style.backgroundColor = 'gold';\n    console.log(\n      `* AppRoot highlight called for ${el.nativeElement.tagName}`);\n  }\n}\n\n\n</code-example>\n<p>Update the <code>AppComponent</code> template to attach the directive to the title:</p>\n<code-example path=\"ngmodule/src/app/app.component.1.ts\" region=\"template\" title=\"src/app/app.component.ts\" linenums=\"false\">\ntemplate: '&#x3C;h1 highlight>{{title}}&#x3C;/h1>'\n\n</code-example>\n<p>If you ran the app now, Angular wouldn't recognize the <code>highlight</code> attribute and would ignore it.\nYou must declare the directive in <code>AppModule</code>.</p>\n<p>Import the <code>HighlightDirective</code> class and add it to the module's <code>declarations</code> like this:</p>\n<code-example path=\"ngmodule/src/app/app.module.1.ts\" region=\"directive\" title=\"src/app/app.module.ts\" linenums=\"false\">\ndeclarations: [\n  AppComponent,\n  HighlightDirective,\n],\n\n</code-example>\n<p>Refactor the title into its own <code>TitleComponent</code>.\nThe component's template binds to the component's <code>title</code> and <code>subtitle</code> properties like this:</p>\n<code-example path=\"ngmodule/src/app/title.component.html\" region=\"v1\" title=\"src/app/title.component.html\" linenums=\"false\">\n&#x3C;h1 highlight>{{title}} {{subtitle}}&#x3C;/h1>\n\n</code-example>\n<code-example path=\"ngmodule/src/app/title.component.ts\" region=\"v1\" title=\"src/app/title.component.ts\" linenums=\"false\">\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-title',\n  templateUrl: './title.component.html',\n})\nexport class TitleComponent {\n  @Input() subtitle = '';\n  title = 'NgModules';\n}\n\n</code-example>\n<p>Rewrite the <code>AppComponent</code> to display the new <code>TitleComponent</code> in the <code>&#x3C;app-title></code> element,\nusing an input binding to set the <code>subtitle</code>.</p>\n<code-example path=\"ngmodule/src/app/app.component.1.ts\" title=\"src/app/app.component.ts (v1)\" linenums=\"false\">\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'my-app',\n  template: '&#x3C;app-title [subtitle]=\"subtitle\">&#x3C;/app-title>'\n})\nexport class AppComponent {\n  subtitle = '(v1)';\n}\n\n</code-example>\n<p>Angular won't recognize the <code>&#x3C;app-title></code> tag until you declare it in <code>AppModule</code>.\nImport the <code>TitleComponent</code> class and add it to the module's <code>declarations</code>:</p>\n<code-example path=\"ngmodule/src/app/app.module.1.ts\" region=\"component\" title=\"src/app/app.module.ts\" linenums=\"false\">\ndeclarations: [\n  AppComponent,\n  HighlightDirective,\n  TitleComponent,\n],\n\n</code-example>\n<a id=\"providers\"></a>\n<h2 id=\"service-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#service-providers\"><i class=\"material-icons\">link</i></a>Service providers</h2>\n<p>Modules are a great way to provide services for all of the module's components.</p>\n<p>The <a href=\"guide/dependency-injection\">Dependency Injection</a> page describes\nthe Angular hierarchical dependency-injection system and how to configure that system\nwith <a href=\"guide/dependency-injection#providers\">providers</a> at different levels of the\napplication's component tree.</p>\n<p>A module can add providers to the application's root dependency injector, making those services\navailable everywhere in the application.</p>\n<p>Many applications capture information about the currently logged-in user and make that information\naccessible through a user service.\nThis sample application has a dummy implementation of such a <code>UserService</code>.</p>\n<code-example path=\"ngmodule/src/app/user.service.ts\" title=\"src/app/user.service.ts\" linenums=\"false\">\nimport { Injectable } from '@angular/core';\n\n@Injectable()\n/** Dummy version of an authenticated user service */\nexport class UserService {\n  userName = 'Sherlock Holmes';\n}\n\n\n</code-example>\n<p>The sample application should display a welcome message to the logged-in user just below the application title.\nUpdate the <code>TitleComponent</code> template to show the welcome message below the application title.</p>\n<code-example path=\"ngmodule/src/app/title.component.html\" title=\"src/app/title.component.html\" linenums=\"false\">\n&#x3C;h1 highlight>{{title}} {{subtitle}}&#x3C;/h1>\n&#x3C;p *ngIf=\"user\">\n  &#x3C;i>Welcome, {{user}}&#x3C;/i>\n&#x3C;p>\n\n\n\n</code-example>\n<p>Update the <code>TitleComponent</code> class with a constructor that injects the <code>UserService</code>\nand sets the component's <code>user</code> property from the service.</p>\n<code-example path=\"ngmodule/src/app/title.component.ts\" title=\"src/app/title.component.ts\" linenums=\"false\">\nimport { Component, Input } from '@angular/core';\nimport { UserService } from './user.service';\n\n@Component({\n  selector: 'app-title',\n  templateUrl: './title.component.html',\n})\nexport class TitleComponent {\n  @Input() subtitle = '';\n  title = 'NgModules';\n  user = '';\n\n  constructor(userService: UserService) {\n    this.user = userService.userName;\n  }\n}\n\n\n</code-example>\n<p>You've defined and used the service. Now to <em>provide</em> it for all components to use,\nadd it to a <code>providers</code> property in the <code>AppModule</code> metadata:</p>\n<code-example path=\"ngmodule/src/app/app.module.1.ts\" region=\"providers\" title=\"src/app/app.module.ts (providers)\" linenums=\"false\">\nproviders: [ UserService ],\n\n</code-example>\n<a id=\"imports\"></a>\n<h2 id=\"import-supporting-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#import-supporting-modules\"><i class=\"material-icons\">link</i></a>Import supporting modules</h2>\n<p>In the revised <code>TitleComponent</code>, an <code>*ngIf</code> directive guards the message.\nThere is no message if there is no user.</p>\n<code-example path=\"ngmodule/src/app/title.component.html\" region=\"ngIf\" title=\"src/app/title.component.html (ngIf)\" linenums=\"false\">\n&#x3C;p *ngIf=\"user\">\n  &#x3C;i>Welcome, {{user}}&#x3C;/i>\n&#x3C;p>\n\n</code-example>\n<p>Although <code>AppModule</code> doesn't declare <code><a href=\"api/common/NgIf\">NgIf</a></code>, the application still compiles and runs.\nHow can that be? The Angular compiler should either ignore or complain about unrecognized HTML.</p>\n<p>Angular does recognize <code><a href=\"api/common/NgIf\">NgIf</a></code> because you imported it earlier.\nThe initial version of <code>AppModule</code> imports <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code>.</p>\n<code-example path=\"ngmodule/src/app/app.module.0.ts\" region=\"imports\" title=\"src/app/app.module.ts (imports)\" linenums=\"false\">\nimports: [ BrowserModule ],\n\n</code-example>\n<p>Importing <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> made all of its public components, directives, and pipes visible\nto the component templates in <code>AppModule</code>.</p>\n<div class=\"l-sub-section\">\n<p>More accurately, <code><a href=\"api/common/NgIf\">NgIf</a></code> is declared in <code><a href=\"api/common/CommonModule\">CommonModule</a></code> from <code>@angular/common</code>.</p>\n<p><code><a href=\"api/common/CommonModule\">CommonModule</a></code> contributes many of the common directives that applications need, including <code>ngIf</code> and <code>ngFor</code>.</p>\n<p><code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> imports <code><a href=\"api/common/CommonModule\">CommonModule</a></code> and <a href=\"guide/ngmodule-faq#q-re-export\">re-exports</a> it.\nThe net effect is that an importer of <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> gets <code><a href=\"api/common/CommonModule\">CommonModule</a></code> directives automatically.</p>\n</div>\n<p>Many familiar Angular directives don't belong to <code><a href=\"api/common/CommonModule\">CommonModule</a></code>.\nFor example,  <code><a href=\"api/forms/NgModel\">NgModel</a></code> and <code><a href=\"api/router/RouterLink\">RouterLink</a></code> belong to Angular's <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> and <code><a href=\"api/router/RouterModule\">RouterModule</a></code> respectively.\nYou must import those modules before you can use their directives.</p>\n<p>To illustrate this point, you'll extend the sample app with <code>ContactComponent</code>,\na form component that imports form support from the Angular <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.</p>\n<h3 class=\"no-toc\" id=\"add-the-_contactcomponent_\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#add-the-_contactcomponent_\"><i class=\"material-icons\">link</i></a>Add the _ContactComponent_</h3>\n<p><a href=\"guide/forms\">Angular forms</a> are a great way to manage user data entry.</p>\n<p>The <code>ContactComponent</code> presents a \"contact editor,\"\nimplemented with Angular forms in the <a href=\"guide/forms#template-driven\">template-driven form</a> style.</p>\n<div class=\"l-sub-section\">\n<h3 class=\"no-toc\" id=\"angular-form-styles\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#angular-form-styles\"><i class=\"material-icons\">link</i></a>Angular form styles</h3>\n<p>You can write Angular form components in\ntemplate-driven or\n<a href=\"guide/dynamic-form\">reactive</a> style.</p>\n<!-- CF: this link goes to a page titled \"Dynamic Forms\". Should the link text be \"dynamic\" instead of \"reactive\"? -->\n<p>The following sample imports the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> from <code>@angular/forms</code> because\nthe <code>ContactComponent</code> is written in <em>template-driven</em> style.\nModules with components written in the <em>reactive</em> style\nimport the <code><a href=\"api/forms/ReactiveFormsModule\">ReactiveFormsModule</a></code>.</p>\n</div>\n<p>The <code>ContactComponent</code> selector matches an element named <code>&#x3C;app-contact></code>.\nAdd an element with that name to the <code>AppComponent</code> template, just below the <code>&#x3C;app-title></code>:</p>\n<code-example path=\"ngmodule/src/app/app.component.1b.ts\" region=\"template\" title=\"src/app/app.component.ts (template)\" linenums=\"false\">\ntemplate: `\n  &#x3C;app-title [subtitle]=\"subtitle\">&#x3C;/app-title>\n  &#x3C;app-contact>&#x3C;/app-contact>\n`\n\n</code-example>\n<p>Form components are often complex. The <code>ContactComponent</code> has its own <code>ContactService</code>\nand <a href=\"guide/pipes#custom-pipes\">custom pipe</a> (called <code>Awesome</code>),\nand an alternative version of the <code>HighlightDirective</code>.</p>\n<p>To make it manageable, place all contact-related material in an <code>src/app/contact</code> folder\nand break the component into three constituent HTML, TypeScript, and css files:</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/contact/contact.component.html\" path=\"ngmodule/src/app/contact/contact.component.html\">\n&#x3C;h2>Contact of {{userName}}&#x3C;/h2>\n&#x3C;div *ngIf=\"msg\" class=\"msg\">{{msg}}&#x3C;/div>\n\n&#x3C;form *ngIf=\"contacts\" (ngSubmit)=\"onSubmit()\" #contactForm=\"ngForm\">\n  &#x3C;h3 highlight>{{ contact.name | awesome }}&#x3C;/h3>\n  &#x3C;div class=\"form-group\">\n    &#x3C;label for=\"name\">Name&#x3C;/label>\n    &#x3C;input type=\"text\" class=\"form-control\" required\n      [(ngModel)]=\"contact.name\"\n        name=\"name\"  #name=\"ngModel\" >\n    &#x3C;div [hidden]=\"name.valid\" class=\"alert alert-danger\">\n      Name is required\n    &#x3C;/div>\n  &#x3C;/div>\n  &#x3C;br>\n  &#x3C;button type=\"submit\" class=\"btn btn-default\" [disabled]=\"!contactForm.form.valid\">Save&#x3C;/button>\n  &#x3C;button type=\"button\" class=\"btn\" (click)=\"next()\" [disabled]=\"!contactForm.form.valid\">Next Contact&#x3C;/button>\n  &#x3C;button type=\"button\" class=\"btn\" (click)=\"newContact()\">New Contact&#x3C;/button>\n&#x3C;/form>\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/contact.component.ts\" path=\"ngmodule/src/app/contact/contact.component.3.ts\">\nimport { Component, OnInit }      from '@angular/core';\n\nimport { Contact, ContactService } from './contact.service';\nimport { UserService }    from '../user.service';\n\n@Component({\n  selector: 'app-contact',\n  templateUrl: './contact.component.html',\n  styleUrls: [ './contact.component.css' ]\n})\nexport class ContactComponent implements OnInit {\n  contact:  Contact;\n  contacts: Contact[];\n\n  msg = 'Loading contacts ...';\n  userName = '';\n\n  constructor(private contactService: ContactService, userService: UserService) {\n    this.userName = userService.userName;\n  }\n\n  ngOnInit() {\n    this.contactService.getContacts().then(contacts => {\n      this.msg = '';\n      this.contacts = contacts;\n      this.contact = contacts[0];\n    });\n  }\n\n  next() {\n    let ix = 1 + this.contacts.indexOf(this.contact);\n    if (ix >= this.contacts.length) { ix = 0; }\n    this.contact = this.contacts[ix];\n  }\n\n  onSubmit() {\n    // POST-DEMO TODO: do something like save it\n    this.displayMessage('Saved ' + this.contact.name);\n  }\n\n  newContact() {\n    this.displayMessage('New contact');\n    this.contact = {id: 42, name: ''};\n    this.contacts.push(this.contact);\n  }\n\n  /** Display a message briefly, then remove it. */\n  displayMessage(msg: string) {\n    this.msg = msg;\n    setTimeout(() => this.msg = '', 1500);\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/contact.component.css\" path=\"ngmodule/src/app/contact/contact.component.css\">\n.ng-valid[required] {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid {\n  border-left: 5px solid #a94442; /* red */\n}\n\n.alert {\n  padding: 15px;\n  margin: 8px 0;\n  border: 1px solid transparent;\n  border-radius: 4px;\n}\n.alert-danger {\n  color: #a94442;\n  background-color: #f2dede;\n  border-color: #ebccd1;\n}\n\n.msg {\n  color: blue;\n  background-color: whitesmoke;\n  border: 1px solid transparent;\n  border-radius: 4px;\n  margin-bottom: 20px;\n}\n\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/contact.service.ts\" path=\"ngmodule/src/app/contact/contact.service.ts\">\nimport { Injectable } from '@angular/core';\n\nexport class Contact {\n  constructor(public id: number, public name: string) { }\n}\n\nconst CONTACTS: Contact[] = [\n  new Contact(21, 'Sam Spade'),\n  new Contact(22, 'Nick Danger'),\n  new Contact(23, 'Nancy Drew')\n];\n\nconst FETCH_LATENCY = 500;\n\n@Injectable()\nexport class ContactService {\n\n  getContacts() {\n    return new Promise&#x3C;Contact[]>(resolve => {\n      setTimeout(() => { resolve(CONTACTS); }, FETCH_LATENCY);\n    });\n  }\n\n  getContact(id: number | string) {\n    return this.getContacts()\n      .then(heroes => heroes.find(hero => hero.id === +id));\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/awesome.pipe.ts\" path=\"ngmodule/src/app/contact/awesome.pipe.ts\">\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({ name: 'awesome' })\n/** Precede the input string with the word \"Awesome \" */\nexport class AwesomePipe implements PipeTransform {\n  transform(phrase: string) {\n    return phrase ? 'Awesome ' + phrase : '';\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/highlight.directive.ts\" path=\"ngmodule/src/app/contact/highlight.directive.ts\">\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({ selector: '[highlight], input' })\n/** Highlight the attached element or an InputElement in blue */\nexport class HighlightDirective {\n  constructor(el: ElementRef) {\n    el.nativeElement.style.backgroundColor = 'powderblue';\n    console.log(\n      `* Contact highlight called for ${el.nativeElement.tagName}`);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p>In the middle of the component template,\nnotice the two-way data binding <code>[(ngModel)]</code>.\n<code>ngModel</code> is the selector for the <code><a href=\"api/forms/NgModel\">NgModel</a></code> directive.</p>\n<p>Although <code><a href=\"api/forms/NgModel\">NgModel</a></code> is an Angular directive, the <em>Angular compiler</em> won't recognize it for the following reasons:</p>\n<ul>\n<li><code>AppModule</code> doesn't declare <code><a href=\"api/forms/NgModel\">NgModel</a></code>.</li>\n<li><code><a href=\"api/forms/NgModel\">NgModel</a></code> wasn't imported via <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code>.</li>\n</ul>\n<p>Even if Angular somehow recognized <code>ngModel</code>,\n<code>ContactComponent</code> wouldn't behave like an Angular form because\nform features such as validation aren't yet available.</p>\n<h3 class=\"no-toc\" id=\"import-the-formsmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#import-the-formsmodule\"><i class=\"material-icons\">link</i></a>Import the FormsModule</h3>\n<p>Add the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> to the <code>AppModule</code> metadata's <code>imports</code> list.</p>\n<code-example path=\"ngmodule/src/app/app.module.1.ts\" region=\"imports\" title=\"src/app/app.module.ts\" linenums=\"false\">\nimports: [ BrowserModule, FormsModule ],\n\n</code-example>\n<p>Now <code>[(ngModel)]</code> binding will work and the user input will be validated by Angular forms,\nonce you declare the new component, pipe, and directive.</p>\n<div class=\"alert is-critical\">\n<p><em>Do not</em> add <code><a href=\"api/forms/NgModel\">NgModel</a></code>—or the <code>FORMS_DIRECTIVES</code>—to\nthe <code>AppModule</code> metadata's declarations.\nThese directives belong to the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.</p>\n<p>Components, directives, and pipes belong to <em>one module only</em>.</p>\n<p><em>Never re-declare classes that belong to another module.</em></p>\n</div>\n<a id=\"declare-pipe\"></a>\n<h3 class=\"no-toc\" id=\"declare-the-contact-component-directive-and-pipe\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#declare-the-contact-component-directive-and-pipe\"><i class=\"material-icons\">link</i></a>Declare the contact component, directive, and pipe</h3>\n<p>The application won't compile until you declare the contact component, directive, and pipe.\nUpdate the <code>declarations</code> in the  <code>AppModule</code> accordingly:</p>\n<code-example path=\"ngmodule/src/app/app.module.1.ts\" region=\"declarations\" title=\"src/app/app.module.ts (declarations)\" linenums=\"false\">\ndeclarations: [\n  AppComponent,\n  HighlightDirective,\n  TitleComponent,\n\n  AwesomePipe,\n  ContactComponent,\n  ContactHighlightDirective\n],\n\n</code-example>\n<a id=\"import-name-conflict\"></a>\n<div class=\"l-sub-section\">\n<p>There are two directives with the same name, both called <code>HighlightDirective</code>.</p>\n<p>To work around this, create an alias for the contact version using the <code>as</code> JavaScript import keyword.</p>\n<code-example path=\"ngmodule/src/app/app.module.1b.ts\" region=\"import-alias\" title=\"src/app/app.module.1b.ts\" linenums=\"false\">\nimport {\n  HighlightDirective as ContactHighlightDirective\n} from './contact/highlight.directive';\n\n</code-example>\n<p>This solves the immediate issue of referencing both directive <em>types</em> in the same file but\nleaves another issue unresolved.\nYou'll learn more about that issue later in this page, in <a href=\"guide/ngmodule#resolve-conflicts\">Resolve directive conflicts</a>.</p>\n</div>\n<h3 class=\"no-toc\" id=\"provide-the-_contactservice_\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#provide-the-_contactservice_\"><i class=\"material-icons\">link</i></a>Provide the _ContactService_</h3>\nThe `ContactComponent` displays contacts retrieved by the `ContactService`,\nwhich Angular injects into its constructor.\n<p>You have to provide that service somewhere.\nThe <code>ContactComponent</code> could provide it,\nbut then the service would be scoped to this component only.\nYou want to share this service with other contact-related components that you'll surely add later.</p>\n<p>In this app, add <code>ContactService</code> to the <code>AppModule</code> metadata's <code>providers</code> list:</p>\n<code-example path=\"ngmodule/src/app/app.module.1b.ts\" region=\"providers\" title=\"src/app/app.module.ts (providers)\" linenums=\"false\">\nproviders: [ ContactService, UserService ],\n\n</code-example>\n<p>Now you can inject <code>ContactService</code> (like <code>UserService</code>) into any component in the application.</p>\n<a id=\"application-scoped-providers\"></a>\n<div class=\"l-sub-section\">\n<h3 class=\"no-toc\" id=\"application-scoped-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#application-scoped-providers\"><i class=\"material-icons\">link</i></a>Application-scoped providers</h3>\n  The `ContactService` provider is _application_-scoped because Angular\n  registers a module's `providers` with the application's *root injector*.\n<p>  Architecturally, the <code>ContactService</code> belongs to the Contact business domain.\nClasses in other domains don't need the <code>ContactService</code> and shouldn't inject it.</p>\n<p>  You might expect Angular to offer a <em>module</em>-scoping mechanism to enforce this design.\nIt doesn't. NgModule instances, unlike components, don't have their own injectors\nso they can't have their own provider scopes.</p>\n<p>  This omission is intentional.\nNgModules are designed primarily to extend an application,\nto enrich the entire app with the module's capabilities.</p>\n<p>  In practice, service scoping is rarely an issue.\nNon-contact components can't accidentally inject the <code>ContactService</code>.\nTo inject <code>ContactService</code>, you must first import its <em>type</em>.\nOnly Contact components should import the <code>ContactService</code> type.</p>\n<p>  Read more in the <a href=\"guide/ngmodule-faq#q-component-scoped-providers\">How do I restrict service scope to a module?</a> section\nof the <a href=\"guide/ngmodule-faq\">NgModule FAQs</a> page.</p>\n</div>\n<h3 class=\"no-toc\" id=\"run-the-app\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#run-the-app\"><i class=\"material-icons\">link</i></a>Run the app</h3>\nEverything is in place to run the application with its contact editor.\n<p>The app file structure looks like this:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    app\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      app.component.ts\n    </div>\n    <div class=\"file\">\n      app.module.ts\n    </div>\n    <div class=\"file\">\n      highlight.directive.ts\n    </div>\n    <div class=\"file\">\n      title.component.(html|ts)\n    </div>\n    <div class=\"file\">\n      user.service.ts\n    </div>\n    <div class=\"file\">\n      contact\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        awesome.pipe.ts\n      </div>\n      <div class=\"file\">\n        contact.component.(css|html|ts)\n      </div>\n      <div class=\"file\">\n        contact.service.ts\n      </div>\n      <div class=\"file\">\n        highlight.directive.ts\n      </div>\n    </div>\n  </div>\n</div>\n<p>Try the example:</p>\n<p><live-example embedded=\"\" plnkr=\"contact.1b\" img=\"guide/ngmodule/contact-1b-plunker.png\"></live-example></p>\n<a id=\"resolve-conflicts\"></a>\n<h2 id=\"resolve-directive-conflicts\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#resolve-directive-conflicts\"><i class=\"material-icons\">link</i></a>Resolve directive conflicts</h2>\n<!-- CF: This section describes directive conflicts in detail, but doesn't describe how to resolve them.\n This section seems like more of an introduction to the next section, \"Feature modules\".\n Consider moving this section to be a child section of \"Feature modules\", or striking \"Resolve\" from this title. -->\n<p>An issue arose <a href=\"guide/ngmodule#import-name-conflict\">earlier</a> when you declared the contact's <code>HighlightDirective</code> because\nyou already had a <code>HighlightDirective</code> class at the application level.</p>\n<p>The selectors of the two directives both highlight the attached element with a different color.</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/highlight.directive.ts\" path=\"ngmodule/src/app/highlight.directive.ts\">\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({ selector: '[highlight]' })\n/** Highlight the attached element in gold */\nexport class HighlightDirective {\n  constructor(el: ElementRef) {\n    el.nativeElement.style.backgroundColor = 'gold';\n    console.log(\n      `* AppRoot highlight called for ${el.nativeElement.tagName}`);\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/highlight.directive.ts\" path=\"ngmodule/src/app/contact/highlight.directive.ts\">\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({ selector: '[highlight], input' })\n/** Highlight the attached element or an InputElement in blue */\nexport class HighlightDirective {\n  constructor(el: ElementRef) {\n    el.nativeElement.style.backgroundColor = 'powderblue';\n    console.log(\n      `* Contact highlight called for ${el.nativeElement.tagName}`);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p>Both directives are declared in this module so both directives are active.</p>\n<p>When the two directives compete to color the same element,\nthe directive that's declared later wins because its DOM changes overwrite the first.\nIn this case, the contact's <code>HighlightDirective</code> makes the application title text blue\nwhen it should stay gold.</p>\n<div class=\"l-sub-section\">\n<p>The issue is that two different classes are trying to do the same thing.</p>\n<p>It's OK to import the same directive class multiple times.\nAngular removes duplicate classes and only registers one of them.</p>\n<p>But from Angular's perspective, two different classes, defined in different files, that have the same name\nare not duplicates. Angular keeps both directives and\nthey take turns modifying the same HTML element.</p>\n</div>\n<p>At least the app still compiles.\nIf you define two different component classes with the same selector specifying the same element tag,\nthe compiler reports an error. It can't insert two components in the same DOM location.</p>\n<p>To eliminate component and directive conflicts, create feature modules\nthat insulate the declarations in one module from the declarations in another.</p>\n<a id=\"feature-modules\"></a>\n<h2 id=\"feature-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#feature-modules\"><i class=\"material-icons\">link</i></a>Feature modules</h2>\n<p>This application isn't big yet, but it's already experiencing structural issues.</p>\n<ul>\n<li>The root <code>AppModule</code> grows larger with each new application class.</li>\n<li>There are conflicting directives.\nThe <code>HighlightDirective</code> in the contact re-colors the work done by the <code>HighlightDirective</code> declared in <code>AppModule</code>.\nAlso, it colors the application title text when it should color only the <code>ContactComponent</code>.</li>\n<li>The app lacks clear boundaries between contact functionality and other application features.\nThat lack of clarity makes it harder to assign development responsibilities to different teams.</li>\n</ul>\n<p>You can resolve these issues with <em>feature modules</em>.</p>\n<p>A feature module is a class adorned by the <code>@NgModule</code> decorator and its metadata,\njust like a root module.\nFeature module metadata have the same properties as the metadata for a root module.</p>\n<p>The root module and the feature module share the same execution context.\nThey share the same dependency injector, which means the services in one module\nare available to all.</p>\n<p>The modules have the following significant technical differences:</p>\n<ul>\n<li>You <em>boot</em> the root module to <em>launch</em> the app;\nyou <em>import</em> a feature module to <em>extend</em> the app.</li>\n<li>A feature module can expose or hide its implementation from other modules.</li>\n</ul>\n<p>Otherwise, a feature module is distinguished primarily by its intent.</p>\n<p>A feature module delivers a cohesive set of functionality\nfocused on an application business domain, user workflow, facility (forms, http, routing),\nor collection of related utilities.</p>\n<p>While you can do everything within the root module,\nfeature modules help you partition the app into areas of specific interest and purpose.</p>\n<!-- CF: Is this paragraph just restating the previous paragraph?\nIf so, I recommend removing it or merging the two -->\n<p>A feature module collaborates with the root module and with other modules\nthrough the services it provides and\nthe components, directives, and pipes that it shares.</p>\n<p>In the next section, you'll carve the contact functionality out of the root module\nand into a dedicated feature module.</p>\n<a id=\"contact-module-v1\"></a>\n<h3 id=\"make-contact-a-feature-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#make-contact-a-feature-module\"><i class=\"material-icons\">link</i></a>Make <em>Contact</em> a feature module</h3>\n<!-- CF: Is \"Contact\" a proper noun in this context? -->\n<p>It's easy to refactor the contact material into a contact feature module.</p>\n<ol>\n<li>Create the <code>ContactModule</code> in the <code>src/app/contact</code> folder.</li>\n<li>Move the contact material from <code>AppModule</code> to <code>ContactModule</code>.</li>\n<li>Replace the imported  <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> with <code><a href=\"api/common/CommonModule\">CommonModule</a></code>.</li>\n<li>Import the <code>ContactModule</code> into the <code>AppModule</code>.</li>\n</ol>\n<p><code>AppModule</code> is the only existing class that changes. But you do add one new file.</p>\n<h3 id=\"add-the-contactmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#add-the-contactmodule\"><i class=\"material-icons\">link</i></a>Add the <em>ContactModule</em></h3>\n<p>Here's the new <code>ContactModule</code>:</p>\n<code-example path=\"ngmodule/src/app/contact/contact.module.2.ts\" title=\"src/app/contact/contact.module.ts\">\nimport { NgModule }           from '@angular/core';\nimport { CommonModule }       from '@angular/common';\nimport { FormsModule }        from '@angular/forms';\n\nimport { AwesomePipe }        from './awesome.pipe';\n\nimport\n       { ContactComponent }   from './contact.component';\nimport { ContactService }     from './contact.service';\nimport { HighlightDirective } from './highlight.directive';\n\n@NgModule({\n  imports:      [ CommonModule, FormsModule ],\n  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],\n  exports:      [ ContactComponent ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n</code-example>\n<p>You copy from <code>AppModule</code> the contact-related import statements and <code>@NgModule</code> properties\nthat concern the contact, and paste them into <code>ContactModule</code>.</p>\n<p>You <em>import</em> the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> because the contact component needs it.</p>\n<div class=\"alert is-important\">\n<p>Modules don't inherit access to the components, directives, or pipes that are declared in other modules.\nWhat <code>AppModule</code> imports is irrelevant to <code>ContactModule</code> and vice versa.\nBefore <code>ContactComponent</code> can bind with <code>[(ngModel)]</code>, its <code>ContactModule</code> must import <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.</p>\n</div>\n<p>You also replaced <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> by <code><a href=\"api/common/CommonModule\">CommonModule</a></code>, for reasons explained in the\n<a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">Should I import BrowserModule or CommonModule?</a>\nsection of the <a href=\"guide/ngmodule-faq\">NgModule FAQs</a> page.</p>\n<p>You <em>declare</em> the contact component, directive, and pipe in the module <code>declarations</code>.</p>\n<p>You <em>export</em> the <code>ContactComponent</code> so\nother modules that import the <code>ContactModule</code> can include it in their component templates.</p>\n<p>All other declared contact classes are private by default.\nThe <code>AwesomePipe</code> and <code>HighlightDirective</code> are hidden from the rest of the application.\nThe <code>HighlightDirective</code> can no longer color the <code>AppComponent</code> title text.</p>\n<h3 id=\"refactor-the-appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#refactor-the-appmodule\"><i class=\"material-icons\">link</i></a>Refactor the <em>AppModule</em></h3>\n<p>Return to the <code>AppModule</code> and remove everything specific to the contact feature set.</p>\n<ul>\n<li>Delete the contact import statements.</li>\n<li>Delete the contact declarations and contact providers.</li>\n<li>Delete the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> from the <code>imports</code> list (<code>AppComponent</code> doesn't need it).</li>\n</ul>\n<p>Leave only the classes required at the application root level.</p>\n<p>Then import the <code>ContactModule</code> so the app can continue to display the exported <code>ContactComponent</code>.</p>\n<p>Here's the refactored version of the <code>AppModule</code> along with the previous version.</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/app.module.ts (v2)\" path=\"ngmodule/src/app/app.module.2.ts\">\nimport { NgModule }           from '@angular/core';\nimport { BrowserModule }      from '@angular/platform-browser';\n\n/* App Root */\nimport\n       { AppComponent }       from './app.component';\nimport { HighlightDirective } from './highlight.directive';\nimport { TitleComponent }     from './title.component';\nimport { UserService }        from './user.service';\n\n/* Contact Imports */\nimport\n       { ContactModule }      from './contact/contact.module';\n\n@NgModule({\n  imports:      [ BrowserModule, ContactModule ],\n  declarations: [ AppComponent, HighlightDirective, TitleComponent ],\n  providers:    [ UserService ],\n  bootstrap:    [ AppComponent ],\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/app.module.ts (v1)\" path=\"ngmodule/src/app/app.module.1b.ts\">\nimport { NgModule }           from '@angular/core';\nimport { BrowserModule }      from '@angular/platform-browser';\n\n/* App Root */\nimport\n       { AppComponent }       from './app.component';\nimport { HighlightDirective } from './highlight.directive';\nimport { TitleComponent }     from './title.component';\nimport { UserService }        from './user.service';\n\n/* Contact Imports */\nimport\n       { ContactComponent }   from './contact/contact.component';\nimport { ContactService }     from './contact/contact.service';\nimport { AwesomePipe }        from './contact/awesome.pipe';\n\nimport {\n  HighlightDirective as ContactHighlightDirective\n} from './contact/highlight.directive';\n\nimport { FormsModule }        from '@angular/forms';\n\n@NgModule({\n  imports: [ BrowserModule,  FormsModule ],\n  declarations: [\n    AppComponent, HighlightDirective, TitleComponent,\n    AwesomePipe, ContactComponent, ContactHighlightDirective\n  ],\n  providers: [ ContactService, UserService ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n</code-tabs>\n<h3 id=\"improvements\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#improvements\"><i class=\"material-icons\">link</i></a>Improvements</h3>\n<p>There's a lot to like in the revised <code>AppModule</code>.</p>\n<ul>\n<li>\n<p>It does not change as the <em>Contact</em> domain grows.</p>\n</li>\n<li>\n<p>It only changes when you add new modules.</p>\n</li>\n<li>\n<p>It's simpler:</p>\n<ul>\n<li>Fewer import statements.</li>\n<li>No <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> import.</li>\n<li>No contact-specific declarations.</li>\n<li>No <code>ContactService</code> provider.</li>\n<li>No <code>HighlightDirective</code> conflict.</li>\n</ul>\n</li>\n</ul>\n<p>Try this <code>ContactModule</code> version of the sample.</p>\n<p><live-example embedded=\"\" plnkr=\"contact.2\" img=\"guide/ngmodule/contact-2-plunker.png\">Try the live example.</live-example></p>\n<a id=\"lazy-load\"></a>\n<h2 id=\"lazy-loading-modules-with-the-router\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#lazy-loading-modules-with-the-router\"><i class=\"material-icons\">link</i></a>Lazy-loading modules with the router</h2>\n<p>The Heroic Staffing Agency sample app has evolved.\nIt has two more modules, one for managing the heroes on staff and another for matching crises to the heroes.\nBoth modules are in the early stages of development.\nTheir specifics aren't important to the story and this page doesn't discuss every line of code.</p>\n<div class=\"l-sub-section\">\n<p>Examine and download the complete source for this version from\nthe <live-example plnkr=\"pre-shared.3\" img=\"guide/ngmodule/v3-plunker.png\">live example.</live-example></p>\n</div>\n<p>Some facets of the current application merit discussion are as follows:</p>\n<ul>\n<li>The app has three feature modules: Contact, Hero, and Crisis.</li>\n<li>The Angular router helps users navigate among these modules.</li>\n<li>The <code>ContactComponent</code> is the default destination when the app starts.</li>\n<li>The <code>ContactModule</code> continues to be \"eagerly\" loaded when the application starts.</li>\n<li><code>HeroModule</code> and the <code>CrisisModule</code> are lazy loaded.</li>\n</ul>\n<a id=\"app-component-template\"></a>\n<p>The new <code>AppComponent</code> template has\na title, three links, and a <code>&#x3C;router-outlet></code>.</p>\n<code-example path=\"ngmodule/src/app/app.component.3.ts\" region=\"template\" title=\"src/app/app.component.ts (v3 - Template)\" linenums=\"false\">\ntemplate: `\n  &#x3C;app-title [subtitle]=\"subtitle\">&#x3C;/app-title>\n  &#x3C;nav>\n    &#x3C;a routerLink=\"contact\" routerLinkActive=\"active\">Contact&#x3C;/a>\n    &#x3C;a routerLink=\"crisis\"  routerLinkActive=\"active\">Crisis Center&#x3C;/a>\n    &#x3C;a routerLink=\"heroes\"  routerLinkActive=\"active\">Heroes&#x3C;/a>\n  &#x3C;/nav>\n  &#x3C;router-outlet>&#x3C;/router-outlet>\n`\n\n</code-example>\n<p>The <code>&#x3C;app-contact></code> element is gone; you're routing to the <em>Contact</em> page now.</p>\n<p>The <code>AppModule</code> has changed modestly:</p>\n<code-example path=\"ngmodule/src/app/app.module.3.ts\" title=\"src/app/app.module.ts (v3)\">\nimport { NgModule }           from '@angular/core';\nimport { BrowserModule }      from '@angular/platform-browser';\n\n/* App Root */\nimport { AppComponent }       from './app.component.3';\nimport { HighlightDirective } from './highlight.directive';\nimport { TitleComponent }     from './title.component';\nimport { UserService }        from './user.service';\n\n/* Feature Modules */\nimport { ContactModule }      from './contact/contact.module.3';\n\n/* Routing Module */\nimport { AppRoutingModule }   from './app-routing.module.3';\n\n@NgModule({\n  imports:      [\n    BrowserModule,\n    ContactModule,\n    AppRoutingModule\n  ],\n  providers:    [ UserService ],\n  declarations: [ AppComponent, HighlightDirective, TitleComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>Some file names bear a <code>.3</code> extension that indicates\na difference with prior or future versions.\nThe significant differences will be explained in due course.</p>\n<!-- CF: Can you be more specific here? Are the differences explained later in this page or in another page? -->\n</div>\n<p>The module still imports <code>ContactModule</code> so that its routes and components are mounted when the app starts.</p>\n<p>The module does <em>not</em> import <code>HeroModule</code> or <code>CrisisModule</code>.\nThey'll be fetched and mounted asynchronously when the user navigates to one of their routes.</p>\n<p>The significant change from version 2 is the addition of the <em>AppRoutingModule</em> to the module <code>imports</code>.\nThe <code>AppRoutingModule</code> is a <a href=\"guide/router#routing-module\">routing module</a>\nthat handles the app's routing concerns.</p>\n<h3 id=\"app-routing\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#app-routing\"><i class=\"material-icons\">link</i></a>App routing</h3>\n<code-example path=\"ngmodule/src/app/app-routing.module.ts\" title=\"src/app/app-routing.module.ts\" linenums=\"false\">\nimport { NgModule }             from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\n\nexport const routes: Routes = [\n  { path: '', redirectTo: 'contact', pathMatch: 'full'},\n  { path: 'crisis', loadChildren: 'app/crisis/crisis.module#CrisisModule' },\n  { path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<p>The router is the subject of the <a href=\"guide/router\">Routing &#x26; Navigation</a> page, so this section skips many of the details and\nconcentrates on the intersection of NgModules and routing.</p>\n<p>The <code>app-routing.module.ts</code> file defines three routes.</p>\n<p>The first route redirects the empty URL (such as <code>http://host.com/</code>)\nto another route whose path is <code>contact</code> (such as <code>http://host.com/contact</code>).</p>\n<p>The <code>contact</code> route isn't defined here.\nIt's defined in the <em>Contact</em> feature's <em>own</em> routing module, <code>contact-routing.module.ts</code>.\nIt's standard practice for feature modules with routing components to define their own routes.\nYou'll get to that file in a moment.</p>\n<p>The remaining two routes use lazy loading syntax to tell the router where to find the modules:</p>\n<code-example path=\"ngmodule/src/app/app-routing.module.ts\" region=\"lazy-routes\" title=\"src/app/app-routing.module.ts\" linenums=\"false\">\n{ path: 'crisis', loadChildren: 'app/crisis/crisis.module#CrisisModule' },\n{ path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' }\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>A lazy-loaded module location is a <em>string</em>, not a <em>type</em>.\nIn this app, the string identifies both the module <em>file</em> and the module <em>class</em>,\nthe latter separated from the former by a <code>#</code>.</p>\n</div>\n<h3 id=\"routermoduleforroot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#routermoduleforroot\"><i class=\"material-icons\">link</i></a>RouterModule.forRoot</h3>\n<p>The <code>forRoot</code> static class method of the <code><a href=\"api/router/RouterModule\">RouterModule</a></code> with the provided configuration and\nadded to the <code>imports</code> array provides the routing concerns for the module.</p>\n<code-example path=\"ngmodule/src/app/app-routing.module.ts\" region=\"forRoot\" title=\"src/app/app-routing.module.ts\" linenums=\"false\">\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule {}\n\n</code-example>\n<p>The returned <code>AppRoutingModule</code> class is a <code>Routing Module</code> containing both the <code><a href=\"api/router/RouterModule\">RouterModule</a></code> directives\nand the dependency-injection providers that produce a configured <code><a href=\"api/router/Router\">Router</a></code>.</p>\n<p>This <code>AppRoutingModule</code> is intended for the app <em>root</em> module only.</p>\n<div class=\"alert is-critical\">\n<p>Never call <code>RouterModule.forRoot</code> in a feature-routing module.</p>\n</div>\n<p>Back in the root <code>AppModule</code>, add the <code>AppRoutingModule</code> to its <code>imports</code> list,\nand the app is ready to navigate.</p>\n<code-example path=\"ngmodule/src/app/app.module.3.ts\" region=\"imports\" title=\"src/app/app.module.ts (imports)\" linenums=\"false\">\nimports:      [\n  BrowserModule,\n  ContactModule,\n  AppRoutingModule\n],\n\n</code-example>\n<h3 id=\"routing-to-a-feature-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#routing-to-a-feature-module\"><i class=\"material-icons\">link</i></a>Routing to a feature module</h3>\n<p>The <code>src/app/contact</code> folder holds a new file, <code>contact-routing.module.ts</code>.\nIt defines the <code>contact</code> route mentioned earlier and provides a <code>ContactRoutingModule</code> as follows:</p>\n<code-example path=\"ngmodule/src/app/contact/contact-routing.module.ts\" region=\"routing\" title=\"src/app/contact/contact-routing.module.ts (routing)\" linenums=\"false\">\n@NgModule({\n  imports: [RouterModule.forChild([\n    { path: 'contact', component: ContactComponent }\n  ])],\n  exports: [RouterModule]\n})\nexport class ContactRoutingModule {}\n\n</code-example>\n<p>This time you pass the route list to the <code>forChild</code> method of the <code><a href=\"api/router/RouterModule\">RouterModule</a></code>.\nThe route list is only responsible for providing additional routes and is intended for feature modules.</p>\n<div class=\"alert is-important\">\n<p>Always call <code>RouterModule.forChild</code> in a feature-routing module.</p>\n</div>\n<div class=\"alert is-helpful\">\n<p><em>forRoot</em> and <em>forChild</em> are conventional names for methods that\ndeliver different <code>import</code> values to root and feature modules.\nAngular doesn't recognize them but Angular developers do.</p>\n<p><a href=\"guide/ngmodule-faq#q-for-root\">Follow this convention</a> if you write a similar module\nthat has both shared <a href=\"guide/ngmodule-faq#q-declarable\">declarables</a> and services.</p>\n</div>\n<p><code>ContactModule</code> has changed in two small but important ways.</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/contact/contact.module.3.ts\" path=\"ngmodule/src/app/contact/contact.module.3.ts\" region=\"class\">\n@NgModule({\n  imports:      [ CommonModule, FormsModule, ContactRoutingModule ],\n  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/contact.module.2.ts\" path=\"ngmodule/src/app/contact/contact.module.2.ts\" region=\"class\">\n@NgModule({\n  imports:      [ CommonModule, FormsModule ],\n  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],\n  exports:      [ ContactComponent ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n</code-pane>\n\n</code-tabs>\n<ul>\n<li>It imports the <code>ContactRoutingModule</code> object from <code>contact-routing.module.ts</code>.</li>\n<li>It no longer exports <code>ContactComponent</code>.</li>\n</ul>\n<p>Now that you navigate to <code>ContactComponent</code> with the router, there's no reason to make it public.\nAlso, <code>ContactComponent</code> doesn't need a selector.\nNo template will ever again reference this <code>ContactComponent</code>.\nIt's gone from the <a href=\"guide/ngmodule#app-component-template\">AppComponent template</a>.</p>\n<a id=\"hero-module\"></a>\n<h3 id=\"lazy-loaded-routing-to-a-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#lazy-loaded-routing-to-a-module\"><i class=\"material-icons\">link</i></a>Lazy-loaded routing to a module</h3>\n<p>The lazy-loaded <code>HeroModule</code> and <code>CrisisModule</code> follow the same principles as any feature module.\nThey don't look different from the eagerly loaded <code>ContactModule</code>.</p>\n<p>The <code>HeroModule</code> is a bit more complex than the <code>CrisisModule</code>, which makes it\na more interesting and useful example. Its file structure is as follows:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    hero\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      hero-detail.component.ts\n    </div>\n    <div class=\"file\">\n      hero-list.component.ts\n    </div>\n    <div class=\"file\">\n      hero.component.ts\n    </div>\n    <div class=\"file\">\n      hero.module.ts\n    </div>\n    <div class=\"file\">\n      hero-routing.module.ts\n    </div>\n    <div class=\"file\">\n      hero.service.ts\n    </div>\n    <div class=\"file\">\n      highlight.directive.ts\n    </div>\n  </div>\n</div>\n<p>This is the child routing scenario familiar to readers of the\n<a href=\"guide/router#child-routing-component\">Child routing component</a> section of the\n<a href=\"guide/router#child-routing-component\">Routing &#x26; Navigation</a> page.\nThe <code>HeroComponent</code> is the feature's top component and routing host.\nIts template has a <code>&#x3C;router-outlet></code> that displays either a list of heroes (<code>HeroList</code>)\nor an editor of a selected hero (<code>HeroDetail</code>).\nBoth components delegate to the <code>HeroService</code> to fetch and save data.</p>\n<p>Yet another <code>HighlightDirective</code> colors elements in yet a different shade.\nIn the next section, <a href=\"guide/ngmodule#shared-module\" title=\"Shared modules\">Shared modules</a>, you'll resolve the repetition and inconsistencies.</p>\n<p>The <code>HeroModule</code> is a feature module like any other.</p>\n<code-example path=\"ngmodule/src/app/hero/hero.module.3.ts\" region=\"class\" title=\"src/app/hero/hero.module.ts (class)\" linenums=\"false\">\n@NgModule({\n  imports: [ CommonModule, FormsModule, HeroRoutingModule ],\n  declarations: [\n    HeroComponent, HeroDetailComponent, HeroListComponent,\n    HighlightDirective\n  ]\n})\nexport class HeroModule { }\n\n</code-example>\n<p>It imports the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> because the <code>HeroDetailComponent</code> template binds with <code>[(ngModel)]</code>.\nIt imports the <code>HeroRoutingModule</code> from <code>hero-routing.module.ts</code> just as <code>ContactModule</code> and <code>CrisisModule</code> do.</p>\n<p>The <code>CrisisModule</code> is much the same.</p>\n<p><live-example embedded=\"\" plnkr=\"pre-shared.3\" img=\"guide/ngmodule/v3-plunker.png\">Try the live example.</live-example></p>\n<a id=\"shared-module\"></a>\n<h2 id=\"shared-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#shared-modules\"><i class=\"material-icons\">link</i></a>Shared modules</h2>\n<p>The app is shaping up.\nBut it carries three different versions of the <code>HighlightDirective</code>.\nAnd the many files cluttering the app folder level could be better organized.</p>\n<p>Add a <code>SharedModule</code> to hold the common components, directives, and pipes\nand share them with the modules that need them.</p>\n<ol>\n<li>Create an <code>src/app/shared</code> folder.</li>\n<li>Move the <code>AwesomePipe</code> and <code>HighlightDirective</code> from <code>src/app/contact</code> to <code>src/app/shared</code>.</li>\n<li>Delete the <code>HighlightDirective</code> classes from <code>src/app/</code> and <code>src/app/hero</code>.</li>\n<li>Create a <code>SharedModule</code> class to own the shared material.</li>\n<li>Update other feature modules to import <code>SharedModule</code>.</li>\n</ol>\n<p>Here is the <code>SharedModule</code>:</p>\n<code-example path=\"ngmodule/src/app/shared/shared.module.ts\" title=\"src/app/src/app/shared/shared.module.ts\">\nimport { NgModule }            from '@angular/core';\nimport { CommonModule }        from '@angular/common';\nimport { FormsModule }         from '@angular/forms';\n\nimport { AwesomePipe }         from './awesome.pipe';\nimport { HighlightDirective }  from './highlight.directive';\n\n@NgModule({\n  imports:      [ CommonModule ],\n  declarations: [ AwesomePipe, HighlightDirective ],\n  exports:      [ AwesomePipe, HighlightDirective,\n                  CommonModule, FormsModule ]\n})\nexport class SharedModule { }\n\n</code-example>\n<p>Note the following:</p>\n<ul>\n<li>It imports the <code><a href=\"api/common/CommonModule\">CommonModule</a></code> because its component needs common directives.</li>\n<li>It declares and exports the utility pipe, directive, and component classes as expected.</li>\n<li>It re-exports the <code><a href=\"api/common/CommonModule\">CommonModule</a></code> and <code><a href=\"api/forms/FormsModule\">FormsModule</a></code></li>\n</ul>\n<h3 id=\"re-exporting-other-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#re-exporting-other-modules\"><i class=\"material-icons\">link</i></a>Re-exporting other modules</h3>\n<p>If you review the application, you may notice that many components requiring <code>SharedModule</code> directives\nalso use <code><a href=\"api/common/NgIf\">NgIf</a></code> and <code><a href=\"api/common/NgFor\">NgFor</a></code> from <code><a href=\"api/common/CommonModule\">CommonModule</a></code>\nand bind to component properties with <code>[(ngModel)]</code>, a directive in the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.\nModules that declare these components would have to import <code><a href=\"api/common/CommonModule\">CommonModule</a></code>, <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>, and <code>SharedModule</code>.</p>\n<p>You can reduce the repetition by having <code>SharedModule</code> re-export <code><a href=\"api/common/CommonModule\">CommonModule</a></code> and <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>\nso that importers of <code>SharedModule</code> get <code><a href=\"api/common/CommonModule\">CommonModule</a></code> and <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> for free.</p>\n<p>As it happens, the components declared by <code>SharedModule</code> itself don't bind with <code>[(ngModel)]</code>.\nTechnically,  there is no need for <code>SharedModule</code> to import <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.</p>\n<p><code>SharedModule</code> can still export <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> without listing it among its <code>imports</code>.</p>\n<h3 id=\"why-titlecomponent-isnt-shared\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#why-titlecomponent-isnt-shared\"><i class=\"material-icons\">link</i></a>Why <em>TitleComponent</em> isn't shared</h3>\n<p><code>SharedModule</code> exists to make commonly used components, directives, and pipes available\nfor use in the templates of components in many other modules.</p>\n<p>The <code>TitleComponent</code> is used only once by the <code>AppComponent</code>.\nThere's no point in sharing it.</p>\n<a id=\"no-shared-module-providers\"></a>\n<h3 id=\"why-userservice-isnt-shared\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#why-userservice-isnt-shared\"><i class=\"material-icons\">link</i></a>Why <em>UserService</em> isn't shared</h3>\n<p>While many components share the same service instances,\nthey rely on Angular dependency injection to do this kind of sharing, not the module system.</p>\n<p>Several components of the sample inject the <code>UserService</code>.\nThere should be only one instance of the <code>UserService</code> in the entire application\nand only one provider of it.</p>\n<p><code>UserService</code> is an application-wide singleton.\nYou don't want each module to have its own separate instance.\nYet there is <a href=\"guide/ngmodule-faq#q-why-bad\">a real danger</a> of that happening</p>\n<!-- CF: This link goes to the top of the NgModule FAQs page.\nIt looks like it is supposed to go to a specific question/section within the page. -->\n<p>if the <code>SharedModule</code> provides the <code>UserService</code>.</p>\n<div class=\"alert is-critical\">\n<p>Do <em>not</em> specify app-wide singleton <code>providers</code> in a shared module.\nA lazy-loaded module that imports that shared module makes its own copy of the service.</p>\n</div>\n<a id=\"core-module\"></a>\n<h2 id=\"the-core-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#the-core-module\"><i class=\"material-icons\">link</i></a>The Core module</h2>\n<p>At the moment, the root folder is cluttered with the <code>UserService</code>\nand <code>TitleComponent</code> that only appear in the root <code>AppComponent</code>.\nYou didn't include them in the <code>SharedModule</code> for reasons just explained.</p>\n<p>Instead, gather them in a single <code>CoreModule</code> that you import once when the app starts\nand never import anywhere else.</p>\n<p>Perform the following steps:</p>\n<ol>\n<li>Create an <code>src/app/core</code> folder.</li>\n</ol>\n<ul>\n<li>Move the <code>UserService</code> and <code>TitleComponent</code> from <code>src/app/</code> to <code>src/app/core</code>.</li>\n<li>Create a <code>CoreModule</code> class to own the core material.</li>\n<li>Update the <code>AppRoot</code> module to  import <code>CoreModule</code>.</li>\n</ul>\n<p>Most of this work is familiar. The interesting part is the <code>CoreModule</code>.</p>\n<code-example path=\"ngmodule/src/app/core/core.module.ts\" region=\"v4\" title=\"src/app/src/app/core/core.module.ts\">\nimport {\n  ModuleWithProviders, NgModule,\n  Optional, SkipSelf }       from '@angular/core';\n\nimport { CommonModule }      from '@angular/common';\n\nimport { TitleComponent }    from './title.component';\nimport { UserService }       from './user.service';\n@NgModule({\n  imports:      [ CommonModule ],\n  declarations: [ TitleComponent ],\n  exports:      [ TitleComponent ],\n  providers:    [ UserService ]\n})\nexport class CoreModule {\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>You're importing some extra symbols from the Angular core library that you're not using yet.\nThey'll become relevant later in this page.</p>\n</div>\n<p>The <code>@NgModule</code> metadata should be familiar.\nYou declare the <code>TitleComponent</code>  because this module owns it and you export it\nbecause <code>AppComponent</code> (which is in <code>AppModule</code>) displays the title in its template.\n<code>TitleComponent</code> needs the Angular <code><a href=\"api/common/NgIf\">NgIf</a></code> directive that you import from <code><a href=\"api/common/CommonModule\">CommonModule</a></code>.</p>\n<p><code>CoreModule</code> provides the <code>UserService</code>. Angular registers that provider with the app root injector,\nmaking a singleton instance of the <code>UserService</code> available to any component that needs it,\nwhether that component is eagerly or lazily loaded.</p>\n<div class=\"l-sub-section\">\n<h3 class=\"no-toc\" id=\"why-bother\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#why-bother\"><i class=\"material-icons\">link</i></a>Why bother?</h3>\nThis scenario is clearly contrived.\nThe app is too small to worry about a single service file and a tiny, one-time component.\n<p>A <code>TitleComponent</code> sitting in the root folder isn't bothering anyone.\nThe root <code>AppModule</code> can register the <code>UserService</code> itself,\nas it does currently, even if you decide to relocate the <code>UserService</code> file to the <code>src/app/core</code> folder.</p>\n<p>Real-world apps have more to worry about.\nThey can have several single-use components (such as spinners, message toasts, and modal dialogs)\nthat appear only in the <code>AppComponent</code> template.\nYou don't import them elsewhere so they're not shared in that sense.\nYet they're too big and messy to leave loose in the root folder.</p>\n<p>Apps often have many singleton services like this sample's <code>UserService</code>.\nEach must be registered exactly once, in the app root injector, when the application starts.</p>\n<p>While many components inject such services in their constructors—and\ntherefore require JavaScript <code>import</code> statements to import their symbols—no\nother component or module should define or re-create the services themselves.\nTheir <em>providers</em> aren't shared.</p>\n<p>We recommend collecting such single-use classes and hiding their details inside a <code>CoreModule</code>.\nA simplified root <code>AppModule</code> imports <code>CoreModule</code> in its capacity as orchestrator of the application as a whole.</p>\n</div>\n<h2 id=\"cleanup\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#cleanup\"><i class=\"material-icons\">link</i></a>Cleanup</h2>\n<p>Having refactored to a <code>CoreModule</code> and a <code>SharedModule</code>, it's time to clean up the other modules.</p>\n<h3 id=\"a-trimmer-appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#a-trimmer-appmodule\"><i class=\"material-icons\">link</i></a>A trimmer <em>AppModule</em></h3>\n<p>Here is the updated <code>AppModule</code> paired with version 3 for comparison:</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/app.module.ts (v4)\" path=\"ngmodule/src/app/app.module.ts\" region=\"v4\">\nimport { NgModule }       from '@angular/core';\nimport { BrowserModule }  from '@angular/platform-browser';\n\n/* App Root */\nimport { AppComponent }   from './app.component';\n\n/* Feature Modules */\nimport { ContactModule }    from './contact/contact.module';\nimport { CoreModule }       from './core/core.module';\n\n/* Routing Module */\nimport { AppRoutingModule } from './app-routing.module';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    ContactModule,\n    CoreModule,\n    AppRoutingModule\n  ],\n  declarations: [ AppComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n\n  <code-pane title=\"src/app/app.module.ts (v3)\" path=\"ngmodule/src/app/app.module.3.ts\">\nimport { NgModule }           from '@angular/core';\nimport { BrowserModule }      from '@angular/platform-browser';\n\n/* App Root */\nimport { AppComponent }       from './app.component.3';\nimport { HighlightDirective } from './highlight.directive';\nimport { TitleComponent }     from './title.component';\nimport { UserService }        from './user.service';\n\n/* Feature Modules */\nimport { ContactModule }      from './contact/contact.module.3';\n\n/* Routing Module */\nimport { AppRoutingModule }   from './app-routing.module.3';\n\n@NgModule({\n  imports:      [\n    BrowserModule,\n    ContactModule,\n    AppRoutingModule\n  ],\n  providers:    [ UserService ],\n  declarations: [ AppComponent, HighlightDirective, TitleComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n</code-tabs>\n<p><code>AppModule</code> now has the following qualities:</p>\n<ul>\n<li>A little smaller because many <code>src/app/root</code> classes have moved to other modules.</li>\n<li>Stable because you'll add future components and providers to other modules, not this one.</li>\n<li>Delegated to imported modules rather than doing work.</li>\n<li>Focused on its main task, orchestrating the app as a whole.</li>\n</ul>\n<h3 id=\"a-trimmer-contactmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#a-trimmer-contactmodule\"><i class=\"material-icons\">link</i></a>A trimmer <em>ContactModule</em></h3>\n<p>Here is the new <code>ContactModule</code> paired with the prior version:</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/contact/contact.module.ts (v4)\" path=\"ngmodule/src/app/contact/contact.module.ts\">\nimport { NgModule }           from '@angular/core';\nimport { SharedModule }       from '../shared/shared.module';\n\nimport { ContactComponent }     from './contact.component';\nimport { ContactService }       from './contact.service';\nimport { ContactRoutingModule } from './contact-routing.module';\n\n@NgModule({\n  imports:      [ SharedModule, ContactRoutingModule ],\n  declarations: [ ContactComponent ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/contact.module.ts (v3)\" path=\"ngmodule/src/app/contact/contact.module.3.ts\">\nimport { NgModule }           from '@angular/core';\nimport { CommonModule }       from '@angular/common';\nimport { FormsModule }        from '@angular/forms';\n\nimport { AwesomePipe }        from './awesome.pipe';\n\nimport { ContactComponent }   from './contact.component.3';\nimport { ContactService }     from './contact.service';\nimport { HighlightDirective } from './highlight.directive';\n\nimport { ContactRoutingModule }   from './contact-routing.module.3';\n\n@NgModule({\n  imports:      [ CommonModule, FormsModule, ContactRoutingModule ],\n  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n</code-pane>\n\n</code-tabs>\n<p>Notice the following:</p>\n<ul>\n<li>The <code>AwesomePipe</code> and <code>HighlightDirective</code> are gone.</li>\n<li>The imports include <code>SharedModule</code> instead of <code><a href=\"api/common/CommonModule\">CommonModule</a></code> and <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.</li>\n<li>The new version is leaner and cleaner.</li>\n</ul>\n<hr>\n<a id=\"core-for-root\"></a>\n<h2 id=\"configure-core-services-with-coremoduleforroot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#configure-core-services-with-coremoduleforroot\"><i class=\"material-icons\">link</i></a>Configure core services with <em>CoreModule.forRoot</em></h2>\n<p>A module that adds providers to the application can offer a facility for configuring those providers as well.</p>\n<p>By convention, the <code>forRoot</code> static method both provides and configures services at the same time.\nIt takes a service configuration object and returns a\n<a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>, which is\na simple object with the following properties:</p>\n<ul>\n<li><code>ngModule</code>: the <code>CoreModule</code> class</li>\n<li><code>providers</code>: the configured providers</li>\n</ul>\n<p>The root <code>AppModule</code> imports the <code>CoreModule</code> and adds the <code>providers</code> to the <code>AppModule</code> providers.</p>\n<div class=\"l-sub-section\">\n<p>More precisely, Angular accumulates all imported providers before appending the items listed in <code>@NgModule.providers</code>.\nThis sequence ensures that whatever you add explicitly to the <code>AppModule</code> providers takes precedence\nover the providers of imported modules.</p>\n</div>\n<p>Add a <code>CoreModule.forRoot</code> method that configures the core <code>UserService</code>.</p>\n<p>You've extended the core <code>UserService</code> with an optional, injected <code>UserServiceConfig</code>.\nIf a <code>UserServiceConfig</code> exists, the <code>UserService</code> sets the user name from that config.</p>\n<code-example path=\"ngmodule/src/app/core/user.service.ts\" region=\"ctor\" title=\"src/app/core/user.service.ts (constructor)\" linenums=\"false\">\nconstructor(@Optional() config: UserServiceConfig) {\n  if (config) { this._userName = config.userName; }\n}\n\n</code-example>\n<p>Here's <code>CoreModule.forRoot</code> that takes a <code>UserServiceConfig</code> object:</p>\n<code-example path=\"ngmodule/src/app/core/core.module.ts\" region=\"for-root\" title=\"src/app/core/core.module.ts (forRoot)\" linenums=\"false\">\nstatic forRoot(config: UserServiceConfig): ModuleWithProviders {\n  return {\n    ngModule: CoreModule,\n    providers: [\n      {provide: UserServiceConfig, useValue: config }\n    ]\n  };\n}\n\n</code-example>\n<p>Lastly, call it within the <code>imports</code> list of the <code>AppModule</code>.</p>\n<code-example path=\"ngmodule/src/app/app.module.ts\" region=\"import-for-root\" title=\"src/app//app.module.ts (imports)\" linenums=\"false\">\nimports: [\n  BrowserModule,\n  ContactModule,\n  CoreModule.forRoot({userName: 'Miss Marple'}),\n  AppRoutingModule\n],\n\n</code-example>\n<p>The app displays \"Miss Marple\" as the user instead of the default \"Sherlock Holmes\".</p>\n<div class=\"alert is-important\">\n<p>Call <code>forRoot</code> only in the root application module, <code>AppModule</code>.\nCalling it in any other module, particularly in a lazy-loaded module,\nis contrary to the intent and can produce a runtime error.</p>\n<p>Remember to <em>import</em> the result; don't add it to any other <code>@NgModule</code> list.</p>\n</div>\n<hr>\n<a id=\"prevent-reimport\"></a>\n<h2 id=\"prevent-reimport-of-the-coremodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#prevent-reimport-of-the-coremodule\"><i class=\"material-icons\">link</i></a>Prevent reimport of the <em>CoreModule</em></h2>\n<p>Only the root <code>AppModule</code> should import the <code>CoreModule</code>.\n<a href=\"guide/ngmodule-faq#q-why-bad\">Bad things happen</a> if a lazy-loaded module imports it.</p>\n<!-- CF: Again, this link goes to the top of the NgModule FAQs page.\nIt looks like it is supposed to go to a specific question/section within the page. -->\n<p>You could hope that no developer makes that mistake.\nOr you can guard against it and fail fast by adding the following <code>CoreModule</code> constructor.</p>\n<code-example path=\"ngmodule/src/app/core/core.module.ts\" region=\"ctor\" title=\"src/app/core/core.module.ts\" linenums=\"false\">\nconstructor (@Optional() @SkipSelf() parentModule: CoreModule) {\n  if (parentModule) {\n    throw new Error(\n      'CoreModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<p>The constructor tells Angular to inject the <code>CoreModule</code> into itself.\nThat seems dangerously circular.</p>\n<p>The injection would be circular if Angular looked for <code>CoreModule</code> in the <em>current</em> injector.\nThe <code>@SkipSelf</code> decorator means \"look for <code>CoreModule</code> in an ancestor injector, above me in the injector hierarchy.\"</p>\n<p>If the constructor executes as intended in the <code>AppModule</code>,\nthere is no ancestor injector that could provide an instance of <code>CoreModule</code>.\nThe injector should give up.</p>\n<p>By default, the injector throws an error when it can't find a requested provider.\nThe <code>@Optional</code> decorator means not finding the service is OK.\nThe injector returns <code>null</code>, the <code>parentModule</code> parameter is null,\nand the constructor concludes uneventfully.</p>\n<p>It's a different story if you improperly import <code>CoreModule</code> into a lazy-loaded module such as <code>HeroModule</code> (try it).</p>\n<p>Angular creates a lazy-loaded module with its own injector, a <em>child</em> of the root injector.\n<code>@SkipSelf</code> causes Angular to look for a <code>CoreModule</code> in the parent injector, which this time is the root injector.\nOf course it finds the instance imported by the root <code>AppModule</code>.\nNow <code>parentModule</code> exists and the constructor throws the error.</p>\n<h2 id=\"conclusion\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#conclusion\"><i class=\"material-icons\">link</i></a>Conclusion</h2>\n<p>You made it! You can examine and download the complete source for this final version from the live example.\n<live-example embedded=\"\" img=\"guide/ngmodule/final-plunker.png\"></live-example></p>\n<h2 id=\"frequently-asked-questions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#frequently-asked-questions\"><i class=\"material-icons\">link</i></a>Frequently asked questions</h2>\n<p>Now that you understand NgModules, you may be interested\nin the companion <a href=\"guide/ngmodule-faq\" title=\"NgModule FAQs\">NgModule FAQs</a> page\nwith its ready answers to specific design and implementation questions.</p>\n\n</div>"
}