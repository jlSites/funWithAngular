{
  "id": "guide/lifecycle-hooks",
  "title": "Lifecycle Hooks",
  "contents": "\n<div class=\"content\">\n<h1 id=\"lifecycle-hooks\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-hooks\"><i class=\"material-icons\">link</i></a>Lifecycle Hooks</h1>\n<img src=\"generated/images/guide/lifecycle-hooks/hooks-in-sequence.png\" alt=\"Us\" class=\"left\" width=\"200\" height=\"283\">\n<p>A component has a lifecycle managed by Angular.</p>\n<p>Angular creates it, renders it, creates and renders its children,\nchecks it when its data-bound properties change, and destroys it before removing it from the DOM.</p>\n<p>Angular offers <strong>lifecycle hooks</strong>\nthat provide visibility into these key life moments and the ability to act when they occur.</p>\n<p>A directive has the same set of lifecycle hooks, minus the hooks that are specific to component content and views.</p>\n<a id=\"hooks-overview\"></a>\n<h2 id=\"component-lifecycle-hooks-overview\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#component-lifecycle-hooks-overview\"><i class=\"material-icons\">link</i></a>Component lifecycle hooks overview</h2>\n<p>Directive and component instances have a lifecycle\nas Angular creates, updates, and destroys them.\nDevelopers can tap into key moments in that lifecycle by implementing\none or more of the <em>lifecycle hook</em> interfaces in the Angular <code>core</code> library.</p>\n<p>Each interface has a single hook method whose name is the interface name prefixed with <code>ng</code>.\nFor example, the <code><a href=\"api/core/OnInit\">OnInit</a></code> interface has a hook method named <code>ngOnInit()</code>\nthat Angular calls shortly after creating the component:</p>\n<code-example path=\"lifecycle-hooks/src/app/peek-a-boo.component.ts\" region=\"ngOnInit\" title=\"peek-a-boo.component.ts (excerpt)\" linenums=\"false\">\nexport class PeekABoo implements OnInit {\n  constructor(private logger: LoggerService) { }\n\n  // implement OnInit's `ngOnInit` method\n  ngOnInit() { this.logIt(`OnInit`); }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p>No directive or component will implement all of the lifecycle hooks and some of the hooks only make sense for components.\nAngular only calls a directive/component hook method <em>if it is defined</em>.</p>\n<a id=\"hooks-purpose-timing\"></a>\n<h2 id=\"lifecycle-sequence\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-sequence\"><i class=\"material-icons\">link</i></a>Lifecycle sequence</h2>\n<p><em>After</em> creating a component/directive by calling its constructor, Angular\ncalls the lifecycle hook methods in the following sequence at specific moments:</p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  <col width=\"80%\">\n  </colgroup><tbody><tr>\n    <th>Hook</th>\n    <th>Purpose and Timing</th>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnChanges()</code>\n    </td>\n    <td>\n<p>      Respond when Angular (re)sets data-bound input properties.\nThe method receives a <code><a href=\"api/core/SimpleChanges\">SimpleChanges</a></code> object of current and previous property values.</p>\n<p>      Called before <code>ngOnInit()</code> and whenever one or more data-bound input properties change.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnInit()</code>\n    </td>\n    <td>\n<p>      Initialize the directive/component after Angular first displays the data-bound properties\nand sets the directive/component's input properties.</p>\n<p>      Called <em>once</em>, after the <em>first</em> <code>ngOnChanges()</code>.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngDoCheck()</code>\n    </td>\n    <td>\n<p>      Detect and act upon changes that Angular can't or won't detect on its own.</p>\n<p>      Called during every change detection run, immediately after <code>ngOnChanges()</code> and <code>ngOnInit()</code>.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterContentInit()</code>\n    </td>\n    <td>\n<p>      Respond after Angular projects external content into the component's view.</p>\n<p>      Called <em>once</em> after the first <code>ngDoCheck()</code>.</p>\n<p>      <em>A component-only hook</em>.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterContentChecked()</code>\n    </td>\n    <td>\n<p>      Respond after Angular checks the content projected into the component.</p>\n<p>      Called after the <code>ngAfterContentInit()</code> and every subsequent <code>ngDoCheck()</code>.</p>\n<p>      <em>A component-only hook</em>.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterViewInit()</code>\n    </td>\n    <td>\n<p>      Respond after Angular initializes the component's views and child views.</p>\n<p>      Called <em>once</em> after the first <code>ngAfterContentChecked()</code>.</p>\n<p>      <em>A component-only hook</em>.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterViewChecked()</code>\n    </td>\n    <td>\n<p>      Respond after Angular checks the component's views and child views.</p>\n<p>      Called after the <code>ngAfterViewInit</code> and every subsequent <code>ngAfterContentChecked()</code>.</p>\n<p>      <em>A component-only hook</em>.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnDestroy</code>\n    </td>\n    <td>\n<p>      Cleanup just before Angular destroys the directive/component.\nUnsubscribe Observables and detach event handlers to avoid memory leaks.</p>\n<p>      Called <em>just before</em> Angular destroys the directive/component.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"interface-optional\"></a>\n<h2 id=\"interfaces-are-optional-technically\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#interfaces-are-optional-technically\"><i class=\"material-icons\">link</i></a>Interfaces are optional (technically)</h2>\n<p>The interfaces are optional for JavaScript and Typescript developers from a purely technical perspective.\nThe JavaScript language doesn't have interfaces.\nAngular can't see TypeScript interfaces at runtime because they disappear from the transpiled JavaScript.</p>\n<p>Fortunately, they aren't necessary.\nYou don't have to add the lifecycle hook interfaces to directives and components to benefit from the hooks themselves.</p>\n<p>Angular instead inspects directive and component classes and calls the hook methods <em>if they are defined</em>.\nAngular finds and calls methods like <code>ngOnInit()</code>, with or without the interfaces.</p>\n<p>Nonetheless, it's good practice to add interfaces to TypeScript directive classes\nin order to benefit from strong typing and editor tooling.</p>\n<a id=\"other-lifecycle-hooks\"></a>\n<h2 id=\"other-angular-lifecycle-hooks\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#other-angular-lifecycle-hooks\"><i class=\"material-icons\">link</i></a>Other Angular lifecycle hooks</h2>\n<p>Other Angular sub-systems may have their own lifecycle hooks apart from these component hooks.</p>\n<p>3rd party libraries might implement their hooks as well in order to give developers more\ncontrol over how these libraries are used.</p>\n<a id=\"the-sample\"></a>\n<h2 id=\"lifecycle-examples\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#lifecycle-examples\"><i class=\"material-icons\">link</i></a>Lifecycle examples</h2>\n<p>The <live-example></live-example>\ndemonstrates the lifecycle hooks in action through a series of exercises\npresented as components under the control of the root <code>AppComponent</code>.</p>\n<p>They follow a common pattern: a <em>parent</em> component serves as a test rig for\na <em>child</em> component that illustrates one or more of the lifecycle hook methods.</p>\n<p>Here's a brief description of each exercise:</p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  <col width=\"80%\">\n  </colgroup><tbody><tr>\n    <th>Component</th>\n    <th>Description</th>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#peek-a-boo\">Peek-a-boo</a>\n    </td>\n    <td>\n<p>      Demonstrates every lifecycle hook.\nEach hook method writes to the on-screen log.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#spy\">Spy</a>\n    </td>\n    <td>\n<p>      Directives have lifecycle hooks too.\nA <code>SpyDirective</code> can log when the element it spies upon is\ncreated or destroyed using the <code>ngOnInit</code> and <code>ngOnDestroy</code> hooks.</p>\n<p>      This example applies the <code>SpyDirective</code> to a <code>&#x3C;div></code> in an <code>ngFor</code> <em>hero</em> repeater\nmanaged by the parent <code>SpyComponent</code>.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#onchanges\">OnChanges</a>\n    </td>\n    <td>\n<p>      See how Angular calls the <code>ngOnChanges()</code> hook with a <code>changes</code> object\nevery time one of the component input properties changes.\nShows how to interpret the <code>changes</code> object.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#docheck\">DoCheck</a>\n    </td>\n    <td>\n<p>      Implements an <code>ngDoCheck()</code> method with custom change detection.\nSee how often Angular calls this hook and watch it post changes to a log.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#afterview\">AfterView</a>\n    </td>\n    <td>\n<p>      Shows what Angular means by a <em>view</em>.\nDemonstrates the <code>ngAfterViewInit</code> and <code>ngAfterViewChecked</code> hooks.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#aftercontent\">AfterContent</a>\n    </td>\n    <td>\n<p>      Shows how to project external content into a component and\nhow to distinguish projected content from a component's view children.\nDemonstrates the <code>ngAfterContentInit</code> and <code>ngAfterContentChecked</code> hooks.</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      Counter\n    </td>\n    <td>\n<p>      Demonstrates a combination of a component and a directive\neach with its own hooks.</p>\n<p>      In this example, a <code>CounterComponent</code> logs a change (via <code>ngOnChanges</code>)\nevery time the parent component increments its input counter property.\nMeanwhile, the <code>SpyDirective</code> from the previous example is applied\nto the <code>CounterComponent</code> log where it watches log entries being created and destroyed.</p>\n    </td>\n  </tr>\n</tbody></table>\n<p>The remainder of this page discusses selected exercises in further detail.</p>\n<a id=\"peek-a-boo\"></a>\n<h2 id=\"peek-a-boo-all-hooks\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#peek-a-boo-all-hooks\"><i class=\"material-icons\">link</i></a>Peek-a-boo: all hooks</h2>\n<p>The <code>PeekABooComponent</code> demonstrates all of the hooks in one component.</p>\n<p>You would rarely, if ever, implement all of the interfaces like this.\nThe peek-a-boo exists to show how Angular calls the hooks in the expected order.</p>\n<p>This snapshot reflects the state of the log after the user clicked the <em>Create...</em> button and then the <em>Destroy...</em> button.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/peek-a-boo.png\" alt=\"Peek-a-boo\" width=\"309\" height=\"366\">\n</figure>\n<p>The sequence of log messages follows the prescribed hook calling order:\n<code><a href=\"api/core/OnChanges\">OnChanges</a></code>, <code><a href=\"api/core/OnInit\">OnInit</a></code>, <code><a href=\"api/core/DoCheck\">DoCheck</a></code> (3x), <code><a href=\"api/core/AfterContentInit\">AfterContentInit</a></code>, <code><a href=\"api/core/AfterContentChecked\">AfterContentChecked</a></code> (3x),\n<code><a href=\"api/core/AfterViewInit\">AfterViewInit</a></code>, <code><a href=\"api/core/AfterViewChecked\">AfterViewChecked</a></code> (3x), and <code><a href=\"api/core/OnDestroy\">OnDestroy</a></code>.</p>\n<div class=\"l-sub-section\">\n<p>  The constructor isn't an Angular hook <em>per se</em>.\nThe log confirms that input properties (the <code>name</code> property in this case) have no assigned values at construction.</p>\n</div>\n<p>Had the user clicked the <em>Update Hero</em> button, the log would show another <code><a href=\"api/core/OnChanges\">OnChanges</a></code> and two more triplets of\n<code><a href=\"api/core/DoCheck\">DoCheck</a></code>, <code><a href=\"api/core/AfterContentChecked\">AfterContentChecked</a></code> and <code><a href=\"api/core/AfterViewChecked\">AfterViewChecked</a></code>.\nClearly these three hooks fire <em>often</em>. Keep the logic in these hooks as lean as possible!</p>\n<p>The next examples focus on hook details.</p>\n<a id=\"spy\"></a>\n<h2 id=\"spying-oninit-and-ondestroy\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#spying-oninit-and-ondestroy\"><i class=\"material-icons\">link</i></a>Spying <em>OnInit</em> and <em>OnDestroy</em></h2>\n<p>Go undercover with these two spy hooks to discover when an element is initialized or destroyed.</p>\n<p>This is the perfect infiltration job for a directive.\nThe heroes will never know they're being watched.</p>\n<div class=\"l-sub-section\">\n<p>  Kidding aside, pay attention to two key points:</p>\n<ol>\n<li>\n<p>Angular calls hook methods for <em>directives</em> as well as components.<br><br></p>\n</li>\n<li>\n<p>A spy directive can provide insight into a DOM object that you cannot change directly.\nObviously you can't touch the implementation of a native <code>&#x3C;div></code>.\nYou can't modify a third party component either.\nBut you can watch both with a directive.</p>\n</li>\n</ol>\n</div>\n<p>The sneaky spy directive is simple, consisting almost entirely of <code>ngOnInit()</code> and <code>ngOnDestroy()</code> hooks\nthat log messages to the parent via an injected <code>LoggerService</code>.</p>\n<code-example path=\"lifecycle-hooks/src/app/spy.directive.ts\" region=\"spy-directive\" title=\"src/app/spy.directive.ts\" linenums=\"false\">\n// Spy on any element to which it is applied.\n// Usage: &#x3C;div mySpy>...&#x3C;/div>\n@Directive({selector: '[mySpy]'})\nexport class SpyDirective implements OnInit, OnDestroy {\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit()    { this.logIt(`onInit`); }\n\n  ngOnDestroy() { this.logIt(`onDestroy`); }\n\n  private logIt(msg: string) {\n    this.logger.log(`Spy #${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p>You can apply the spy to any native or component element and it'll be initialized and destroyed\nat the same time as that element.\nHere it is attached to the repeated hero <code>&#x3C;div></code>:</p>\n<code-example path=\"lifecycle-hooks/src/app/spy.component.html\" region=\"template\" title=\"src/app/spy.component.html\" linenums=\"false\">\n&#x3C;div *ngFor=\"let hero of heroes\" mySpy class=\"heroes\">\n  {{hero}}\n&#x3C;/div>\n\n</code-example>\n<p>Each spy's birth and death marks the birth and death of the attached hero <code>&#x3C;div></code>\nwith an entry in the <em>Hook Log</em> as seen here:</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/spy-directive.gif\" alt=\"Spy Directive\" width=\"656\" height=\"378\">\n</figure>\n<p>Adding a hero results in a new hero <code>&#x3C;div></code>. The spy's <code>ngOnInit()</code> logs that event.</p>\n<p>The <em>Reset</em> button clears the <code>heroes</code> list.\nAngular removes all hero <code>&#x3C;div></code> elements from the DOM and destroys their spy directives at the same time.\nThe spy's <code>ngOnDestroy()</code> method reports its last moments.</p>\n<p>The <code>ngOnInit()</code> and <code>ngOnDestroy()</code> methods have more vital roles to play in real applications.</p>\n<a id=\"oninit\"></a>\n<h3 id=\"oninit\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#oninit\"><i class=\"material-icons\">link</i></a><em>OnInit()</em></h3>\n<p>Use <code>ngOnInit()</code> for two main reasons:</p>\n<ol>\n<li>To perform complex initializations shortly after construction.</li>\n<li>To set up the component after Angular sets the input properties.</li>\n</ol>\n<p>Experienced developers agree that components should be cheap and safe to construct.</p>\n<div class=\"l-sub-section\">\n<p>  Misko Hevery, Angular team lead,\n<a href=\"http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/\">explains why</a>\nyou should avoid complex constructor logic.</p>\n</div>\n<p>Don't fetch data in a component constructor.\nYou shouldn't worry that a new component will try to contact a remote server when\ncreated under test or before you decide to display it.\nConstructors should do no more than set the initial local variables to simple values.</p>\n<p>An <code>ngOnInit()</code> is a good place for a component to fetch its initial data. The\n<a href=\"tutorial/toh-pt4#oninit\">Tour of Heroes Tutorial</a> and <a href=\"guide/http#oninit\">HTTP Client</a>\nguides show how.</p>\n<p>Remember also that a directive's data-bound input properties are not set until <em>after construction</em>.\nThat's a problem if you need to initialize the directive based on those properties.\nThey'll have been set when <code>ngOnInit()</code> runs.</p>\n<div class=\"l-sub-section\">\n<p>  The <code>ngOnChanges()</code> method is your first opportunity to access those properties.\nAngular calls <code>ngOnChanges()</code> before <code>ngOnInit()</code> and many times after that.\nIt only calls <code>ngOnInit()</code> once.</p>\n</div>\n<p>You can count on Angular to call the <code>ngOnInit()</code> method <em>soon</em> after creating the component.\nThat's where the heavy initialization logic belongs.</p>\n<a id=\"ondestroy\"></a>\n<h3 id=\"ondestroy\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#ondestroy\"><i class=\"material-icons\">link</i></a><em>OnDestroy()</em></h3>\n<p>Put cleanup logic in <code>ngOnDestroy()</code>, the logic that <em>must</em> run before Angular destroys the directive.</p>\n<p>This is the time to notify another part of the application that the component is going away.</p>\n<p>This is the place to free resources that won't be garbage collected automatically.\nUnsubscribe from Observables and DOM events. Stop interval timers.\nUnregister all callbacks that this directive registered with global or application services.\nYou risk memory leaks if you neglect to do so.</p>\n<a id=\"onchanges\"></a>\n<h2 id=\"onchanges\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#onchanges\"><i class=\"material-icons\">link</i></a><em>OnChanges()</em></h2>\n<p>Angular calls its <code>ngOnChanges()</code> method whenever it detects changes to <strong><em>input properties</em></strong> of the component (or directive).\nThis example monitors the <code><a href=\"api/core/OnChanges\">OnChanges</a></code> hook.</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"ng-on-changes\" title=\"on-changes.component.ts (excerpt)\" linenums=\"false\">\nngOnChanges(changes: SimpleChanges) {\n  for (let propName in changes) {\n    let chng = changes[propName];\n    let cur  = JSON.stringify(chng.currentValue);\n    let prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}\n\n</code-example>\n<p>The <code>ngOnChanges()</code> method takes an object that maps each changed property name to a\n<a href=\"api/core/SimpleChange\">SimpleChange</a> object holding the current and previous property values.\nThis hook iterates over the changed properties and logs them.</p>\n<p>The example component, <code>OnChangesComponent</code>, has two input properties: <code>hero</code> and <code>power</code>.</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"inputs\" title=\"src/app/on-changes.component.ts\" linenums=\"false\">\n@Input() hero: Hero;\n@Input() power: string;\n\n</code-example>\n<p>The host <code>OnChangesParentComponent</code> binds to them like this:</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes-parent.component.html\" region=\"on-changes\" title=\"src/app/on-changes-parent.component.html\">\n&#x3C;on-changes [hero]=\"hero\" [power]=\"power\">&#x3C;/on-changes>\n\n</code-example>\n<p>Here's the sample in action as the user makes changes.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/on-changes-anim.gif\" alt=\"OnChanges\" width=\"632\" height=\"512\">\n</figure>\n<p>The log entries appear as the string value of the <em>power</em> property changes.\nBut the <code>ngOnChanges</code> does not catch changes to <code>hero.name</code>\nThat's surprising at first.</p>\n<p>Angular only calls the hook when the value of the input property changes.\nThe value of the <code>hero</code> property is the <em>reference to the hero object</em>.\nAngular doesn't care that the hero's own <code>name</code> property changed.\nThe hero object <em>reference</em> didn't change so, from Angular's perspective, there is no change to report!</p>\n<a id=\"docheck\"></a>\n<h2 id=\"docheck\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#docheck\"><i class=\"material-icons\">link</i></a><em>DoCheck()</em></h2>\n<p>Use the <code><a href=\"api/core/DoCheck\">DoCheck</a></code> hook to detect and act upon changes that Angular doesn't catch on its own.</p>\n<div class=\"l-sub-section\">\n<p>  Use this method to detect a change that Angular overlooked.</p>\n</div>\n<p>The <em>DoCheck</em> sample extends the <em>OnChanges</em> sample with the following <code>ngDoCheck()</code> hook:</p>\n<code-example path=\"lifecycle-hooks/src/app/do-check.component.ts\" region=\"ng-do-check\" title=\"DoCheckComponent (ngDoCheck)\" linenums=\"false\">\nngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`DoCheck: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // log that hook was called when there was no relevant change.\n      let count = this.noChangeCount += 1;\n      let noChangeMsg = `DoCheck called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // add new \"no change\" message\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // update last \"no change\" message\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}\n\n</code-example>\n<p>This code inspects certain <em>values of interest</em>, capturing and comparing their current state against previous values.\nIt writes a special message to the log when there are no substantive changes to the <code>hero</code> or the <code>power</code>\nso you can see how often <code><a href=\"api/core/DoCheck\">DoCheck</a></code> is called. The results are illuminating:</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/do-check-anim.gif\" alt=\"DoCheck\" width=\"632\" height=\"588\">\n</figure>\n<p>While the <code>ngDoCheck()</code> hook can detect when the hero's <code>name</code> has changed, it has a frightful cost.\nThis hook is called with enormous frequency—after <em>every</em>\nchange detection cycle no matter where the change occurred.\nIt's called over twenty times in this example before the user can do anything.</p>\n<p>Most of these initial checks are triggered by Angular's first rendering of <em>unrelated data elsewhere on the page</em>.\nMere mousing into another <code>&#x3C;input></code> triggers a call.\nRelatively few calls reveal actual changes to pertinent data.\nClearly our implementation must be very lightweight or the user experience suffers.</p>\n<a id=\"afterview\"></a>\n<h2 id=\"afterview\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#afterview\"><i class=\"material-icons\">link</i></a>AfterView</h2>\n<p>The <em>AfterView</em> sample explores the <code>AfterViewInit()</code> and <code>AfterViewChecked()</code> hooks that Angular calls\n<em>after</em> it creates a component's child views.</p>\n<p>Here's a child view that displays a hero's name in an <code>&#x3C;input></code>:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"child-view\" title=\"ChildComponent\" linenums=\"false\">\n@Component({\n  selector: 'my-child-view',\n  template: '&#x3C;input [(ngModel)]=\"hero\">'\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}\n\n</code-example>\n<p>The <code>AfterViewComponent</code> displays this child view <em>within its template</em>:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"template\" title=\"AfterViewComponent (template)\" linenums=\"false\">\ntemplate: `\n  &#x3C;div>-- child view begins --&#x3C;/div>\n    &#x3C;my-child-view>&#x3C;/my-child-view>\n  &#x3C;div>-- child view ends --&#x3C;/div>`\n\n</code-example>\n<p>The following hooks take action based on changing values <em>within the child view</em>,\nwhich can only be reached by querying for the child view via the property decorated with\n<a href=\"api/core/ViewChild\">@ViewChild</a>.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"hooks\" title=\"AfterViewComponent (class excerpts)\" linenums=\"false\">\nexport class AfterViewComponent implements  AfterViewChecked, AfterViewInit {\n  private prevHero = '';\n\n  // Query for a VIEW child of type `ChildViewComponent`\n  @ViewChild(ChildViewComponent) viewChild: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild is set after the view has been initialized\n    this.logIt('AfterViewInit');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // viewChild is updated after the view has been checked\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('AfterViewChecked (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('AfterViewChecked');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<a id=\"wait-a-tick\"></a>\n<h3 id=\"abide-by-the-unidirectional-data-flow-rule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#abide-by-the-unidirectional-data-flow-rule\"><i class=\"material-icons\">link</i></a>Abide by the unidirectional data flow rule</h3>\n<p>The <code>doSomething()</code> method updates the screen when the hero name exceeds 10 characters.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"do-something\" title=\"AfterViewComponent (doSomething)\" linenums=\"false\">\n// This surrogate for real business logic sets the `comment`\nprivate doSomething() {\n  let c = this.viewChild.hero.length > 10 ? `That's a long name` : '';\n  if (c !== this.comment) {\n    // Wait a tick because the component's view has already been checked\n    this.logger.tick_then(() => this.comment = c);\n  }\n}\n\n</code-example>\n<p>Why does the <code>doSomething()</code> method wait a tick before updating <code>comment</code>?</p>\n<p>Angular's unidirectional data flow rule forbids updates to the view <em>after</em> it has been composed.\nBoth of these hooks fire <em>after</em> the component's view has been composed.</p>\n<p>Angular throws an error if the hook updates the component's data-bound <code>comment</code> property immediately (try it!).\nThe <code>LoggerService.tick_then()</code> postpones the log update\nfor one turn of the browser's JavaScript cycle and that's just long enough.</p>\n<p>Here's <em>AfterView</em> in action:</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/after-view-anim.gif\" alt=\"AfterView\" width=\"520\" height=\"532\">\n</figure>\n<p>Notice that Angular frequently calls <code>AfterViewChecked()</code>, often when there are no changes of interest.\nWrite lean hook methods to avoid performance problems.</p>\n<a id=\"aftercontent\"></a>\n<h2 id=\"aftercontent\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#aftercontent\"><i class=\"material-icons\">link</i></a>AfterContent</h2>\n<p>The <em>AfterContent</em> sample explores the <code>AfterContentInit()</code> and <code>AfterContentChecked()</code> hooks that Angular calls\n<em>after</em> Angular projects external content into the component.</p>\n<a id=\"content-projection\"></a>\n<h3 id=\"content-projection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#content-projection\"><i class=\"material-icons\">link</i></a>Content projection</h3>\n<p><em>Content projection</em> is a way to import HTML content from outside the component and insert that content\ninto the component's template in a designated spot.</p>\n<div class=\"l-sub-section\">\n<p>  AngularJS developers know this technique as <em>transclusion</em>.</p>\n</div>\n<p>Consider this variation on the <a href=\"guide/lifecycle-hooks#afterview\">previous <em>AfterView</em></a> example.\nThis time, instead of including the child view within the template, it imports the content from\nthe <code>AfterContentComponent</code>'s parent. Here's the parent's template:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"parent-template\" title=\"AfterContentParentComponent (template excerpt)\" linenums=\"false\">\n`&#x3C;after-content>\n   &#x3C;my-child>&#x3C;/my-child>\n &#x3C;/after-content>`\n\n</code-example>\n<p>Notice that the <code>&#x3C;my-child></code> tag is tucked between the <code>&#x3C;after-content></code> tags.\nNever put content between a component's element tags <em>unless you intend to project that content\ninto the component</em>.</p>\n<p>Now look at the component's template:</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"template\" title=\"AfterContentComponent (template)\" linenums=\"false\">\ntemplate: `\n  &#x3C;div>-- projected content begins --&#x3C;/div>\n    &#x3C;ng-content>&#x3C;/ng-content>\n  &#x3C;div>-- projected content ends --&#x3C;/div>`\n\n</code-example>\n<p>The <code>&#x3C;ng-content></code> tag is a <em>placeholder</em> for the external content.\nIt tells Angular where to insert that content.\nIn this case, the projected content is the <code>&#x3C;my-child></code> from the parent.</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/projected-child-view.png\" alt=\"Projected Content\" width=\"230\" height=\"89\">\n</figure>\n<div class=\"l-sub-section\">\n<p>  The telltale signs of <em>content projection</em> are twofold:</p>\n<ul>\n<li>HTML between component element tags.</li>\n<li>The presence of <code>&#x3C;ng-content></code> tags in the component's template.</li>\n</ul>\n</div>\n<a id=\"aftercontent-hooks\"></a>\n<h3 id=\"aftercontent-hooks\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#aftercontent-hooks\"><i class=\"material-icons\">link</i></a>AfterContent hooks</h3>\n<p><em>AfterContent</em> hooks are similar to the <em>AfterView</em> hooks.\nThe key difference is in the child component.</p>\n<ul>\n<li>\n<p>The <em>AfterView</em> hooks concern <code><a href=\"api/core/ViewChildren\">ViewChildren</a></code>, the child components whose element tags\nappear <em>within</em> the component's template.</p>\n</li>\n<li>\n<p>The <em>AfterContent</em> hooks concern <code><a href=\"api/core/ContentChildren\">ContentChildren</a></code>, the child components that Angular\nprojected into the component.</p>\n</li>\n</ul>\n<p>The following <em>AfterContent</em> hooks take action based on changing values in a <em>content child</em>,\nwhich can only be reached by querying for them via the property decorated with\n<a href=\"api/core/ContentChild\">@ContentChild</a>.</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"hooks\" title=\"AfterContentComponent (class excerpts)\" linenums=\"false\">\nexport class AfterContentComponent implements AfterContentChecked, AfterContentInit {\n  private prevHero = '';\n  comment = '';\n\n  // Query for a CONTENT child of type `ChildComponent`\n  @ContentChild(ChildComponent) contentChild: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild is set after the content has been initialized\n    this.logIt('AfterContentInit');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // contentChild is updated after the content has been checked\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('AfterContentChecked (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('AfterContentChecked');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<a id=\"no-unidirectional-flow-worries\"></a>\n<h3 id=\"no-unidirectional-flow-worries-with-aftercontent\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/lifecycle-hooks#no-unidirectional-flow-worries-with-aftercontent\"><i class=\"material-icons\">link</i></a>No unidirectional flow worries with <em>AfterContent</em></h3>\n<p>This component's <code>doSomething()</code> method update's the component's data-bound <code>comment</code> property immediately.\nThere's no <a href=\"guide/lifecycle-hooks#wait-a-tick\">need to wait</a>.</p>\n<p>Recall that Angular calls both <em>AfterContent</em> hooks before calling either of the <em>AfterView</em> hooks.\nAngular completes composition of the projected content <em>before</em> finishing the composition of this component's view.\nThere is a small window between the <code>AfterContent...</code> and <code>AfterView...</code> hooks to modify the host view.</p>\n\n</div>"
}