{
  "id": "guide/cheatsheet",
  "title": "Cheat Sheet",
  "contents": "\n<div class=\"content\">\n<h1 id=\"cheat-sheet\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cheatsheet#cheat-sheet\"><i class=\"material-icons\">link</i></a>Cheat Sheet</h1>\n<div id=\"cheatsheet\">\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Bootstrapping</th>\n<th><p><code>import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td><code><b>platformBrowserDynamic().bootstrapModule</b>(AppModule);</code></td>\n<td><p>Bootstraps the app, using the root component from the specified <code><a href=\"api/core/NgModule\">NgModule</a></code>. </p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>NgModules</th>\n<th><p><code>import { NgModule } from '@angular/core';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td><code>@<b>NgModule</b>({ declarations: ..., imports: ...,<br>     exports: ..., providers: ..., bootstrap: ...})<br>class MyModule {}</code></td>\n<td><p>Defines a module that contains components, directives, pipes, and providers.</p>\n</td>\n</tr><tr>\n<td><code><b>declarations:</b> [MyRedComponent, MyBlueComponent, MyDatePipe]</code></td>\n<td><p>List of components, directives, and pipes that belong to this module.</p>\n</td>\n</tr><tr>\n<td><code><b>imports:</b> [BrowserModule, SomeOtherModule]</code></td>\n<td><p>List of modules to import into this module. Everything from the imported modules\nis available to <code>declarations</code> of this module.</p>\n</td>\n</tr><tr>\n<td><code><b>exports:</b> [MyRedComponent, MyDatePipe]</code></td>\n<td><p>List of components, directives, and pipes visible to modules that import this module.</p>\n</td>\n</tr><tr>\n<td><code><b>providers:</b> [MyService, { provide: ... }]</code></td>\n<td><p>List of dependency injection providers visible both to the contents of this module and to importers of this module.</p>\n</td>\n</tr><tr>\n<td><code><b>bootstrap:</b> [MyAppComponent]</code></td>\n<td><p>List of components to bootstrap when this module is bootstrapped.</p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Template syntax</th>\n<th></th>\n</tr>\n<tr>\n<td><code>&#x3C;input <b>[value]</b>=\"firstName\"></code></td>\n<td><p>Binds property <code>value</code> to the result of expression <code>firstName</code>.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;div <b>[attr.role]</b>=\"myAriaRole\"></code></td>\n<td><p>Binds attribute <code>role</code> to the result of expression <code>myAriaRole</code>.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;div <b>[class.extra-sparkle]</b>=\"isDelightful\"></code></td>\n<td><p>Binds the presence of the CSS class <code>extra-sparkle</code> on the element to the truthiness of the expression <code>isDelightful</code>.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;div <b>[style.width.px]</b>=\"mySize\"></code></td>\n<td><p>Binds style property <code>width</code> to the result of expression <code>mySize</code> in pixels. Units are optional.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;button <b>(click)</b>=\"readRainbow($event)\"></code></td>\n<td><p>Calls method <code>readRainbow</code> when a click event is triggered on this button element (or its children) and passes in the event object.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;div title=\"Hello <b>{{ponyName}}</b>\"></code></td>\n<td><p>Binds a property to an interpolated string, for example, \"Hello Seabiscuit\". Equivalent to:\n<code>&#x3C;div [title]=\"'Hello ' + ponyName\"></code></p>\n</td>\n</tr><tr>\n<td><code>&#x3C;p>Hello <b>{{ponyName}}</b>&#x3C;/p></code></td>\n<td><p>Binds text content to an interpolated string, for example, \"Hello Seabiscuit\".</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;my-cmp <b>[(title)]</b>=\"name\"></code></td>\n<td><p>Sets up two-way data binding. Equivalent to: <code>&#x3C;my-cmp [title]=\"name\" (titleChange)=\"name=$event\"></code></p>\n</td>\n</tr><tr>\n<td><code>&#x3C;video <b>#movieplayer</b> ...><br>  &#x3C;button <b>(click)</b>=\"movieplayer.play()\"><br>&#x3C;/video></code></td>\n<td><p>Creates a local variable <code>movieplayer</code> that provides access to the <code>video</code> element instance in data-binding and event-binding expressions in the current template.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;p <b>*myUnless</b>=\"myExpression\">...&#x3C;/p></code></td>\n<td><p>The <code>*</code> symbol turns the current element into an embedded template. Equivalent to:\n<code>&#x3C;ng-template [myUnless]=\"myExpression\">&#x3C;p>...&#x3C;/p>&#x3C;/ng-template></code></p>\n</td>\n</tr><tr>\n<td><code>&#x3C;p>Card No.: <b>{{cardNumber | myCardNumberFormatter}}</b>&#x3C;/p></code></td>\n<td><p>Transforms the current value of expression <code>cardNumber</code> via the pipe called <code>myCardNumberFormatter</code>.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;p>Employer: <b>{{employer?.companyName}}</b>&#x3C;/p></code></td>\n<td><p>The safe navigation operator (<code>?</code>) means that the <code>employer</code> field is optional and if <code>undefined</code>, the rest of the expression should be ignored.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;<b>svg:</b>rect x=\"0\" y=\"0\" width=\"100\" height=\"100\"/></code></td>\n<td><p>An SVG snippet template needs an <code>svg:</code> prefix on its root element to disambiguate the SVG element from an HTML component.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;<b>svg</b>><br>  &#x3C;rect x=\"0\" y=\"0\" width=\"100\" height=\"100\"/><br>&#x3C;/<b>svg</b>></code></td>\n<td><p>An <code>&#x3C;svg></code> root element is detected as an SVG element automatically, without the prefix.</p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Built-in directives</th>\n<th><p><code>import { CommonModule } from '@angular/common';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td><code>&#x3C;section <b>*ngIf</b>=\"showSection\"></code></td>\n<td><p>Removes or recreates a portion of the DOM tree based on the <code>showSection</code> expression.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;li <b>*ngFor</b>=\"let item of list\"></code></td>\n<td><p>Turns the li element and its contents into a template, and uses that to instantiate a view for each item in list.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;div <b>[ngSwitch]</b>=\"conditionExpression\"><br>  &#x3C;ng-template <b>[<b>ngSwitchCase</b>]</b>=\"case1Exp\">...&#x3C;/ng-template><br>  &#x3C;ng-template <b>ngSwitchCase</b>=\"case2LiteralString\">...&#x3C;/ng-template><br>  &#x3C;ng-template <b>ngSwitchDefault</b>>...&#x3C;/ng-template><br>&#x3C;/div></code></td>\n<td><p>Conditionally swaps the contents of the div by selecting one of the embedded templates based on the current value of <code>conditionExpression</code>.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;div <b>[ngClass]</b>=\"{'active': isActive, 'disabled': isDisabled}\"></code></td>\n<td><p>Binds the presence of CSS classes on the element to the truthiness of the associated map values. The right-hand expression should return {class-name: true/false} map.</p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Forms</th>\n<th><p><code>import { FormsModule } from '@angular/forms';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td><code>&#x3C;input <b>[(ngModel)]</b>=\"userName\"></code></td>\n<td><p>Provides two-way data-binding, parsing, and validation for form controls.</p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Class decorators</th>\n<th><p><code>import { Directive, ... } from '@angular/core';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td><code><b>@Component({...})</b><br>class MyComponent() {}</code></td>\n<td><p>Declares that a class is a component and provides metadata about the component.</p>\n</td>\n</tr><tr>\n<td><code><b>@Directive({...})</b><br>class MyDirective() {}</code></td>\n<td><p>Declares that a class is a directive and provides metadata about the directive.</p>\n</td>\n</tr><tr>\n<td><code><b>@Pipe({...})</b><br>class MyPipe() {}</code></td>\n<td><p>Declares that a class is a pipe and provides metadata about the pipe.</p>\n</td>\n</tr><tr>\n<td><code><b>@Injectable()</b><br>class MyService() {}</code></td>\n<td><p>Declares that a class has dependencies that should be injected into the constructor when the dependency injector is creating an instance of this class.\n</p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Directive configuration</th>\n<th><p><code>@Directive({ property1: value1, ... })</code>\n</p>\n</th>\n</tr>\n<tr>\n<td><code><b>selector:</b> '.cool-button:not(a)'</code></td>\n<td><p>Specifies a CSS selector that identifies this directive within a template. Supported selectors include <code>element</code>,\n<code>[attribute]</code>, <code>.class</code>, and <code>:not()</code>.</p>\n<p>Does not support parent-child relationship selectors.</p>\n</td>\n</tr><tr>\n<td><code><b>providers:</b> [MyService, { provide: ... }]</code></td>\n<td><p>List of dependency injection providers for this directive and its children.</p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Component configuration</th>\n<th><p>\n<code>@Component</code> extends <code>@Directive</code>,\nso the <code>@Directive</code> configuration applies to components as well</p>\n</th>\n</tr>\n<tr>\n<td><code><b>moduleId:</b> module.id</code></td>\n<td><p>If set, the <code>templateUrl</code> and <code>styleUrl</code> are resolved relative to the component.</p>\n</td>\n</tr><tr>\n<td><code><b>viewProviders:</b> [MyService, { provide: ... }]</code></td>\n<td><p>List of dependency injection providers scoped to this component's view.</p>\n</td>\n</tr><tr>\n<td><code><b>template:</b> 'Hello {{name}}'<br><b>templateUrl:</b> 'my-component.html'</code></td>\n<td><p>Inline template or external template URL of the component's view.</p>\n</td>\n</tr><tr>\n<td><code><b>styles:</b> ['.primary {color: red}']<br><b>styleUrls:</b> ['my-component.css']</code></td>\n<td><p>List of inline CSS styles or external stylesheet URLs for styling the component’s view.</p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Class field decorators for directives and components</th>\n<th><p><code>import { Input, ... } from '@angular/core';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td><code><b>@Input()</b> myProperty;</code></td>\n<td><p>Declares an input property that you can update via property binding (example:\n<code>&#x3C;my-cmp [myProperty]=\"someExpression\"></code>).</p>\n</td>\n</tr><tr>\n<td><code><b>@Output()</b> myEvent = new EventEmitter();</code></td>\n<td><p>Declares an output property that fires events that you can subscribe to with an event binding (example: <code>&#x3C;my-cmp (myEvent)=\"doSomething()\"></code>).</p>\n</td>\n</tr><tr>\n<td><code><b>@HostBinding('class.valid')</b> isValid;</code></td>\n<td><p>Binds a host element property (here, the CSS class <code>valid</code>) to a directive/component property (<code>isValid</code>).</p>\n</td>\n</tr><tr>\n<td><code><b>@HostListener('click', ['$event'])</b> onClick(e) {...}</code></td>\n<td><p>Subscribes to a host element event (<code>click</code>) with a directive/component method (<code>onClick</code>), optionally passing an argument (<code>$event</code>).</p>\n</td>\n</tr><tr>\n<td><code><b>@ContentChild(myPredicate)</b> myChildComponent;</code></td>\n<td><p>Binds the first result of the component content query (<code>myPredicate</code>) to a property (<code>myChildComponent</code>) of the class.</p>\n</td>\n</tr><tr>\n<td><code><b>@ContentChildren(myPredicate)</b> myChildComponents;</code></td>\n<td><p>Binds the results of the component content query (<code>myPredicate</code>) to a property (<code>myChildComponents</code>) of the class.</p>\n</td>\n</tr><tr>\n<td><code><b>@ViewChild(myPredicate)</b> myChildComponent;</code></td>\n<td><p>Binds the first result of the component view query (<code>myPredicate</code>) to a property (<code>myChildComponent</code>) of the class. Not available for directives.</p>\n</td>\n</tr><tr>\n<td><code><b>@ViewChildren(myPredicate)</b> myChildComponents;</code></td>\n<td><p>Binds the results of the component view query (<code>myPredicate</code>) to a property (<code>myChildComponents</code>) of the class. Not available for directives.</p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Directive and component change detection and lifecycle hooks</th>\n<th><p>(implemented as class methods)\n</p>\n</th>\n</tr>\n<tr>\n<td><code><b>constructor(myService: MyService, ...)</b> { ... }</code></td>\n<td><p>Called before any other lifecycle hook. Use it to inject dependencies, but avoid any serious work here.</p>\n</td>\n</tr><tr>\n<td><code><b>ngOnChanges(changeRecord)</b> { ... }</code></td>\n<td><p>Called after every change to input properties and before processing content or child views.</p>\n</td>\n</tr><tr>\n<td><code><b>ngOnInit()</b> { ... }</code></td>\n<td><p>Called after the constructor, initializing input properties, and the first call to <code>ngOnChanges</code>.</p>\n</td>\n</tr><tr>\n<td><code><b>ngDoCheck()</b> { ... }</code></td>\n<td><p>Called every time that the input properties of a component or a directive are checked. Use it to extend change detection by performing a custom check.</p>\n</td>\n</tr><tr>\n<td><code><b>ngAfterContentInit()</b> { ... }</code></td>\n<td><p>Called after <code>ngOnInit</code> when the component's or directive's content has been initialized.</p>\n</td>\n</tr><tr>\n<td><code><b>ngAfterContentChecked()</b> { ... }</code></td>\n<td><p>Called after every check of the component's or directive's content.</p>\n</td>\n</tr><tr>\n<td><code><b>ngAfterViewInit()</b> { ... }</code></td>\n<td><p>Called after <code>ngAfterContentInit</code> when the component's view has been initialized. Applies to components only.</p>\n</td>\n</tr><tr>\n<td><code><b>ngAfterViewChecked()</b> { ... }</code></td>\n<td><p>Called after every check of the component's view. Applies to components only.</p>\n</td>\n</tr><tr>\n<td><code><b>ngOnDestroy()</b> { ... }</code></td>\n<td><p>Called once, before the instance is destroyed.</p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Dependency injection configuration</th>\n<th></th>\n</tr>\n<tr>\n<td><code>{ <b>provide</b>: MyService, <b>useClass</b>: MyMockService }</code></td>\n<td><p>Sets or overrides the provider for <code>MyService</code> to the <code>MyMockService</code> class.</p>\n</td>\n</tr><tr>\n<td><code>{ <b>provide</b>: MyService, <b>useFactory</b>: myFactory }</code></td>\n<td><p>Sets or overrides the provider for <code>MyService</code> to the <code>myFactory</code> factory function.</p>\n</td>\n</tr><tr>\n<td><code>{ <b>provide</b>: MyValue, <b>useValue</b>: 41 }</code></td>\n<td><p>Sets or overrides the provider for <code>MyValue</code> to the value <code>41</code>.</p>\n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>Routing and navigation</th>\n<th><p><code>import { Routes, RouterModule, ... } from '@angular/router';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td><code>const routes: <b>Routes</b> = [<br>  { path: '', component: HomeComponent },<br>  { path: 'path/:routeParam', component: MyComponent },<br>  { path: 'staticPath', component: ... },<br>  { path: '**', component: ... },<br>  { path: 'oldPath', redirectTo: '/staticPath' },<br>  { path: ..., component: ..., data: { message: 'Custom' } }<br>]);<br><br>const routing = RouterModule.forRoot(routes);</code></td>\n<td><p>Configures routes for the application. Supports static, parameterized, redirect, and wildcard routes. Also supports custom route data and resolve.</p>\n</td>\n</tr><tr>\n<td><code><br>&#x3C;<b>router-outlet</b>>&#x3C;/<b>router-outlet</b>><br>&#x3C;<b>router-outlet</b> name=\"aux\">&#x3C;/<b>router-outlet</b>><br></code></td>\n<td><p>Marks the location to load the component of the active route.</p>\n</td>\n</tr><tr>\n<td><code><br>&#x3C;a routerLink=\"/path\"><br>&#x3C;a <b>[routerLink]</b>=\"[ '/path', routeParam ]\"><br>&#x3C;a <b>[routerLink]</b>=\"[ '/path', { matrixParam: 'value' } ]\"><br>&#x3C;a <b>[routerLink]</b>=\"[ '/path' ]\" [queryParams]=\"{ page: 1 }\"><br>&#x3C;a <b>[routerLink]</b>=\"[ '/path' ]\" fragment=\"anchor\"><br></code></td>\n<td><p>Creates a link to a different view based on a route instruction consisting of a route path, required and optional parameters, query parameters, and a fragment. To navigate to a root route, use the <code>/</code> prefix; for a child route, use the <code>./</code>prefix; for a sibling or parent, use the <code>../</code> prefix.</p>\n</td>\n</tr><tr>\n<td><code>&#x3C;a [routerLink]=\"[ '/path' ]\" routerLinkActive=\"active\"></code></td>\n<td><p>The provided classes are added to the element when the <code>routerLink</code> becomes the current active route.</p>\n</td>\n</tr><tr>\n<td><code>class <b>CanActivate</b>Guard implements <b>CanActivate</b> {<br>    canActivate(<br>      route: ActivatedRouteSnapshot,<br>      state: RouterStateSnapshot<br>    ): Observable&#x3C;boolean>|Promise&#x3C;boolean>|boolean { ... }<br>}<br><br>{ path: ..., canActivate: [<b>CanActivate</b>Guard] }</code></td>\n<td><p>An interface for defining a class that the router should call first to determine if it should activate this component. Should return a boolean or an Observable/Promise that resolves to a boolean.</p>\n</td>\n</tr><tr>\n<td><code>class <b>CanDeactivate</b>Guard implements <b>CanDeactivate</b>&#x3C;T> {<br>    canDeactivate(<br>      component: T,<br>      route: ActivatedRouteSnapshot,<br>      state: RouterStateSnapshot<br>    ): Observable&#x3C;boolean>|Promise&#x3C;boolean>|boolean { ... }<br>}<br><br>{ path: ..., canDeactivate: [<b>CanDeactivate</b>Guard] }</code></td>\n<td><p>An interface for defining a class that the router should call first to determine if it should deactivate this component after a navigation. Should return a boolean or an Observable/Promise that resolves to a boolean.</p>\n</td>\n</tr><tr>\n<td><code>class <b>CanActivateChild</b>Guard implements <b>CanActivateChild</b> {<br>    canActivateChild(<br>      route: ActivatedRouteSnapshot,<br>      state: RouterStateSnapshot<br>    ): Observable&#x3C;boolean>|Promise&#x3C;boolean>|boolean { ... }<br>}<br><br>{ path: ..., canActivateChild: [CanActivateGuard],<br>    children: ... }</code></td>\n<td><p>An interface for defining a class that the router should call first to determine if it should activate the child route. Should return a boolean or an Observable/Promise that resolves to a boolean.</p>\n</td>\n</tr><tr>\n<td><code>class <b>Resolve</b>Guard implements <b>Resolve</b>&#x3C;T> {<br>    resolve(<br>      route: ActivatedRouteSnapshot,<br>      state: RouterStateSnapshot<br>    ): Observable&#x3C;any>|Promise&#x3C;any>|any { ... }<br>}<br><br>{ path: ..., resolve: [<b>Resolve</b>Guard] }</code></td>\n<td><p>An interface for defining a class that the router should call first to resolve route data before rendering the route. Should return a value or an Observable/Promise that resolves to a value.</p>\n</td>\n</tr><tr>\n<td><code>class <b>CanLoad</b>Guard implements <b>CanLoad</b> {<br>    canLoad(<br>      route: Route<br>    ): Observable&#x3C;boolean>|Promise&#x3C;boolean>|boolean { ... }<br>}<br><br>{ path: ..., canLoad: [<b>CanLoad</b>Guard], loadChildren: ... }</code></td>\n<td><p>An interface for defining a class that the router should call first to check if the lazy loaded module should be loaded. Should return a boolean or an Observable/Promise that resolves to a boolean.</p>\n</td>\n</tr>\n</tbody></table>\n</div>\n\n</div>"
}