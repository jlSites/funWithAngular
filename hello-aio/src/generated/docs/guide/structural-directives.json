{
  "id": "guide/structural-directives",
  "title": "Structural Directives",
  "contents": "\n<div class=\"content\">\n<h1 id=\"structural-directives\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#structural-directives\"><i class=\"material-icons\">link</i></a>Structural Directives</h1>\n<style>\n  h4 {font-size: 17px !important; text-transform: none !important;}\n  .syntax { font-family: Consolas, 'Lucida Sans', Courier, sans-serif; color: black; font-size: 85%; }\n\n</style>\n<p>This guide looks at how Angular manipulates the DOM with <strong>structural directives</strong> and\nhow you can write your own structural directives to do the same thing.</p>\n<p>Try the <live-example></live-example>.</p>\n<a id=\"definition\"></a>\n<h2 id=\"what-are-structural-directives\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#what-are-structural-directives\"><i class=\"material-icons\">link</i></a>What are structural directives?</h2>\n<p>Structural directives are responsible for HTML layout.\nThey shape or reshape the DOM's <em>structure</em>, typically by adding, removing, or manipulating\nelements.</p>\n<p>As with other directives, you apply a structural directive to a <em>host element</em>.\nThe directive then does whatever it's supposed to do with that host element and its descendents.</p>\n<p>Structural directives are easy to recognize.\nAn asterisk (*) precedes the directive attribute name as in this example.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngif)\" region=\"ngif\">\n&#x3C;div *ngIf=\"hero\" >{{hero.name}}&#x3C;/div>\n\n</code-example>\n<p>No brackets. No parentheses. Just <code>*ngIf</code> set to a string.</p>\n<p>You'll learn in this guide that the <a href=\"guide/structural-directives#asterisk\">asterisk (*) is a convenience notation</a>\nand the string is a <a href=\"guide/structural-directives#microsyntax\"><em>microsyntax</em></a> rather than the usual\n<a href=\"guide/template-syntax#template-expressions\">template expression</a>.\nAngular desugars this notation into a marked-up <code>&#x3C;ng-template></code> that surrounds the\nhost element and its descendents.\nEach structural directive does something different with that template.</p>\n<p>Three of the common, built-in structural directives—<a href=\"guide/template-syntax#ngIf\">NgIf</a>,\n<a href=\"guide/template-syntax#ngFor\">NgFor</a>, and <a href=\"guide/template-syntax#ngSwitch\">NgSwitch...</a>—are\ndescribed in the <a href=\"guide/template-syntax\"><em>Template Syntax</em></a> guide and seen in samples throughout the Angular documentation.\nHere's an example of them in a template:</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (built-in)\" region=\"built-in\">\n&#x3C;div *ngIf=\"hero\" >{{hero.name}}&#x3C;/div>\n\n&#x3C;ul>\n  &#x3C;li *ngFor=\"let hero of heroes\">{{hero.name}}&#x3C;/li>\n&#x3C;/ul>\n\n&#x3C;div [ngSwitch]=\"hero?.emotion\">\n  &#x3C;happy-hero    *ngSwitchCase=\"'happy'\"    [hero]=\"hero\">&#x3C;/happy-hero>\n  &#x3C;sad-hero      *ngSwitchCase=\"'sad'\"      [hero]=\"hero\">&#x3C;/sad-hero>\n  &#x3C;confused-hero *ngSwitchCase=\"'confused'\" [hero]=\"hero\">&#x3C;/confused-hero>\n  &#x3C;unknown-hero  *ngSwitchDefault           [hero]=\"hero\">&#x3C;/unknown-hero>\n&#x3C;/div>\n\n</code-example>\n<p>This guide won't repeat how to <em>use</em> them. But it does explain <em>how they work</em>\nand how to <a href=\"guide/structural-directives#unless\">write your own</a> structural directive.</p>\n<div class=\"callout is-helpful\">\n<header>\n  Directive spelling\n</header>\n<p>Throughout this guide, you'll see a directive spelled in both <em>UpperCamelCase</em> and <em>lowerCamelCase</em>.\nAlready you've seen <code><a href=\"api/common/NgIf\">NgIf</a></code> and <code>ngIf</code>.\nThere's a reason. <code><a href=\"api/common/NgIf\">NgIf</a></code> refers to the directive <em>class</em>;\n<code>ngIf</code> refers to the directive's <em>attribute name</em>.</p>\n<p>A directive <em>class</em> is spelled in <em>UpperCamelCase</em> (<code><a href=\"api/common/NgIf\">NgIf</a></code>).\nA directive's <em>attribute name</em> is spelled in <em>lowerCamelCase</em> (<code>ngIf</code>).\nThe guide refers to the directive <em>class</em> when talking about its properties and what the directive does.\nThe guide refers to the <em>attribute name</em> when describing how\nyou apply the directive to an element in the HTML template.</p>\n</div>\n<div class=\"l-sub-section\">\n<p>There are two other kinds of Angular directives, described extensively elsewhere:\n(1) components and (2) attribute directives.</p>\n<p>A <em>component</em> manages a region of HTML in the manner of a native HTML element.\nTechnically it's a directive with a template.</p>\n<p>An <a href=\"guide/attribute-directives\"><em>attribute</em> directive</a> changes the appearance or behavior\nof an element, component, or another directive.\nFor example, the built-in <a href=\"guide/template-syntax#ngStyle\"><code><a href=\"api/common/NgStyle\">NgStyle</a></code></a> directive\nchanges several element styles at the same time.</p>\n<p>You can apply many <em>attribute</em> directives to one host element.\nYou can <a href=\"guide/structural-directives#one-per-element\">only apply one</a> <em>structural</em> directive to a host element.</p>\n</div>\n<a id=\"ngIf\"></a>\n<h2 id=\"ngif-case-study\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#ngif-case-study\"><i class=\"material-icons\">link</i></a>NgIf case study</h2>\n<p><code><a href=\"api/common/NgIf\">NgIf</a></code> is the simplest structural directive and the easiest to understand.\nIt takes a boolean expression and makes an entire chunk of the DOM appear or disappear.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngif-true)\" region=\"ngif-true\">\n&#x3C;p *ngIf=\"true\">\n  Expression is true and ngIf is true.\n  This paragraph is in the DOM.\n&#x3C;/p>\n&#x3C;p *ngIf=\"false\">\n  Expression is false and ngIf is false.\n  This paragraph is not in the DOM.\n&#x3C;/p>\n\n</code-example>\n<p>The <code>ngIf</code> directive doesn't hide elements with CSS. It adds and removes them physically from the DOM.\nConfirm that fact using browser developer tools to inspect the DOM.</p>\n<figure>\n  <img src=\"generated/images/guide/structural-directives/element-not-in-dom.png\" alt=\"ngIf=false element not in DOM\" width=\"326\" height=\"126\">\n</figure>\n<p>The top paragraph is in the DOM. The bottom, disused paragraph is not;\nin its place is a comment about \"bindings\" (more about that <a href=\"guide/structural-directives#asterisk\">later</a>).</p>\n<p>When the condition is false, <code><a href=\"api/common/NgIf\">NgIf</a></code> removes its host element from the DOM,\ndetaches it from DOM events (the attachments that it made),\ndetaches the component from Angular change detection, and destroys it.\nThe component and DOM nodes can be garbage-collected and free up memory.</p>\n<h3 id=\"why-remove-rather-than-hide\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#why-remove-rather-than-hide\"><i class=\"material-icons\">link</i></a>Why <em>remove</em> rather than <em>hide</em>?</h3>\n<p>A directive could hide the unwanted paragraph instead by setting its <code>display</code> style to <code>none</code>.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (display-none)\" region=\"display-none\">\n&#x3C;p [style.display]=\"'block'\">\n  Expression sets display to \"block\".\n  This paragraph is visible.\n&#x3C;/p>\n&#x3C;p [style.display]=\"'none'\">\n  Expression sets display to \"none\".\n  This paragraph is hidden but still in the DOM.\n&#x3C;/p>\n\n</code-example>\n<p>While invisible, the element remains in the DOM.</p>\n<figure>\n  <img src=\"generated/images/guide/structural-directives/element-display-in-dom.png\" alt=\"hidden element still in DOM\" width=\"415\" height=\"185\">\n</figure>\n<p>The difference between hiding and removing doesn't matter for a simple paragraph.\nIt does matter when the host element is attached to a resource intensive component.\nSuch a component's behavior continues even when hidden.\nThe component stays attached to its DOM element. It keeps listening to events.\nAngular keeps checking for changes that could affect data bindings.\nWhatever the component was doing, it keeps doing.</p>\n<p>Although invisible, the component—and all of its descendant components—tie up resources.\nThe performance and memory burden can be substantial, responsiveness can degrade, and the user sees nothing.</p>\n<p>On the positive side, showing the element again is quick.\nThe component's previous state is preserved and ready to display.\nThe component doesn't re-initialize—an operation that could be expensive.\nSo hiding and showing is sometimes the right thing to do.</p>\n<p>But in the absence of a compelling reason to keep them around,\nyour preference should be to remove DOM elements that the user can't see\nand recover the unused resources with a structural directive like <code><a href=\"api/common/NgIf\">NgIf</a></code> .</p>\n<p><strong>These same considerations apply to every structural directive, whether built-in or custom.</strong>\nBefore applying a structural directive, you might want to pause for a moment\nto consider the consequences of adding and removing elements and of creating and destroying components.</p>\n<a id=\"asterisk\"></a>\n<h2 id=\"the-asterisk--prefix\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#the-asterisk--prefix\"><i class=\"material-icons\">link</i></a>The asterisk (*) prefix</h2>\n<p>Surely you noticed the asterisk (*) prefix to the directive name\nand wondered why it is necessary and what it does.</p>\n<p>Here is <code>*ngIf</code> displaying the hero's name if <code>hero</code> exists.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (asterisk)\" region=\"asterisk\">\n&#x3C;div *ngIf=\"hero\" >{{hero.name}}&#x3C;/div>\n\n</code-example>\n<p>The asterisk is \"syntactic sugar\" for something a bit more complicated.\nInternally, Angular desugars it in two stages.\nFirst, it translates the <code>*ngIf=\"...\"</code> into a template <em>attribute</em>, <code>template=\"ngIf ...\"</code>,  like this.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngif-template-attr)\" region=\"ngif-template-attr\">\n&#x3C;div template=\"ngIf hero\">{{hero.name}}&#x3C;/div>\n\n</code-example>\n<p>Then it translates the template <em>attribute</em> into a <code>&#x3C;ng-template></code> <em>element</em>, wrapped around the host element, like this.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngif-template)\" region=\"ngif-template\">\n&#x3C;ng-template [ngIf]=\"hero\">\n  &#x3C;div>{{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n</code-example>\n<ul>\n<li>The <code>*ngIf</code> directive moved to the <code>&#x3C;ng-template></code> element where it became a property binding,<code>[ngIf]</code>.</li>\n<li>The rest of the <code>&#x3C;div></code>, including its class attribute, moved inside the <code>&#x3C;ng-template></code> element.</li>\n</ul>\n<p>None of these forms are actually rendered.\nOnly the finished product ends up in the DOM.</p>\n<figure>\n  <img src=\"generated/images/guide/structural-directives/hero-div-in-dom.png\" alt=\"hero div in DOM\" width=\"320\" height=\"69\">\n</figure>\n<p>Angular consumed the <code>&#x3C;ng-template></code> content during its actual rendering and\nreplaced the <code>&#x3C;ng-template></code> with a diagnostic comment.</p>\n<p>The <a href=\"guide/structural-directives#ngFor\"><code><a href=\"api/common/NgFor\">NgFor</a></code></a> and <a href=\"guide/structural-directives#ngSwitch\"><code>NgSwitch...</code></a> directives follow the same pattern.</p>\n<a id=\"ngFor\"></a>\n<h2 id=\"inside-ngfor\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#inside-ngfor\"><i class=\"material-icons\">link</i></a>Inside <em>*ngFor</em></h2>\n<p>Angular transforms the <code>*ngFor</code> in similar fashion from asterisk (*) syntax through\ntemplate <em>attribute</em> to <code>&#x3C;ng-template></code> <em>element</em>.</p>\n<p>Here's a full-featured application of <code><a href=\"api/common/NgFor\">NgFor</a></code>, written all three ways:</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (inside-ngfor)\" region=\"inside-ngfor\">\n&#x3C;div *ngFor=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\">\n  ({{i}}) {{hero.name}}\n&#x3C;/div>\n\n&#x3C;div template=\"ngFor let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\">\n  ({{i}}) {{hero.name}}\n&#x3C;/div>\n\n&#x3C;ng-template ngFor let-hero [ngForOf]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\">\n  &#x3C;div [class.odd]=\"odd\">({{i}}) {{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n</code-example>\n<p>This is manifestly more complicated than <code>ngIf</code> and rightly so.\nThe <code><a href=\"api/common/NgFor\">NgFor</a></code> directive has more features, both required and optional, than the <code><a href=\"api/common/NgIf\">NgIf</a></code> shown in this guide.\nAt minimum <code><a href=\"api/common/NgFor\">NgFor</a></code> needs a looping variable (<code>let hero</code>) and a list (<code>heroes</code>).</p>\n<p>You enable these features in the string assigned to <code>ngFor</code>, which you write in Angular's <a href=\"guide/structural-directives#microsyntax\">microsyntax</a>.</p>\n<div class=\"alert is-helpful\">\n<p>Everything <em>outside</em> the <code>ngFor</code> string stays with the host element\n(the <code>&#x3C;div></code>) as it moves inside the <code>&#x3C;ng-template></code>.\nIn this example, the <code>[ngClass]=\"odd\"</code> stays on the <code>&#x3C;div></code>.</p>\n</div>\n<a id=\"microsyntax\"></a>\n<h3 id=\"microsyntax\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#microsyntax\"><i class=\"material-icons\">link</i></a>Microsyntax</h3>\n<p>The Angular microsyntax lets you configure a directive in a compact, friendly string.\nThe microsyntax parser translates that string into attributes on the <code>&#x3C;ng-template></code>:</p>\n<ul>\n<li>\n<p>The <code>let</code> keyword declares a <a href=\"guide/structural-directives#template-input-variable\"><em>template input variable</em></a>\nthat you reference within the template. The input variables in this example are <code>hero</code>, <code>i</code>, and <code>odd</code>.\nThe parser translates <code>let hero</code>, <code>let i</code>, and <code>let odd</code> into variables named,\n<code>let-hero</code>, <code>let-i</code>, and <code>let-odd</code>.</p>\n</li>\n<li>\n<p>The microsyntax parser takes <code>of</code> and <code>trackby</code>, title-cases them (<code>of</code> -> <code>Of</code>, <code>trackBy</code> -> <code>TrackBy</code>),\nand prefixes them with the directive's attribute name (<code>ngFor</code>), yielding the names <code>ngForOf</code> and <code>ngForTrackBy</code>.\nThose are the names of two <code><a href=\"api/common/NgFor\">NgFor</a></code> <em>input properties</em> .\nThat's how the directive learns that the list is <code>heroes</code> and the track-by function is <code>trackById</code>.</p>\n</li>\n<li>\n<p>As the <code><a href=\"api/common/NgFor\">NgFor</a></code> directive loops through the list, it sets and resets properties of its own <em>context</em> object.\nThese properties include <code>index</code> and <code>odd</code> and a special property named <code>$implicit</code>.</p>\n</li>\n<li>\n<p>The <code>let-i</code> and <code>let-odd</code> variables were defined as <code>let i=index</code> and <code>let odd=odd</code>.\nAngular sets them to the current value of the context's <code>index</code> and <code>odd</code> properties.</p>\n</li>\n<li>\n<p>The context property for <code>let-hero</code> wasn't specified.\nIt's intended source is implicit.\nAngular sets <code>let-hero</code> to the value of the context's <code>$implicit</code> property\nwhich <code><a href=\"api/common/NgFor\">NgFor</a></code> has initialized with the hero for the current iteration.</p>\n</li>\n<li>\n<p>The <a href=\"api/common/NgFor\" title=\"API: NgFor\">API guide</a>\ndescribes additional <code><a href=\"api/common/NgFor\">NgFor</a></code> directive properties and context properties.</p>\n</li>\n</ul>\n<p>These microsyntax mechanisms are available to you when you write your own structural directives.\nStudying the\n<a href=\"https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_if.ts\" title=\"Source: NgIf\">source code for <code><a href=\"api/common/NgIf\">NgIf</a></code></a>\nand <a href=\"https://github.com/angular/angular/blob/master/packages/common/src/directives/ng_for_of.ts\" title=\"Source: NgFor\"><code><a href=\"api/common/NgFor\">NgFor</a></code></a>\nis a great way to learn more.</p>\n<a id=\"template-input-variable\"></a>\n<a id=\"template-input-variables\"></a>\n<h3 id=\"template-input-variable\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#template-input-variable\"><i class=\"material-icons\">link</i></a>Template input variable</h3>\n<p>A <em>template input variable</em> is a variable whose value you can reference <em>within</em> a single instance of the template.\nThere are several such variables in this example: <code>hero</code>, <code>i</code>, and <code>odd</code>.\nAll are preceded by the keyword <code>let</code>.</p>\n<p>A <em>template input variable</em> is <strong><em>not</em></strong> the same as a\n<a href=\"guide/template-syntax#ref-vars\">template <em>reference</em> variable</a>,\nneither <em>semantically</em> nor <em>syntactically</em>.</p>\n<p>You declare a template <em>input</em> variable using the <code>let</code> keyword (<code>let hero</code>).\nThe variable's scope is limited to a <em>single instance</em> of the repeated template.\nYou can use the same variable name again in the definition of other structural directives.</p>\n<p>You declare a template <em>reference</em> variable by prefixing the variable name with <code>#</code> (<code>#var</code>).\nA <em>reference</em> variable refers to its attached element, component or directive.\nIt can be accessed <em>anywhere</em> in the <em>entire template</em>.</p>\n<p>Template <em>input</em> and <em>reference</em> variable names have their own namespaces. The <code>hero</code> in <code>let hero</code> is never the same\nvariable as the <code>hero</code> declared as <code>#hero</code>.</p>\n<a id=\"one-per-element\"></a>\n<h3 id=\"one-structural-directive-per-host-element\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#one-structural-directive-per-host-element\"><i class=\"material-icons\">link</i></a>One structural directive per host element</h3>\n<p>Someday you'll want to repeat a block of HTML but only when a particular condition is true.\nYou'll <em>try</em> to put both an <code>*ngFor</code> and an <code>*ngIf</code> on the same host element.\nAngular won't let you. You may apply only one <em>structural</em> directive to an element.</p>\n<p>The reason is simplicity. Structural directives can do complex things with the host element and its descendents.\nWhen two directives lay claim to the same host element, which one takes precedence?\nWhich should go first, the <code><a href=\"api/common/NgIf\">NgIf</a></code> or the <code><a href=\"api/common/NgFor\">NgFor</a></code>? Can the <code><a href=\"api/common/NgIf\">NgIf</a></code> cancel the effect of the <code><a href=\"api/common/NgFor\">NgFor</a></code>?\nIf so (and it seems like it should be so), how should Angular generalize the ability to cancel for other structural directives?</p>\n<p>There are no easy answers to these questions. Prohibiting multiple structural directives makes them moot.\nThere's an easy solution for this use case: put the <code>*ngIf</code> on a container element that wraps the <code>*ngFor</code> element.\nOne or both elements can be an <a href=\"guide/structural-directives#ngcontainer\"><code>ng-container</code></a> so you don't have to introduce extra levels of HTML.</p>\n<a id=\"ngSwitch\"></a>\n<h2 id=\"inside-ngswitch-directives\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#inside-ngswitch-directives\"><i class=\"material-icons\">link</i></a>Inside <em>NgSwitch</em> directives</h2>\n<p>The Angular <em>NgSwitch</em> is actually a set of cooperating directives: <code><a href=\"api/common/NgSwitch\">NgSwitch</a></code>, <code><a href=\"api/common/NgSwitchCase\">NgSwitchCase</a></code>, and <code><a href=\"api/common/NgSwitchDefault\">NgSwitchDefault</a></code>.</p>\n<p>Here's an example.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngswitch)\" region=\"ngswitch\">\n&#x3C;div [ngSwitch]=\"hero?.emotion\">\n  &#x3C;happy-hero    *ngSwitchCase=\"'happy'\"    [hero]=\"hero\">&#x3C;/happy-hero>\n  &#x3C;sad-hero      *ngSwitchCase=\"'sad'\"      [hero]=\"hero\">&#x3C;/sad-hero>\n  &#x3C;confused-hero *ngSwitchCase=\"'confused'\" [hero]=\"hero\">&#x3C;/confused-hero>\n  &#x3C;unknown-hero  *ngSwitchDefault           [hero]=\"hero\">&#x3C;/unknown-hero>\n&#x3C;/div>\n\n</code-example>\n<p>The switch value assigned to <code><a href=\"api/common/NgSwitch\">NgSwitch</a></code> (<code>hero.emotion</code>) determines which\n(if any) of the switch cases are displayed.</p>\n<p><code><a href=\"api/common/NgSwitch\">NgSwitch</a></code> itself is not a structural directive.\nIt's an <em>attribute</em> directive that controls the behavior of the other two switch directives.\nThat's why you write <code>[ngSwitch]</code>, never <code>*ngSwitch</code>.</p>\n<p><code><a href=\"api/common/NgSwitchCase\">NgSwitchCase</a></code> and <code><a href=\"api/common/NgSwitchDefault\">NgSwitchDefault</a></code> <em>are</em> structural directives.\nYou attach them to elements using the asterisk (*) prefix notation.\nAn <code><a href=\"api/common/NgSwitchCase\">NgSwitchCase</a></code> displays its host element when its value matches the switch value.\nThe <code><a href=\"api/common/NgSwitchDefault\">NgSwitchDefault</a></code> displays its host element when no sibling <code><a href=\"api/common/NgSwitchCase\">NgSwitchCase</a></code> matches the switch value.</p>\n<div class=\"l-sub-section\">\n<p>The element to which you apply a directive is its <em>host</em> element.\nThe <code>&#x3C;happy-hero></code> is the host element for the happy <code>*ngSwitchCase</code>.\nThe <code>&#x3C;unknown-hero></code> is the host element for the <code>*ngSwitchDefault</code>.</p>\n</div>\n<p>As with other structural directives, the <code><a href=\"api/common/NgSwitchCase\">NgSwitchCase</a></code> and <code><a href=\"api/common/NgSwitchDefault\">NgSwitchDefault</a></code>\ncan be desugared into the template <em>attribute</em> form.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngswitch-template-attr)\" region=\"ngswitch-template-attr\">\n&#x3C;div [ngSwitch]=\"hero?.emotion\">\n  &#x3C;happy-hero    template=\"ngSwitchCase 'happy'\"    [hero]=\"hero\">&#x3C;/happy-hero>\n  &#x3C;sad-hero      template=\"ngSwitchCase 'sad'\"      [hero]=\"hero\">&#x3C;/sad-hero>\n  &#x3C;confused-hero template=\"ngSwitchCase 'confused'\" [hero]=\"hero\">&#x3C;/confused-hero>\n  &#x3C;unknown-hero  template=\"ngSwitchDefault\"         [hero]=\"hero\">&#x3C;/unknown-hero>\n&#x3C;/div>\n\n</code-example>\n<p>That, in turn, can be desugared into the <code>&#x3C;ng-template></code> element form.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngswitch-template)\" region=\"ngswitch-template\">\n&#x3C;div [ngSwitch]=\"hero?.emotion\">\n  &#x3C;ng-template [ngSwitchCase]=\"'happy'\">\n    &#x3C;happy-hero [hero]=\"hero\">&#x3C;/happy-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [ngSwitchCase]=\"'sad'\">\n    &#x3C;sad-hero [hero]=\"hero\">&#x3C;/sad-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [ngSwitchCase]=\"'confused'\">\n    &#x3C;confused-hero [hero]=\"hero\">&#x3C;/confused-hero>\n  &#x3C;/ng-template >\n  &#x3C;ng-template ngSwitchDefault>\n    &#x3C;unknown-hero [hero]=\"hero\">&#x3C;/unknown-hero>\n  &#x3C;/ng-template>\n&#x3C;/div>\n\n</code-example>\n<a id=\"prefer-asterisk\"></a>\n<h2 id=\"prefer-the-asterisk--syntax\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#prefer-the-asterisk--syntax\"><i class=\"material-icons\">link</i></a>Prefer the asterisk (*) syntax.</h2>\n<p>The asterisk (*) syntax is more clear than the other desugared forms.\nUse <a href=\"guide/structural-directives#ng-container\">&#x3C;ng-container></a> when there's no single element\nto host the directive.</p>\n<p>While there's rarely a good reason to apply a structural directive in template <em>attribute</em> or <em>element</em> form,\nit's still important to know that Angular creates a <code>&#x3C;ng-template></code> and to understand how it works.\nYou'll refer to the <code>&#x3C;ng-template></code> when you <a href=\"guide/structural-directives#unless\">write your own structural directive</a>.</p>\n<a id=\"template\"></a>\n<h2 id=\"the-ng-template\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#the-ng-template\"><i class=\"material-icons\">link</i></a>The <em>&#x3C;ng-template></em></h2>\n<p>The &#x3C;ng-template> is an Angular element for rendering HTML.\nIt is never displayed directly.\nIn fact, before rendering the view, Angular <em>replaces</em> the <code>&#x3C;ng-template></code> and its contents with a comment.</p>\n<p>If there is no structural directive and you merely wrap some elements in a <code>&#x3C;ng-template></code>,\nthose elements disappear.\nThat's the fate of the middle \"Hip!\" in the phrase \"Hip! Hip! Hooray!\".</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (template-tag)\" region=\"template-tag\">\n&#x3C;p>Hip!&#x3C;/p>\n&#x3C;ng-template>\n  &#x3C;p>Hip!&#x3C;/p>\n&#x3C;/ng-template>\n&#x3C;p>Hooray!&#x3C;/p>\n\n</code-example>\n<p>Angular erases the middle \"Hip!\", leaving the cheer a bit less enthusiastic.</p>\n<figure>\n  <img src=\"generated/images/guide/structural-directives/template-rendering.png\" alt=\"template tag rendering\" width=\"555\" height=\"94\">\n</figure>\n<p>A structural directive puts a <code>&#x3C;ng-template></code> to work\nas you'll see when you <a href=\"guide/structural-directives#unless\">write your own structural directive</a>.</p>\n<a id=\"ngcontainer\"></a>\n<a id=\"ng-container\"></a>\n<h2 id=\"group-sibling-elements-with-ng-container\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#group-sibling-elements-with-ng-container\"><i class=\"material-icons\">link</i></a>Group sibling elements with &#x3C;ng-container></h2>\n<p>There's often a <em>root</em> element that can and should host the structural directive.\nThe list element (<code>&#x3C;li></code>) is a typical host element of an <code><a href=\"api/common/NgFor\">NgFor</a></code> repeater.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngfor-li)\" region=\"ngfor-li\">\n&#x3C;li *ngFor=\"let hero of heroes\">{{hero.name}}&#x3C;/li>\n\n</code-example>\n<p>When there isn't a host element, you can usually wrap the content in a native HTML container element,\nsuch as a <code>&#x3C;div></code>, and attach the directive to that wrapper.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngif)\" region=\"ngif\">\n&#x3C;div *ngIf=\"hero\" >{{hero.name}}&#x3C;/div>\n\n</code-example>\n<p>Introducing another container element—typically a <code>&#x3C;span></code> or <code>&#x3C;div></code>—to\ngroup the elements under a single <em>root</em> is usually harmless.\n<em>Usually</em> ... but not <em>always</em>.</p>\n<p>The grouping element may break the template appearance because CSS styles\nneither expect nor accommodate the new layout.\nFor example, suppose you have the following paragraph layout.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngif-span)\" region=\"ngif-span\">\n&#x3C;p>\n  I turned the corner\n  &#x3C;span *ngIf=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/span>\n  and continued on my way.\n&#x3C;/p>\n\n</code-example>\n<p>You also have a CSS style rule that happens to apply to a <code>&#x3C;span></code> within a <code>&#x3C;p></code>aragraph.</p>\n<code-example path=\"structural-directives/src/app/app.component.css\" linenums=\"false\" title=\"src/app/app.component.css (p-span)\" region=\"p-span\">\np span { color: red; font-size: 70%; }\n\n</code-example>\n<p>The constructed paragraph renders strangely.</p>\n<figure>\n  <img src=\"generated/images/guide/structural-directives/bad-paragraph.png\" alt=\"spanned paragraph with bad style\" width=\"452\" height=\"15\">\n</figure>\n<p>The <code>p span</code> style, intended for use elsewhere, was inadvertently applied here.</p>\n<p>Another problem: some HTML elements require all immediate children to be of a specific type.\nFor example, the <code>&#x3C;select></code> element requires <code>&#x3C;option></code> children.\nYou can't wrap the <em>options</em> in a conditional <code>&#x3C;div></code> or a <code>&#x3C;span></code>.</p>\n<p>When you try this,</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (select-span)\" region=\"select-span\">\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(ngModel)]=\"hero\">\n  &#x3C;span *ngFor=\"let h of heroes\">\n    &#x3C;span *ngIf=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/span>\n  &#x3C;/span>\n&#x3C;/select>\n\n</code-example>\n<p>the drop down is empty.</p>\n<figure>\n  <img src=\"generated/images/guide/structural-directives/bad-select.png\" alt=\"spanned options don&#x27;t work\" width=\"290\" height=\"36\">\n</figure>\n<p>The browser won't display an <code>&#x3C;option></code> within a <code>&#x3C;span></code>.</p>\n<h3 id=\"ng-container-to-the-rescue\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#ng-container-to-the-rescue\"><i class=\"material-icons\">link</i></a>&#x3C;ng-container> to the rescue</h3>\n<p>The Angular <code>&#x3C;ng-container></code> is a grouping element that doesn't interfere with styles or layout\nbecause Angular <em>doesn't put it in the DOM</em>.</p>\n<p>Here's the conditional paragraph again, this time using <code>&#x3C;ng-container></code>.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (ngif-ngcontainer)\" region=\"ngif-ngcontainer\">\n&#x3C;p>\n  I turned the corner\n  &#x3C;ng-container *ngIf=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/ng-container>\n  and continued on my way.\n&#x3C;/p>\n\n</code-example>\n<p>It renders properly.</p>\n<figure>\n  <img src=\"generated/images/guide/structural-directives/good-paragraph.png\" alt=\"ngcontainer paragraph with proper style\" width=\"509\" height=\"15\">\n</figure>\n<p>Now conditionally exclude a <em>select</em> <code>&#x3C;option></code> with <code>&#x3C;ng-container></code>.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (select-ngcontainer)\" region=\"select-ngcontainer\">\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(ngModel)]=\"hero\">\n  &#x3C;ng-container *ngFor=\"let h of heroes\">\n    &#x3C;ng-container *ngIf=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/ng-container>\n  &#x3C;/ng-container>\n&#x3C;/select>\n\n</code-example>\n<p>The drop down works properly.</p>\n<figure>\n  <img src=\"generated/images/guide/structural-directives/select-ngcontainer-anim.gif\" alt=\"ngcontainer options work properly\" width=\"312\" height=\"100\">\n</figure>\n<p>The <code>&#x3C;ng-container></code> is a syntax element recognized by the Angular parser.\nIt's not a directive, component, class, or interface.\nIt's more like the curly braces in a JavaScript <code>if</code>-block:</p>\n<code-example language=\"javascript\">\n  if (someCondition) {\n    statement1;\n    statement2;\n    statement3;\n  }\n\n</code-example>\n<p>Without those braces, JavaScript would only execute the first statement\nwhen you intend to conditionally execute all of them as a single block.\nThe <code>&#x3C;ng-container></code> satisfies a similar need in Angular templates.</p>\n<a id=\"unless\"></a>\n<h2 id=\"write-a-structural-directive\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#write-a-structural-directive\"><i class=\"material-icons\">link</i></a>Write a structural directive</h2>\n<p>In this section, you write an <code>UnlessDirective</code> structural directive\nthat does the opposite of <code><a href=\"api/common/NgIf\">NgIf</a></code>.\n<code><a href=\"api/common/NgIf\">NgIf</a></code> displays the template content when the condition is <code>true</code>.\n<code>UnlessDirective</code> displays the content when the condition is <strong><em>false</em></strong>.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (myUnless-1)\" region=\"myUnless-1\">\n&#x3C;p *myUnless=\"condition\">Show this sentence unless the condition is true.&#x3C;/p>\n\n</code-example>\n<p>Creating a directive is similar to creating a component.</p>\n<ul>\n<li>\n<p>Import the <code><a href=\"api/core/Directive\">Directive</a></code> decorator (instead of the <code><a href=\"api/core/Component\">Component</a></code> decorator).</p>\n</li>\n<li>\n<p>Import the <code><a href=\"api/core/Input\">Input</a></code>, <code><a href=\"api/core/TemplateRef\">TemplateRef</a></code>, and <code><a href=\"api/core/ViewContainerRef\">ViewContainerRef</a></code> symbols; you'll need them for <em>any</em> structural directive.</p>\n</li>\n<li>\n<p>Apply the decorator to the directive class.</p>\n</li>\n<li>\n<p>Set the CSS <em>attribute selector</em> that identifies the directive when applied to an element in a template.</p>\n</li>\n</ul>\n<p>Here's how you might begin:</p>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" linenums=\"false\" title=\"src/app/unless.directive.ts (skeleton)\" region=\"skeleton\">\nimport { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';\n\n@Directive({ selector: '[myUnless]'})\nexport class UnlessDirective {\n}\n\n\n</code-example>\n<p>The directive's <em>selector</em> is typically the directive's <strong>attribute name</strong> in square brackets, <code>[myUnless]</code>.\nThe brackets define a CSS\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors\" title=\"MDN: Attribute selectors\">attribute selector</a>.</p>\n<p>The directive <em>attribute name</em> should be spelled in <em>lowerCamelCase</em> and begin with a prefix.\nDon't use <code>ng</code>. That prefix belongs to Angular.\nPick something short that fits you or your company.\nIn this example, the prefix is <code>my</code>.</p>\n<p>The directive <em>class</em> name ends in <code><a href=\"api/core/Directive\">Directive</a></code> per the <a href=\"guide/styleguide#02-03\" title=\"Angular Style Guide\">style guide</a>.\nAngular's own directives do not.</p>\n<h3 id=\"templateref-and-viewcontainerref\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#templateref-and-viewcontainerref\"><i class=\"material-icons\">link</i></a><em>TemplateRef</em> and <em>ViewContainerRef</em></h3>\n<p>A simple structural directive like this one creates an\n<a href=\"api/core/EmbeddedViewRef\" title=\"API: EmbeddedViewRef\"><em>embedded view</em></a>\nfrom the Angular-generated <code>&#x3C;ng-template></code> and inserts that view in a\n<a href=\"api/core/ViewContainerRef\" title=\"API: ViewContainerRef\"><em>view container</em></a>\nadjacent to the directive's original <code>&#x3C;p></code> host element.</p>\n<p>You'll acquire the <code>&#x3C;ng-template></code> contents with a\n<a href=\"api/core/TemplateRef\" title=\"API: TemplateRef\"><code><a href=\"api/core/TemplateRef\">TemplateRef</a></code></a>\nand access the <em>view container</em> through a\n<a href=\"api/core/ViewContainerRef\" title=\"API: ViewContainerRef\"><code><a href=\"api/core/ViewContainerRef\">ViewContainerRef</a></code></a>.</p>\n<p>You inject both in the directive constructor as private variables of the class.</p>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" linenums=\"false\" title=\"src/app/unless.directive.ts (ctor)\" region=\"ctor\">\nconstructor(\n  private templateRef: TemplateRef&#x3C;any>,\n  private viewContainer: ViewContainerRef) { }\n\n</code-example>\n<h3 id=\"the-myunless-property\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#the-myunless-property\"><i class=\"material-icons\">link</i></a>The <em>myUnless</em> property</h3>\n<p>The directive consumer expects to bind a true/false condition to <code>[myUnless]</code>.\nThat means the directive needs a <code>myUnless</code> property, decorated with <code>@Input</code></p>\n<div class=\"l-sub-section\">\n<p>Read about <code>@Input</code> in the <a href=\"guide/template-syntax#inputs-outputs\"><em>Template Syntax</em></a> guide.</p>\n</div>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" linenums=\"false\" title=\"src/app/unless.directive.ts (set)\" region=\"set\">\n@Input() set myUnless(condition: boolean) {\n  if (!condition &#x26;&#x26; !this.hasView) {\n    this.viewContainer.createEmbeddedView(this.templateRef);\n    this.hasView = true;\n  } else if (condition &#x26;&#x26; this.hasView) {\n    this.viewContainer.clear();\n    this.hasView = false;\n  }\n}\n\n</code-example>\n<p>Angular sets the  <code>myUnless</code> property whenever the value of the condition changes.\nBecause the <code>myUnless</code> property does work, it needs a setter.</p>\n<ul>\n<li>\n<p>If the condition is falsy and the view hasn't been created previously,\ntell the <em>view container</em> to create the <em>embedded view</em> from the template.</p>\n</li>\n<li>\n<p>If the condition is truthy and the view is currently displayed,\nclear the container which also destroys the view.</p>\n</li>\n</ul>\n<p>Nobody reads the <code>myUnless</code> property so it doesn't need a getter.</p>\n<p>The completed directive code looks like this:</p>\n<code-example path=\"structural-directives/src/app/unless.directive.ts\" linenums=\"false\" title=\"src/app/unless.directive.ts (excerpt)\" region=\"no-docs\">\nimport { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';\n\n/**\n * Add the template content to the DOM unless the condition is true.\n */\n@Directive({ selector: '[myUnless]'})\nexport class UnlessDirective {\n  private hasView = false;\n\n  constructor(\n    private templateRef: TemplateRef&#x3C;any>,\n    private viewContainer: ViewContainerRef) { }\n\n  @Input() set myUnless(condition: boolean) {\n    if (!condition &#x26;&#x26; !this.hasView) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n      this.hasView = true;\n    } else if (condition &#x26;&#x26; this.hasView) {\n      this.viewContainer.clear();\n      this.hasView = false;\n    }\n  }\n}\n\n\n</code-example>\n<p>Add this directive to the <code>declarations</code> array of the AppModule.</p>\n<p>Then create some HTML to try it.</p>\n<code-example path=\"structural-directives/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (myUnless)\" region=\"myUnless\">\n&#x3C;p *myUnless=\"condition\" class=\"unless a\">\n  (A) This paragraph is displayed because the condition is false.\n&#x3C;/p>\n\n&#x3C;p *myUnless=\"!condition\" class=\"unless b\">\n  (B) Although the condition is true,\n  this paragraph is displayed because myUnless is set to false.\n&#x3C;/p>\n\n</code-example>\n<p>When the <code>condition</code> is falsy, the top (A) paragraph appears and the bottom (B) paragraph disappears.\nWhen the <code>condition</code> is truthy, the top (A) paragraph is removed and the bottom (B) paragraph appears.</p>\n<figure>\n  <img src=\"generated/images/guide/structural-directives/unless-anim.gif\" alt=\"UnlessDirective in action\" width=\"524\" height=\"100\">\n</figure>\n<a id=\"summary\"></a>\n<h2 id=\"summary\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/structural-directives#summary\"><i class=\"material-icons\">link</i></a>Summary</h2>\n<p>You can both try and download the source code for this guide in the <live-example></live-example>.</p>\n<p>Here is the source from the <code>src/app/</code> folder.</p>\n<code-tabs>\n\n  <code-pane title=\"app.component.ts\" path=\"structural-directives/src/app/app.component.ts\">\nimport { Component } from '@angular/core';\n\nimport { Hero, heroes } from './hero';\n\n@Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html',\n  styleUrls: [ './app.component.css' ]\n})\nexport class AppComponent {\n  heroes = heroes;\n  hero = this.heroes[0];\n\n  condition = false;\n  logs: string[] = [];\n  showSad = true;\n  status = 'ready';\n\n  trackById(index: number, hero: Hero): number { return hero.id; }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"app.component.html\" path=\"structural-directives/src/app/app.component.html\">\n&#x3C;h1>Structural Directives&#x3C;/h1>\n\n&#x3C;p>Conditional display of hero&#x3C;/p>\n\n&#x3C;blockquote>\n&#x3C;div *ngIf=\"hero\" >{{hero.name}}&#x3C;/div>\n&#x3C;/blockquote>\n\n&#x3C;p>List of heroes&#x3C;/p>\n\n&#x3C;ul>\n  &#x3C;li *ngFor=\"let hero of heroes\">{{hero.name}}&#x3C;/li>\n&#x3C;/ul>\n\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"ngIf\">NgIf&#x3C;/h2>\n\n&#x3C;p *ngIf=\"true\">\n  Expression is true and ngIf is true.\n  This paragraph is in the DOM.\n&#x3C;/p>\n&#x3C;p *ngIf=\"false\">\n  Expression is false and ngIf is false.\n  This paragraph is not in the DOM.\n&#x3C;/p>\n\n&#x3C;p [style.display]=\"'block'\">\n  Expression sets display to \"block\".\n  This paragraph is visible.\n&#x3C;/p>\n&#x3C;p [style.display]=\"'none'\">\n  Expression sets display to \"none\".\n  This paragraph is hidden but still in the DOM.\n&#x3C;/p>\n\n&#x3C;h4>NgIf with template&#x3C;/h4>\n&#x3C;p>&#x26;lt;ng-template&#x26;gt; element&#x3C;/p>\n&#x3C;ng-template [ngIf]=\"hero\">\n  &#x3C;div>{{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n&#x3C;p>template attribute&#x3C;/p>\n&#x3C;div template=\"ngIf hero\">{{hero.name}}&#x3C;/div>\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"ng-container\">&#x26;lt;ng-container&#x26;gt;&#x3C;/h2>\n\n&#x3C;h4>*ngIf with a &#x26;lt;ng-container&#x26;gt;&#x3C;/h4>\n\n&#x3C;button (click)=\"hero = hero ? null : heroes[0]\">Toggle hero&#x3C;/button>\n\n&#x3C;p>\n  I turned the corner\n  &#x3C;ng-container *ngIf=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/ng-container>\n  and continued on my way.\n&#x3C;/p>\n&#x3C;p>\n  I turned the corner\n  &#x3C;span *ngIf=\"hero\">\n    and saw {{hero.name}}. I waved\n  &#x3C;/span>\n  and continued on my way.\n&#x3C;/p>\n\n&#x3C;p>&#x3C;i>&#x26;lt;select&#x26;gt; with &#x26;lt;span&#x26;gt;&#x3C;/i>&#x3C;/p>\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(ngModel)]=\"hero\">\n  &#x3C;span *ngFor=\"let h of heroes\">\n    &#x3C;span *ngIf=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/span>\n  &#x3C;/span>\n&#x3C;/select>\n\n&#x3C;p>&#x3C;i>&#x26;lt;select&#x26;gt; with &#x26;lt;ng-container&#x26;gt;&#x3C;/i>&#x3C;/p>\n&#x3C;div>\n  Pick your favorite hero\n  (&#x3C;label>&#x3C;input type=\"checkbox\" checked (change)=\"showSad = !showSad\">show sad&#x3C;/label>)\n&#x3C;/div>\n&#x3C;select [(ngModel)]=\"hero\">\n  &#x3C;ng-container *ngFor=\"let h of heroes\">\n    &#x3C;ng-container *ngIf=\"showSad || h.emotion !== 'sad'\">\n      &#x3C;option [ngValue]=\"h\">{{h.name}} ({{h.emotion}})&#x3C;/option>\n    &#x3C;/ng-container>\n  &#x3C;/ng-container>\n&#x3C;/select>\n&#x3C;br>&#x3C;br>\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"ngFor\">NgFor&#x3C;/h2>\n\n&#x3C;div class=\"box\">\n\n&#x3C;p class=\"code\">&#x26;lt;div *ngFor=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\"&#x26;gt;&#x3C;/p>\n&#x3C;div *ngFor=\"let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\">\n  ({{i}}) {{hero.name}}\n&#x3C;/div>\n\n&#x3C;p class=\"code\">&#x26;lt;div template=\"ngFor let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\"&#x26;gt;&#x3C;/p>\n&#x3C;div template=\"ngFor let hero of heroes; let i=index; let odd=odd; trackBy: trackById\" [class.odd]=\"odd\">\n  ({{i}}) {{hero.name}}\n&#x3C;/div>\n\n&#x3C;p class=\"code\">&#x26;lt;template ngFor let-hero [ngForOf]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\"&#x26;gt;&#x3C;/p>\n&#x3C;ng-template ngFor let-hero [ngForOf]=\"heroes\" let-i=\"index\" let-odd=\"odd\" [ngForTrackBy]=\"trackById\">\n  &#x3C;div [class.odd]=\"odd\">({{i}}) {{hero.name}}&#x3C;/div>\n&#x3C;/ng-template>\n\n&#x3C;/div>\n&#x3C;hr>\n\n&#x3C;h2 id=\"ngSwitch\">NgSwitch&#x3C;/h2>\n\n&#x3C;div>Pick your favorite hero&#x3C;/div>\n&#x3C;p>\n  &#x3C;label *ngFor=\"let h of heroes\">\n    &#x3C;input type=\"radio\" name=\"heroes\" [(ngModel)]=\"hero\" [value]=\"h\">{{h.name}}\n  &#x3C;/label>\n  &#x3C;label>&#x3C;input type=\"radio\" name=\"heroes\" (click)=\"hero = null\">None of the above&#x3C;/label>\n&#x3C;/p>\n\n&#x3C;h4>NgSwitch&#x3C;/h4>\n\n&#x3C;div [ngSwitch]=\"hero?.emotion\">\n  &#x3C;happy-hero    *ngSwitchCase=\"'happy'\"    [hero]=\"hero\">&#x3C;/happy-hero>\n  &#x3C;sad-hero      *ngSwitchCase=\"'sad'\"      [hero]=\"hero\">&#x3C;/sad-hero>\n  &#x3C;confused-hero *ngSwitchCase=\"'confused'\" [hero]=\"hero\">&#x3C;/confused-hero>\n  &#x3C;unknown-hero  *ngSwitchDefault           [hero]=\"hero\">&#x3C;/unknown-hero>\n&#x3C;/div>\n\n&#x3C;h4>NgSwitch with &#x3C;i>template&#x3C;/i> attribute&#x3C;/h4>\n&#x3C;div [ngSwitch]=\"hero?.emotion\">\n  &#x3C;happy-hero    template=\"ngSwitchCase 'happy'\"    [hero]=\"hero\">&#x3C;/happy-hero>\n  &#x3C;sad-hero      template=\"ngSwitchCase 'sad'\"      [hero]=\"hero\">&#x3C;/sad-hero>\n  &#x3C;confused-hero template=\"ngSwitchCase 'confused'\" [hero]=\"hero\">&#x3C;/confused-hero>\n  &#x3C;unknown-hero  template=\"ngSwitchDefault\"         [hero]=\"hero\">&#x3C;/unknown-hero>\n&#x3C;/div>\n\n&#x3C;h4>NgSwitch with &#x26;lt;ng-template&#x26;gt;&#x3C;/h4>\n&#x3C;div [ngSwitch]=\"hero?.emotion\">\n  &#x3C;ng-template [ngSwitchCase]=\"'happy'\">\n    &#x3C;happy-hero [hero]=\"hero\">&#x3C;/happy-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [ngSwitchCase]=\"'sad'\">\n    &#x3C;sad-hero [hero]=\"hero\">&#x3C;/sad-hero>\n  &#x3C;/ng-template>\n  &#x3C;ng-template [ngSwitchCase]=\"'confused'\">\n    &#x3C;confused-hero [hero]=\"hero\">&#x3C;/confused-hero>\n  &#x3C;/ng-template >\n  &#x3C;ng-template ngSwitchDefault>\n    &#x3C;unknown-hero [hero]=\"hero\">&#x3C;/unknown-hero>\n  &#x3C;/ng-template>\n&#x3C;/div>\n\n&#x3C;hr>\n\n&#x3C;h2>&#x26;lt;template&#x26;gt;&#x3C;/h2>\n&#x3C;p>Hip!&#x3C;/p>\n&#x3C;ng-template>\n  &#x3C;p>Hip!&#x3C;/p>\n&#x3C;/ng-template>\n&#x3C;p>Hooray!&#x3C;/p>\n\n&#x3C;hr>\n\n&#x3C;h2 id=\"myUnless\">UnlessDirective&#x3C;/h2>\n&#x3C;p>\n  The condition is currently\n  &#x3C;span [ngClass]=\"{ 'a': !condition, 'b': condition, 'unless': true }\">{{condition}}&#x3C;/span>.\n  &#x3C;button\n    (click)=\"condition = !condition\"\n    [ngClass] = \"{ 'a': condition, 'b': !condition }\" >\n    Toggle condition to {{condition ? 'false' : 'true'}}\n  &#x3C;/button>\n&#x3C;/p>\n&#x3C;p *myUnless=\"condition\" class=\"unless a\">\n  (A) This paragraph is displayed because the condition is false.\n&#x3C;/p>\n\n&#x3C;p *myUnless=\"!condition\" class=\"unless b\">\n  (B) Although the condition is true,\n  this paragraph is displayed because myUnless is set to false.\n&#x3C;/p>\n\n\n&#x3C;h4>UnlessDirective with template&#x3C;/h4>\n\n&#x3C;p *myUnless=\"condition\">Show this sentence unless the condition is true.&#x3C;/p>\n\n&#x3C;p template=\"myUnless condition\" class=\"code unless\">\n  (A) &#x26;lt;p template=\"myUnless condition\" class=\"code unless\"&#x26;gt;\n&#x3C;/p>\n\n&#x3C;ng-template [myUnless]=\"condition\">\n  &#x3C;p class=\"code unless\">\n    (A) &#x26;lt;template [myUnless]=\"condition\"&#x26;gt;\n  &#x3C;/p>\n&#x3C;/ng-template>\n\n\n\n</code-pane>\n\n  <code-pane title=\"app.component.css\" path=\"structural-directives/src/app/app.component.css\">\nbutton {\n  min-width: 100px;\n  font-size: 100%;\n}\n\n.box {\n  border: 1px solid gray;\n  max-width: 600px;\n  padding: 4px;\n}\n.choices {\n  font-style: italic;\n}\n\ncode, .code {\n  background-color: #eee;\n  color: black;\n  font-family: Courier, sans-serif;\n  font-size: 85%;\n}\n\ndiv.code {\n  width: 400px;\n}\n\n.heroic {\n  font-size: 150%;\n  font-weight: bold;\n}\n\nhr {\n  margin: 40px 0\n}\n\n.odd {\n  background-color:  palegoldenrod;\n}\n\ntd, th {\n  text-align: left;\n  vertical-align: top;\n}\n\np span { color: red; font-size: 70%; }\n\n.unless {\n  border: 2px solid;\n  padding: 6px;\n}\n\np.unless {\n  width: 500px;\n}\n\nbutton.a, span.a, .unless.a {\n  color: red;\n  border-color: gold;\n  background-color: yellow;\n  font-size: 100%;\n}\n\nbutton.b, span.b, .unless.b {\n  color: black;\n  border-color: green;\n  background-color: lightgreen;\n  font-size: 100%;\n}\n\n\n</code-pane>\n\n  <code-pane title=\"app.module.ts\" path=\"structural-directives/src/app/app.module.ts\">\nimport { NgModule }      from '@angular/core';\nimport { FormsModule }   from '@angular/forms';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { AppComponent }         from './app.component';\nimport { heroSwitchComponents } from './hero-switch.components';\nimport { UnlessDirective }    from './unless.directive';\n\n@NgModule({\n  imports: [ BrowserModule, FormsModule ],\n  declarations: [\n    AppComponent,\n    heroSwitchComponents,\n    UnlessDirective\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n  <code-pane title=\"hero.ts\" path=\"structural-directives/src/app/hero.ts\">\nexport class Hero {\n  id: number;\n  name: string;\n  emotion?: string;\n}\n\nexport const heroes: Hero[] = [\n  { id: 1, name: 'Mr. Nice',  emotion: 'happy'},\n  { id: 2, name: 'Narco',     emotion: 'sad' },\n  { id: 3, name: 'Windstorm', emotion: 'confused' },\n  { id: 4, name: 'Magneta'}\n];\n\n\n</code-pane>\n\n  <code-pane title=\"hero-switch.components.ts\" path=\"structural-directives/src/app/hero-switch.components.ts\">\nimport { Component, Input } from '@angular/core';\nimport { Hero } from './hero';\n\n@Component({\n  selector: 'happy-hero',\n  template: `Wow. You like {{hero.name}}. What a happy hero ... just like you.`\n})\nexport class HappyHeroComponent {\n  @Input() hero: Hero;\n}\n\n@Component({\n  selector: 'sad-hero',\n  template: `You like {{hero.name}}? Such a sad hero. Are you sad too?`\n})\nexport class SadHeroComponent {\n  @Input() hero: Hero;\n}\n\n@Component({\n  selector: 'confused-hero',\n  template: `Are you as confused as {{hero.name}}?`\n})\nexport class ConfusedHeroComponent {\n  @Input() hero: Hero;\n}\n\n@Component({\n  selector: 'unknown-hero',\n  template: `{{message}}`\n})\nexport class UnknownHeroComponent {\n  @Input() hero: Hero;\n  get message() {\n    return this.hero &#x26;&#x26; this.hero.name ?\n      `${this.hero.name} is strange and mysterious.` :\n      'Are you feeling indecisive?';\n  }\n}\n\nexport const heroSwitchComponents =\n  [ HappyHeroComponent, SadHeroComponent, ConfusedHeroComponent, UnknownHeroComponent ];\n\n\n</code-pane>\n\n  <code-pane title=\"unless.directive.ts\" path=\"structural-directives/src/app/unless.directive.ts\">\nimport { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';\n\n/**\n * Add the template content to the DOM unless the condition is true.\n *\n * If the expression assigned to `myUnless` evaluates to a truthy value\n * then the templated elements are removed removed from the DOM,\n * the templated elements are (re)inserted into the DOM.\n *\n * &#x3C;div *ngUnless=\"errorCount\" class=\"success\">\n *   Congrats! Everything is great!\n * &#x3C;/div>\n *\n * ### Syntax\n *\n * - `&#x3C;div *myUnless=\"condition\">...&#x3C;/div>`\n * - `&#x3C;div template=\"myUnless condition\">...&#x3C;/div>`\n * - `&#x3C;template [myUnless]=\"condition\">&#x3C;div>...&#x3C;/div>&#x3C;/template>`\n *\n */\n@Directive({ selector: '[myUnless]'})\nexport class UnlessDirective {\n  private hasView = false;\n\n  constructor(\n    private templateRef: TemplateRef&#x3C;any>,\n    private viewContainer: ViewContainerRef) { }\n\n  @Input() set myUnless(condition: boolean) {\n    if (!condition &#x26;&#x26; !this.hasView) {\n      this.viewContainer.createEmbeddedView(this.templateRef);\n      this.hasView = true;\n    } else if (condition &#x26;&#x26; this.hasView) {\n      this.viewContainer.clear();\n      this.hasView = false;\n    }\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p>You learned</p>\n<ul>\n<li>that structural directives manipulate HTML layout.</li>\n<li>to use <a href=\"guide/structural-directives#ngcontainer\"><code>&#x3C;ng-container></code></a> as a grouping element when there is no suitable host element.</li>\n<li>that the Angular desugars <a href=\"guide/structural-directives#asterisk\">asterisk (*) syntax</a> into a <code>&#x3C;ng-template></code>.</li>\n<li>how that works for the <code><a href=\"api/common/NgIf\">NgIf</a></code>, <code><a href=\"api/common/NgFor\">NgFor</a></code> and <code><a href=\"api/common/NgSwitch\">NgSwitch</a></code> built-in directives.</li>\n<li>about the <a href=\"guide/structural-directives#microsyntax\"><em>microsyntax</em></a> that expands into a <a href=\"guide/structural-directives#template\"><code>&#x3C;ng-template></code></a>.</li>\n<li>to write a <a href=\"guide/structural-directives#unless\">custom structural directive</a>, <code>UnlessDirective</code>.</li>\n</ul>\n\n</div>"
}