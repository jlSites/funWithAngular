{
  "id": "guide/form-validation",
  "title": "Form Validation",
  "contents": "\n<div class=\"content\">\n<h1 id=\"form-validation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#form-validation\"><i class=\"material-icons\">link</i></a>Form Validation</h1>\n<p>Improve overall data quality by validating user input for accuracy and completeness.</p>\n<p>This page shows how to validate user input in the UI and display useful validation messages\nusing first the Template Driven Forms and then the Reactive Forms approach.</p>\n<div class=\"l-sub-section\">\n<p>Read more about these choices in the <a href=\"guide/forms\">Forms</a>\nand the <a href=\"guide/reactive-forms\">Reactive Forms</a> guides.</p>\n</div>\n<a id=\"live-example\"></a>\n<p><strong>Try the live example to see and download the full cookbook source code.</strong></p>\n<live-example name=\"form-validation\" embedded=\"true\" img=\"guide/form-validation/plunker.png\">\n</live-example>\n<h2 id=\"simple-template-driven-forms\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#simple-template-driven-forms\"><i class=\"material-icons\">link</i></a>Simple Template Driven Forms</h2>\n<p>In the Template Driven approach, you arrange\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms_in_HTML\">form elements</a> in the component's template.</p>\n<p>You add Angular form directives (mostly directives beginning <code>ng...</code>) to help\nAngular construct a corresponding internal control model that implements form functionality.\nIn Template Driven forms, the control model is <em>implicit</em> in the template.</p>\n<p>To validate user input, you add <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation\">HTML validation attributes</a>\nto the elements. Angular interprets those as well, adding validator functions to the control model.</p>\n<p>Angular exposes information about the state of the controls including\nwhether the user has \"touched\" the control or made changes and if the control values are valid.</p>\n<p>In this first template validation example,\nnotice the HTML that reads the control state and updates the display appropriately.\nHere's an excerpt from the template HTML for a single input control bound to the hero name:</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template1.component.html\" region=\"name-with-error-msg\" title=\"template/hero-form-template1.component.html (Hero name)\" linenums=\"false\">\n&#x3C;label for=\"name\">Name&#x3C;/label>\n\n&#x3C;input type=\"text\" id=\"name\" class=\"form-control\"\n       required minlength=\"4\" maxlength=\"24\"\n       name=\"name\" [(ngModel)]=\"hero.name\"\n       #name=\"ngModel\" >\n\n&#x3C;div *ngIf=\"name.errors &#x26;&#x26; (name.dirty || name.touched)\"\n     class=\"alert alert-danger\">\n    &#x3C;div [hidden]=\"!name.errors.required\">\n      Name is required\n    &#x3C;/div>\n    &#x3C;div [hidden]=\"!name.errors.minlength\">\n      Name must be at least 4 characters long.\n    &#x3C;/div>\n    &#x3C;div [hidden]=\"!name.errors.maxlength\">\n      Name cannot be more than 24 characters long.\n    &#x3C;/div>\n&#x3C;/div>\n\n</code-example>\n<p>Note the following:</p>\n<ul>\n<li>\n<p>The <code>&#x3C;input></code> element carries the HTML validation attributes: <code>required</code>, <code>minlength</code>, and <code>maxlength</code>.</p>\n</li>\n<li>\n<p>The <code>name</code> attribute of the input is set to <code>\"name\"</code> so Angular can track this input element and associate it\nwith an Angular form control called <code>name</code> in its internal control model.</p>\n</li>\n<li>\n<p>The <code>[(ngModel)]</code> directive allows two-way data binding between the input box to the <code>hero.name</code> property.</p>\n</li>\n<li>\n<p>The template variable (<code>#name</code>) has the value <code>\"ngModel\"</code> (always <code>ngModel</code>).\nThis gives you a reference to the Angular <code><a href=\"api/forms/NgModel\">NgModel</a></code> directive\nassociated with this control that you can use <em>in the template</em>\nto check for control states such as <code>valid</code> and <code>dirty</code>.</p>\n</li>\n<li>\n<p>The <code>*ngIf</code> on the <code>&#x3C;div></code> element reveals a set of nested message <code>divs</code>\nbut only if there are <code>name</code> errors and\nthe control is either <code>dirty</code> or <code>touched</code>.</p>\n</li>\n<li>\n<p>Each nested <code>&#x3C;div></code> can present a custom message for one of the possible validation errors.\nThere are messages for <code>required</code>, <code>minlength</code>, and <code>maxlength</code>.</p>\n</li>\n</ul>\n<p>The full template repeats this kind of layout for each data entry control on the form.</p>\n<a id=\"why-check\"></a>\n<div class=\"l-sub-section\">\n<h4 id=\"why-check-dirty-and-touched\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#why-check-dirty-and-touched\"><i class=\"material-icons\">link</i></a>Why check <em>dirty</em> and <em>touched</em>?</h4>\n<p>The app shouldn't show errors for a new hero before the user has had a chance to edit the value.\nThe checks for <code>dirty</code> and <code>touched</code> prevent premature display of errors.</p>\n<p>Learn about <code>dirty</code> and <code>touched</code> in the <a href=\"guide/forms\">Forms</a> guide.</p>\n</div>\n<p>The component class manages the hero model used in the data binding\nas well as other code to support the view.</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template1.component.ts\" region=\"class\" title=\"template/hero-form-template1.component.ts (class)\">\nexport class HeroFormTemplate1Component {\n\n  powers = ['Really Smart', 'Super Flexible', 'Weather Changer'];\n\n  hero = new Hero(18, 'Dr. WhatIsHisWayTooLongName', this.powers[0], 'Dr. What');\n\n  submitted = false;\n\n  onSubmit() {\n    this.submitted = true;\n  }\n\n  addHero() {\n    this.hero = new Hero(42, '', '');\n  }\n}\n\n</code-example>\n<p>Use this Template Driven validation technique when working with static forms with simple, standard validation rules.</p>\n<p>Here are the complete files for the first version of <code>HeroFormTemplateCompononent</code> in the Template Driven approach:</p>\n<code-tabs>\n\n  <code-pane title=\"template/hero-form-template1.component.html\" path=\"form-validation/src/app/template/hero-form-template1.component.html\">\n&#x3C;div class=\"container\">\n  &#x3C;div [hidden]=\"submitted\">\n    &#x3C;h1>Hero Form 1 (Template)&#x3C;/h1>\n    &#x3C;form #heroForm=\"ngForm\"  *ngIf=\"active\"  (ngSubmit)=\"onSubmit()\">\n      &#x3C;div class=\"form-group\">\n        &#x3C;label for=\"name\">Name&#x3C;/label>\n\n        &#x3C;input type=\"text\" id=\"name\" class=\"form-control\"\n               required minlength=\"4\" maxlength=\"24\"\n               name=\"name\" [(ngModel)]=\"hero.name\"\n               #name=\"ngModel\" >\n\n        &#x3C;div *ngIf=\"name.errors &#x26;&#x26; (name.dirty || name.touched)\"\n             class=\"alert alert-danger\">\n            &#x3C;div [hidden]=\"!name.errors.required\">\n              Name is required\n            &#x3C;/div>\n            &#x3C;div [hidden]=\"!name.errors.minlength\">\n              Name must be at least 4 characters long.\n            &#x3C;/div>\n            &#x3C;div [hidden]=\"!name.errors.maxlength\">\n              Name cannot be more than 24 characters long.\n            &#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/div>\n\n      &#x3C;div class=\"form-group\">\n        &#x3C;label for=\"alterEgo\">Alter Ego&#x3C;/label>\n        &#x3C;input type=\"text\" id=\"alterEgo\" class=\"form-control\"\n               name=\"alterEgo\"\n               [(ngModel)]=\"hero.alterEgo\" >\n      &#x3C;/div>\n\n      &#x3C;div class=\"form-group\">\n        &#x3C;label for=\"power\">Hero Power&#x3C;/label>\n        &#x3C;select id=\"power\" class=\"form-control\"\n                name=\"power\"\n                [(ngModel)]=\"hero.power\" required\n                #power=\"ngModel\" >\n          &#x3C;option *ngFor=\"let p of powers\" [value]=\"p\">{{p}}&#x3C;/option>\n        &#x3C;/select>\n\n        &#x3C;div *ngIf=\"power.errors &#x26;&#x26; power.touched\" class=\"alert alert-danger\">\n          &#x3C;div [hidden]=\"!power.errors.required\">Power is required&#x3C;/div>\n        &#x3C;/div>\n      &#x3C;/div>\n\n      &#x3C;button type=\"submit\" class=\"btn btn-default\"\n             [disabled]=\"!heroForm.form.valid\">Submit&#x3C;/button>\n      &#x3C;button type=\"button\" class=\"btn btn-default\"\n             (click)=\"addHero()\">New Hero&#x3C;/button>\n    &#x3C;/form>\n  &#x3C;/div>\n\n  &#x3C;hero-submitted [hero]=\"hero\" [(submitted)]=\"submitted\">&#x3C;/hero-submitted>\n&#x3C;/div>\n\n\n</code-pane>\n\n  <code-pane title=\"template/hero-form-template1.component.ts\" path=\"form-validation/src/app/template/hero-form-template1.component.ts\">\nimport { Component } from '@angular/core';\n\n\nimport { Hero }      from '../shared/hero';\n\n@Component({\n  selector: 'hero-form-template1',\n  templateUrl: './hero-form-template1.component.html'\n})\nexport class HeroFormTemplate1Component {\n\n  powers = ['Really Smart', 'Super Flexible', 'Weather Changer'];\n\n  hero = new Hero(18, 'Dr. WhatIsHisWayTooLongName', this.powers[0], 'Dr. What');\n\n  submitted = false;\n\n  onSubmit() {\n    this.submitted = true;\n  }\n\n  addHero() {\n    this.hero = new Hero(42, '', '');\n  }\n}\n\n</code-pane>\n\n</code-tabs>\n<h2 id=\"template-driven-forms-with-validation-messages-in-code\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#template-driven-forms-with-validation-messages-in-code\"><i class=\"material-icons\">link</i></a>Template Driven Forms with validation messages in code</h2>\n<p>While the layout is straightforward,\nthere are obvious shortcomings with the way it's handling validation messages:</p>\n<ul>\n<li>\n<p>It takes a lot of HTML to represent all possible error conditions.\nThis gets out of hand when there are many controls and many validation rules.</p>\n</li>\n<li>\n<p>There's a lot of JavaScript logic in the HTML.</p>\n</li>\n<li>\n<p>The messages are static strings, hard-coded into the template.\nIt's easier to maintain <em>dynamic</em> messages in the component class.</p>\n</li>\n</ul>\n<p>In this example, you can move the logic and the messages into the component with a few changes to\nthe template and component.</p>\n<p>Here's the hero name again, excerpted from the revised template\n(template 2), next to the original version:</p>\n<code-tabs>\n\n  <code-pane title=\"hero-form-template2.component.html (name #2)\" path=\"form-validation/src/app/template/hero-form-template2.component.html\" region=\"name-with-error-msg\">\n&#x3C;label for=\"name\">Name&#x3C;/label>\n\n&#x3C;input type=\"text\" id=\"name\" class=\"form-control\"\n       required minlength=\"4\" maxlength=\"24\" forbiddenName=\"bob\"\n       name=\"name\" [(ngModel)]=\"hero.name\" >\n\n&#x3C;div *ngIf=\"formErrors.name\" class=\"alert alert-danger\">\n  {{ formErrors.name }}\n&#x3C;/div>\n\n</code-pane>\n\n  <code-pane title=\"hero-form-template1.component.html (name #1)\" path=\"form-validation/src/app/template/hero-form-template1.component.html\" region=\"name-with-error-msg\">\n&#x3C;label for=\"name\">Name&#x3C;/label>\n\n&#x3C;input type=\"text\" id=\"name\" class=\"form-control\"\n       required minlength=\"4\" maxlength=\"24\"\n       name=\"name\" [(ngModel)]=\"hero.name\"\n       #name=\"ngModel\" >\n\n&#x3C;div *ngIf=\"name.errors &#x26;&#x26; (name.dirty || name.touched)\"\n     class=\"alert alert-danger\">\n    &#x3C;div [hidden]=\"!name.errors.required\">\n      Name is required\n    &#x3C;/div>\n    &#x3C;div [hidden]=\"!name.errors.minlength\">\n      Name must be at least 4 characters long.\n    &#x3C;/div>\n    &#x3C;div [hidden]=\"!name.errors.maxlength\">\n      Name cannot be more than 24 characters long.\n    &#x3C;/div>\n&#x3C;/div>\n\n</code-pane>\n\n</code-tabs>\n<p>The <code>&#x3C;input></code> element HTML is almost the same. There are noteworthy differences:</p>\n<ul>\n<li>\n<p>The hard-code error message <code>&#x3C;divs></code> are gone.</p>\n</li>\n<li>\n<p>There's a new attribute, <code>forbiddenName</code>, that is actually a custom validation directive.\nIt invalidates the control if the user enters \"bob\" in the name <code>&#x3C;input></code>(<a href=\"guide/form-validation#live-example\">try it</a>).\nSee the <a href=\"guide/form-validation#custom-validation\">custom validation</a> section later in this page for more information\non custom validation directives.</p>\n</li>\n<li>\n<p>The <code>#name</code> template variable is gone because the app no longer refers to the Angular control for this element.</p>\n</li>\n<li>\n<p>Binding to the new <code>formErrors.name</code> property is sufficient to display all name validation error messages.</p>\n</li>\n</ul>\n<a id=\"component-class\"></a>\n<h3 id=\"component-class\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#component-class\"><i class=\"material-icons\">link</i></a>Component class</h3>\n<p>The original component code for Template 1 stayed the same; however,\nTemplate 2 requires some changes in the component. This section covers the code\nnecessary in Template 2's component class to acquire the Angular\nform control and compose error messages.</p>\n<p>The first step is to acquire the form control that Angular created from the template by querying for it.</p>\n<p>Look back at the top of the component template at the\n<code>#heroForm</code> template variable in the <code>&#x3C;form></code> element:</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template1.component.html\" region=\"form-tag\" title=\"template/hero-form-template1.component.html (form tag)\" linenums=\"false\">\n&#x3C;form #heroForm=\"ngForm\"  *ngIf=\"active\"  (ngSubmit)=\"onSubmit()\">\n\n</code-example>\n<p>The <code>heroForm</code> variable is a reference to the control model that Angular derived from the template.\nTell Angular to inject that model into the component class's <code>currentForm</code> property using a <code>@ViewChild</code> query:</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template2.component.ts\" region=\"view-child\" title=\"template/hero-form-template2.component.ts (heroForm)\" linenums=\"false\">\nheroForm: NgForm;\n@ViewChild('heroForm') currentForm: NgForm;\n\nngAfterViewChecked() {\n  this.formChanged();\n}\n\nformChanged() {\n  if (this.currentForm === this.heroForm) { return; }\n  this.heroForm = this.currentForm;\n  if (this.heroForm) {\n    this.heroForm.valueChanges\n      .subscribe(data => this.onValueChanged(data));\n  }\n}\n\n</code-example>\n<p>Some observations:</p>\n<ul>\n<li>\n<p>Angular <code>@ViewChild</code> queries for a template variable when you pass it\nthe name of that variable as a string (<code>'heroForm'</code> in this case).</p>\n</li>\n<li>\n<p>The <code>heroForm</code> object changes several times during the life of the component, most notably when you add a new hero.\nPeriodically inspecting it reveals these changes.</p>\n</li>\n<li>\n<p>Angular calls the <code>ngAfterViewChecked()</code> <a href=\"guide/lifecycle-hooks#afterview\">lifecycle hook method</a>\nwhen anything changes in the view.\nThat's the right time to see if there's a new <code>heroForm</code> object.</p>\n</li>\n<li>\n<p>When there <em>is</em> a new <code>heroForm</code> model, <code>formChanged()</code> subscribes to its <code>valueChanges</code> <em>Observable</em> property.\nThe <code>onValueChanged</code> handler looks for validation errors after every keystroke.</p>\n</li>\n</ul>\n<code-example path=\"form-validation/src/app/template/hero-form-template2.component.ts\" region=\"handler\" title=\"template/hero-form-template2.component.ts (handler)\" linenums=\"false\">\nonValueChanged(data?: any) {\n  if (!this.heroForm) { return; }\n  const form = this.heroForm.form;\n\n  for (const field in this.formErrors) {\n    // clear previous error message (if any)\n    this.formErrors[field] = '';\n    const control = form.get(field);\n\n    if (control &#x26;&#x26; control.dirty &#x26;&#x26; !control.valid) {\n      const messages = this.validationMessages[field];\n      for (const key in control.errors) {\n        this.formErrors[field] += messages[key] + ' ';\n      }\n    }\n  }\n}\n\nformErrors = {\n  'name': '',\n  'power': ''\n};\n\n</code-example>\n<p>The <code>onValueChanged</code> handler interprets user data entry.\nThe <code>data</code> object passed into the handler contains the current element values.\nThe handler ignores them. Instead, it iterates over the fields of the component's <code>formErrors</code> object.</p>\n<p>The <code>formErrors</code> is a dictionary of the hero fields that have validation rules and their current error messages.\nOnly two hero properties have validation rules, <code>name</code> and <code>power</code>.\nThe messages are empty strings when the hero data are valid.</p>\n<p>For each field, the <code>onValueChanged</code> handler does the following:</p>\n<ul>\n<li>Clears the prior error message, if any.</li>\n<li>Acquires the field's corresponding Angular form control.</li>\n<li>If such a control exists <em>and</em> it's been changed (\"dirty\")\n<em>and</em> it's invalid, the handler composes a consolidated error message for all of the control's errors.</li>\n</ul>\n<p>Next, the component needs some error messages—a set for each validated property with\none message per validation rule:</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template2.component.ts\" region=\"messages\" title=\"template/hero-form-template2.component.ts (messages)\" linenums=\"false\">\nvalidationMessages = {\n  'name': {\n    'required':      'Name is required.',\n    'minlength':     'Name must be at least 4 characters long.',\n    'maxlength':     'Name cannot be more than 24 characters long.',\n    'forbiddenName': 'Someone named \"Bob\" cannot be a hero.'\n  },\n  'power': {\n    'required': 'Power is required.'\n  }\n};\n\n</code-example>\n<p>Now every time the user makes a change, the <code>onValueChanged</code> handler checks for validation errors and produces messages accordingly.</p>\n<a id=\"improvement\"></a>\n<h3 id=\"the-benefits-of-messages-in-code\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#the-benefits-of-messages-in-code\"><i class=\"material-icons\">link</i></a>The benefits of messages in code</h3>\n<p>Clearly the template got substantially smaller while the component code got substantially larger.\nIt's not easy to see the benefit when there are just three fields and only two of them have validation rules.</p>\n<p>Consider what happens as the number of validated\nfields and rules increases.\nIn general, HTML is harder to read and maintain than code.\nThe initial template was already large and threatening to get rapidly worse\nwith the addition of more validation message <code>&#x3C;div></code> elements.</p>\n<p>After moving the validation messaging to the component,\nthe template grows more slowly and proportionally.\nEach field has approximately the same number of lines no matter its number of validation rules.\nThe component also grows proportionally, at the rate of one line per validated field\nand one line per validation message.</p>\n<p>Now that the messages are in code, you have more flexibility and can compose messages more efficiently.\nYou can refactor the messages out of the component, perhaps to a service class that retrieves them from the server.\nIn short, there are more opportunities to improve message handling now that text and logic have moved from template to code.</p>\n<a id=\"formmodule\"></a>\n<h3 id=\"formmodule-and-template-driven-forms\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#formmodule-and-template-driven-forms\"><i class=\"material-icons\">link</i></a><em>FormModule</em> and Template Driven forms</h3>\n<p>Angular has two different forms modules—<code><a href=\"api/forms/FormsModule\">FormsModule</a></code> and\n<code><a href=\"api/forms/ReactiveFormsModule\">ReactiveFormsModule</a></code>—that correspond with the\ntwo approaches to form development. Both modules come\nfrom the same <code>@angular/forms</code> library package.</p>\n<p>You've been reviewing the Template Driven approach which requires the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.\nHere's how you imported it in the <code>HeroFormTemplateModule</code>.</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template.module.ts\" title=\"template/hero-form-template.module.ts\" linenums=\"false\">\nimport { NgModule }     from '@angular/core';\nimport { FormsModule }  from '@angular/forms';\n\nimport { SharedModule }               from '../shared/shared.module';\nimport { HeroFormTemplate1Component } from './hero-form-template1.component';\nimport { HeroFormTemplate2Component } from './hero-form-template2.component';\n\n@NgModule({\n  imports:      [ SharedModule, FormsModule ],\n  declarations: [ HeroFormTemplate1Component, HeroFormTemplate2Component ],\n  exports:      [ HeroFormTemplate1Component, HeroFormTemplate2Component ]\n})\nexport class HeroFormTemplateModule { }\n\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>This guide hasn't talked about the <code>SharedModule</code> or its <code>SubmittedComponent</code> which appears at the bottom of every\nform template in this cookbook.</p>\n<p>They're not germane to the validation story. Look at the <a href=\"guide/form-validation#live-example\">live example</a> if you're interested.</p>\n</div>\n<a id=\"reactive\"></a>\n<h2 id=\"reactive-forms-with-validation-in-code\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#reactive-forms-with-validation-in-code\"><i class=\"material-icons\">link</i></a>Reactive Forms with validation in code</h2>\n<p>In the Template Driven approach, you mark up the template with form elements, validation attributes,\nand <code>ng...</code> directives from the Angular <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.\nAt runtime, Angular interprets the template and derives its <em>form control model</em>.</p>\n<p><strong>Reactive Forms</strong> takes a different approach.\nYou create the form control model in code. You write the template with form elements\nand <code>form...</code> directives from the Angular <code><a href=\"api/forms/ReactiveFormsModule\">ReactiveFormsModule</a></code>.\nAt runtime, Angular binds the template elements to your control model based on your instructions.</p>\n<p>This allows you to do the following:</p>\n<ul>\n<li>Add, change, and remove validation functions on the fly.</li>\n<li>Manipulate the control model dynamically from within the component.</li>\n<li><a href=\"guide/form-validation#testing-considerations\">Test</a> validation and control logic with isolated unit tests.</li>\n</ul>\n<p>The following sample re-writes the hero form in Reactive Forms style.</p>\n<a id=\"reactive-forms-module\"></a>\n<h3 id=\"switch-to-the-reactiveformsmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#switch-to-the-reactiveformsmodule\"><i class=\"material-icons\">link</i></a>Switch to the <em>ReactiveFormsModule</em></h3>\n<p>The Reactive Forms classes and directives come from the Angular <code><a href=\"api/forms/ReactiveFormsModule\">ReactiveFormsModule</a></code>, not the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.\nThe application module for the Reactive Forms feature in this sample looks like this:</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.module.ts\" title=\"src/app/reactive/hero-form-reactive.module.ts\" linenums=\"false\">\nimport { NgModule }            from '@angular/core';\nimport { ReactiveFormsModule } from '@angular/forms';\n\nimport { SharedModule }              from '../shared/shared.module';\nimport { HeroFormReactiveComponent } from './hero-form-reactive.component';\n\n@NgModule({\n  imports:      [ SharedModule, ReactiveFormsModule ],\n  declarations: [ HeroFormReactiveComponent ],\n  exports:      [ HeroFormReactiveComponent ]\n})\nexport class HeroFormReactiveModule { }\n\n\n</code-example>\n<p>The Reactive Forms feature module and component are in the <code>src/app/reactive</code> folder.\nFocus on the <code>HeroFormReactiveComponent</code> there, starting with its template.</p>\n<a id=\"reactive-component-template\"></a>\n<h3 id=\"component-template\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#component-template\"><i class=\"material-icons\">link</i></a>Component template</h3>\n<p>Begin by changing the <code>&#x3C;form></code> tag so that it binds the Angular <code>formGroup</code> directive in the template\nto the <code>heroForm</code> property in the component class.\nThe <code>heroForm</code> is the control model that the component class builds and maintains.</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"form-tag\" title=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" linenums=\"false\">\n&#x3C;form [formGroup]=\"heroForm\"  *ngIf=\"active\"  (ngSubmit)=\"onSubmit()\">\n\n</code-example>\n<p>Next, modify the template HTML elements to match the Reactive Forms style.\nHere is the \"name\" portion of the template again, revised for Reactive Forms and compared with the Template Driven version:</p>\n<code-tabs>\n\n  <code-pane title=\"hero-form-reactive.component.html (name #3)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"name-with-error-msg\">\n&#x3C;label for=\"name\">Name&#x3C;/label>\n\n&#x3C;input type=\"text\" id=\"name\" class=\"form-control\"\n       formControlName=\"name\" required >\n\n&#x3C;div *ngIf=\"formErrors.name\" class=\"alert alert-danger\">\n  {{ formErrors.name }}\n&#x3C;/div>\n\n</code-pane>\n\n  <code-pane title=\"hero-form-template1.component.html (name #2)\" path=\"form-validation/src/app/template/hero-form-template2.component.html\" region=\"name-with-error-msg\">\n&#x3C;label for=\"name\">Name&#x3C;/label>\n\n&#x3C;input type=\"text\" id=\"name\" class=\"form-control\"\n       required minlength=\"4\" maxlength=\"24\" forbiddenName=\"bob\"\n       name=\"name\" [(ngModel)]=\"hero.name\" >\n\n&#x3C;div *ngIf=\"formErrors.name\" class=\"alert alert-danger\">\n  {{ formErrors.name }}\n&#x3C;/div>\n\n</code-pane>\n\n</code-tabs>\n<p>Key changes are:</p>\n<ul>\n<li>\n<p>The validation attributes are gone (except <code>required</code>) because\nvalidating happens in code.</p>\n</li>\n<li>\n<p><code>required</code> remains, not for validation purposes (that's in the code),\nbut rather for css styling and accessibility.</p>\n</li>\n</ul>\n<div class=\"l-sub-section\">\n<p>Currently, Reactive Forms doesn't add the <code>required</code> or <code>aria-required</code>\nHTML validation attribute to the DOM element\nwhen the control has the <code>required</code> validator function.</p>\n<p>Until then, apply the <code>required</code> attribute <em>and</em> add the <code>Validator.required</code> function\nto the control model, as you'll see below.</p>\n</div>\n<ul>\n<li>\n<p>The <code>formControlName</code> replaces the <code>name</code> attribute; it serves the same\npurpose of correlating the input with the Angular form control.</p>\n</li>\n<li>\n<p>The two-way <code>[(ngModel)]</code> binding is gone.\nThe reactive approach does not use data binding to move data into and out of the form controls.\nThat's all in code.</p>\n</li>\n</ul>\n<a id=\"reactive-component-class\"></a>\n<h3 id=\"component-class-1\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#component-class-1\"><i class=\"material-icons\">link</i></a>Component class</h3>\n<p>The component class is now responsible for defining and managing the form control model.</p>\n<p>Angular no longer derives the control model from the template so you can no longer query for it.\nYou can create the Angular form control model explicitly with\nthe help of the <code><a href=\"api/forms/FormBuilder\">FormBuilder</a></code> class.</p>\n<p>Here's the section of code devoted to that process, paired with the Template Driven code it replaces:</p>\n<code-tabs>\n\n  <code-pane title=\"reactive/hero-form-reactive.component.ts (FormBuilder)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\" region=\"form-builder\">\nheroForm: FormGroup;\nconstructor(private fb: FormBuilder) { }\n\nngOnInit(): void {\n  this.buildForm();\n}\n\nbuildForm(): void {\n  this.heroForm = this.fb.group({\n    'name': [this.hero.name, [\n        Validators.required,\n        Validators.minLength(4),\n        Validators.maxLength(24),\n        forbiddenNameValidator(/bob/i)\n      ]\n    ],\n    'alterEgo': [this.hero.alterEgo],\n    'power':    [this.hero.power, Validators.required]\n  });\n\n  this.heroForm.valueChanges\n    .subscribe(data => this.onValueChanged(data));\n\n  this.onValueChanged(); // (re)set validation messages now\n}\n\n\n</code-pane>\n\n  <code-pane title=\"template/hero-form-template2.component.ts (ViewChild)\" path=\"form-validation/src/app/template/hero-form-template2.component.ts\" region=\"view-child\">\nheroForm: NgForm;\n@ViewChild('heroForm') currentForm: NgForm;\n\nngAfterViewChecked() {\n  this.formChanged();\n}\n\nformChanged() {\n  if (this.currentForm === this.heroForm) { return; }\n  this.heroForm = this.currentForm;\n  if (this.heroForm) {\n    this.heroForm.valueChanges\n      .subscribe(data => this.onValueChanged(data));\n  }\n}\n\n</code-pane>\n\n</code-tabs>\n<ul>\n<li>\n<p>Inject <code><a href=\"api/forms/FormBuilder\">FormBuilder</a></code> in a constructor.</p>\n</li>\n<li>\n<p>Call a <code>buildForm</code> method in the <code>ngOnInit</code> <a href=\"guide/lifecycle-hooks#hooks-overview\">lifecycle hook method</a>\nbecause that's when you'll have the hero data. Call it again in the <code>addHero</code> method.</p>\n</li>\n</ul>\n<div class=\"l-sub-section\">\n<p>A real app would retrieve the hero asynchronously from a data service, a task best performed in the <code>ngOnInit</code> hook.</p>\n</div>\n<ul>\n<li>The <code>buildForm</code> method uses the <code><a href=\"api/forms/FormBuilder\">FormBuilder</a></code>, <code>fb</code>, to declare the form control model.\nThen it attaches the same <code>onValueChanged</code> handler (there's a one line difference)\nto the form's <code>valueChanges</code> event and calls it immediately\nto set error messages for the new control model.</li>\n</ul>\n<h2 id=\"built-in-validators\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#built-in-validators\"><i class=\"material-icons\">link</i></a>Built-in validators</h2>\n<p>Angular forms include a number of built-in validator functions, which are functions\nthat help you check common user input in forms. In addition to the built-in\nvalidators covered here of <code>minlength</code>, <code>maxlength</code>,\nand <code>required</code>, there are others such as <code>email</code> and <code>pattern</code>\nfor Reactive Forms.\nFor a full list of built-in validators,\nsee the <a href=\"api/forms/Validators\">Validators</a> API reference.</p>\n<h4 id=\"formbuilder-declaration\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#formbuilder-declaration\"><i class=\"material-icons\">link</i></a><em>FormBuilder</em> declaration</h4>\n<p>The <code><a href=\"api/forms/FormBuilder\">FormBuilder</a></code> declaration object specifies the three controls of the sample's hero form.</p>\n<p>Each control spec is a control name with an array value.\nThe first array element is the current value of the corresponding hero field.\nThe optional second value is a validator function or an array of validator functions.</p>\n<p>Most of the validator functions are stock validators provided by Angular as static methods of the <code><a href=\"api/forms/Validators\">Validators</a></code> class.\nAngular has stock validators that correspond to the standard HTML validation attributes.</p>\n<p>The <code>forbiddenName</code> validator on the <code>\"name\"</code> control is a custom validator,\ndiscussed in a separate <a href=\"guide/form-validation#custom-validation\">section below</a>.</p>\n<div class=\"l-sub-section\">\n<p>Learn more about <code><a href=\"api/forms/FormBuilder\">FormBuilder</a></code> in the <a href=\"guide/reactive-forms#formbuilder\">Introduction to FormBuilder</a> section of Reactive Forms guide.</p>\n</div>\n<h4 id=\"committing-hero-value-changes\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#committing-hero-value-changes\"><i class=\"material-icons\">link</i></a>Committing hero value changes</h4>\n<p>In two-way data binding, the user's changes flow automatically from the controls back to the data model properties.\nA Reactive Forms component should not use data binding to\nautomatically update data model properties.\nThe developer decides <em>when and how</em> to update the data model from control values.</p>\n<p>This sample updates the model twice:</p>\n<ol>\n<li>When the user submits the form.</li>\n<li>When the user adds a new hero.</li>\n</ol>\n<p>The <code>onSubmit()</code> method simply replaces the <code>hero</code> object with the combined values of the form:</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\" region=\"on-submit\" title=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\" linenums=\"false\">\nonSubmit() {\n  this.submitted = true;\n  this.hero = this.heroForm.value;\n}\n\n</code-example>\n<p>The <code>addHero()</code> method discards pending changes and creates a brand new <code>hero</code> model object.</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\" region=\"add-hero\" title=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\" linenums=\"false\">\naddHero() {\n  this.hero = new Hero(42, '', '');\n  this.buildForm();\n}\n\n</code-example>\n<p>Then it calls <code>buildForm()</code> again which replaces the previous <code>heroForm</code> control model with a new one.\nThe <code>&#x3C;form></code> tag's <code>[formGroup]</code> binding refreshes the page with the new control model.</p>\n<p>Here's the complete reactive component file, compared to the two Template Driven component files.</p>\n<code-tabs>\n\n  <code-pane title=\"reactive/hero-form-reactive.component.ts (#3)\" path=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\">\nimport { Component, OnInit }                  from '@angular/core';\nimport { FormGroup, FormBuilder, Validators } from '@angular/forms';\n\nimport { Hero }                   from '../shared/hero';\nimport { forbiddenNameValidator } from '../shared/forbidden-name.directive';\n\n@Component({\n  selector: 'hero-form-reactive3',\n  templateUrl: './hero-form-reactive.component.html'\n})\nexport class HeroFormReactiveComponent implements OnInit {\n\n  powers = ['Really Smart', 'Super Flexible', 'Weather Changer'];\n\n  hero = new Hero(18, 'Dr. WhatIsHisName', this.powers[0], 'Dr. What');\n\n  submitted = false;\n\n  onSubmit() {\n    this.submitted = true;\n    this.hero = this.heroForm.value;\n  }\n  }\n\n  heroForm: FormGroup;\n  constructor(private fb: FormBuilder) { }\n\n  ngOnInit(): void {\n    this.buildForm();\n  }\n\n  buildForm(): void {\n    this.heroForm = this.fb.group({\n      'name': [this.hero.name, [\n          Validators.required,\n          Validators.minLength(4),\n          Validators.maxLength(24),\n          forbiddenNameValidator(/bob/i)\n        ]\n      ],\n      'alterEgo': [this.hero.alterEgo],\n      'power':    [this.hero.power, Validators.required]\n    });\n\n    this.heroForm.valueChanges\n      .subscribe(data => this.onValueChanged(data));\n\n    this.onValueChanged(); // (re)set validation messages now\n  }\n\n\n  onValueChanged(data?: any) {\n    if (!this.heroForm) { return; }\n    const form = this.heroForm;\n\n    for (const field in this.formErrors) {\n      // clear previous error message (if any)\n      this.formErrors[field] = '';\n      const control = form.get(field);\n\n      if (control &#x26;&#x26; control.dirty &#x26;&#x26; !control.valid) {\n        const messages = this.validationMessages[field];\n        for (const key in control.errors) {\n          this.formErrors[field] += messages[key] + ' ';\n        }\n      }\n    }\n  }\n\n  formErrors = {\n    'name': '',\n    'power': ''\n  };\n\n  validationMessages = {\n    'name': {\n      'required':      'Name is required.',\n      'minlength':     'Name must be at least 4 characters long.',\n      'maxlength':     'Name cannot be more than 24 characters long.',\n      'forbiddenName': 'Someone named \"Bob\" cannot be a hero.'\n    },\n    'power': {\n      'required': 'Power is required.'\n    }\n  };\n}\n\n</code-pane>\n\n  <code-pane title=\"template/hero-form-template2.component.ts (#2)\" path=\"form-validation/src/app/template/hero-form-template2.component.ts\">\nimport { Component, AfterViewChecked, ViewChild } from '@angular/core';\nimport { NgForm } from '@angular/forms';\n\nimport { Hero }      from '../shared/hero';\n\n@Component({\n  selector: 'hero-form-template2',\n  templateUrl: './hero-form-template2.component.html'\n})\nexport class HeroFormTemplate2Component implements AfterViewChecked {\n\n  powers = ['Really Smart', 'Super Flexible', 'Weather Changer'];\n\n  hero = new Hero(18, 'Dr. WhatIsHisWayTooLongName', this.powers[0], 'Dr. What');\n\n  submitted = false;\n\n  onSubmit() {\n    this.submitted = true;\n  }\n\n  addHero() {\n    this.hero = new Hero(42, '', '');\n  }\n\n  heroForm: NgForm;\n  @ViewChild('heroForm') currentForm: NgForm;\n\n  ngAfterViewChecked() {\n    this.formChanged();\n  }\n\n  formChanged() {\n    if (this.currentForm === this.heroForm) { return; }\n    this.heroForm = this.currentForm;\n    if (this.heroForm) {\n      this.heroForm.valueChanges\n        .subscribe(data => this.onValueChanged(data));\n    }\n  }\n\n  onValueChanged(data?: any) {\n    if (!this.heroForm) { return; }\n    const form = this.heroForm.form;\n\n    for (const field in this.formErrors) {\n      // clear previous error message (if any)\n      this.formErrors[field] = '';\n      const control = form.get(field);\n\n      if (control &#x26;&#x26; control.dirty &#x26;&#x26; !control.valid) {\n        const messages = this.validationMessages[field];\n        for (const key in control.errors) {\n          this.formErrors[field] += messages[key] + ' ';\n        }\n      }\n    }\n  }\n\n  formErrors = {\n    'name': '',\n    'power': ''\n  };\n\n  validationMessages = {\n    'name': {\n      'required':      'Name is required.',\n      'minlength':     'Name must be at least 4 characters long.',\n      'maxlength':     'Name cannot be more than 24 characters long.',\n      'forbiddenName': 'Someone named \"Bob\" cannot be a hero.'\n    },\n    'power': {\n      'required': 'Power is required.'\n    }\n  };\n}\n\n</code-pane>\n\n  <code-pane title=\"template/hero-form-template1.component.ts (#1)\" path=\"form-validation/src/app/template/hero-form-template1.component.ts\">\nimport { Component } from '@angular/core';\n\n\nimport { Hero }      from '../shared/hero';\n\n@Component({\n  selector: 'hero-form-template1',\n  templateUrl: './hero-form-template1.component.html'\n})\nexport class HeroFormTemplate1Component {\n\n  powers = ['Really Smart', 'Super Flexible', 'Weather Changer'];\n\n  hero = new Hero(18, 'Dr. WhatIsHisWayTooLongName', this.powers[0], 'Dr. What');\n\n  submitted = false;\n\n  onSubmit() {\n    this.submitted = true;\n  }\n\n  addHero() {\n    this.hero = new Hero(42, '', '');\n  }\n}\n\n</code-pane>\n\n</code-tabs>\n<div class=\"l-sub-section\">\n<p>Run the <a href=\"guide/form-validation#live-example\">live example</a> to see how the reactive form behaves,\nand to compare all of the files in this sample.</p>\n</div>\n<h2 id=\"custom-validation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#custom-validation\"><i class=\"material-icons\">link</i></a>Custom validation</h2>\n<p>This cookbook sample has a custom <code>forbiddenNameValidator()</code> function that's applied to both the\nTemplate Driven and the reactive form controls. It's in the <code>src/app/shared</code> folder\nand declared in the <code>SharedModule</code>.</p>\n<p>Here's the <code>forbiddenNameValidator()</code> function:</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"custom-validator\" title=\"shared/forbidden-name.directive.ts (forbiddenNameValidator)\" linenums=\"false\">\n/** A hero's name can't match the given regular expression */\nexport function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {\n  return (control: AbstractControl): {[key: string]: any} => {\n    const name = control.value;\n    const no = nameRe.test(name);\n    return no ? {'forbiddenName': {name}} : null;\n  };\n}\n\n</code-example>\n<p>The function is actually a factory that takes a regular expression to detect a <em>specific</em> forbidden name\nand returns a validator function.</p>\n<p>In this sample, the forbidden name is \"bob\";\nthe validator rejects any hero name containing \"bob\".\nElsewhere it could reject \"alice\" or any name that the configuring regular expression matches.</p>\n<p>The <code>forbiddenNameValidator</code> factory returns the configured validator function.\nThat function takes an Angular control object and returns <em>either</em>\nnull if the control value is valid <em>or</em> a validation error object.\nThe validation error object typically has a property whose name is the validation key, <code>'forbiddenName'</code>,\nand whose value is an arbitrary dictionary of values that you could insert into an error message (<code>{name}</code>).</p>\n<h3 id=\"custom-validation-directive\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#custom-validation-directive\"><i class=\"material-icons\">link</i></a>Custom validation directive</h3>\n<p>In the Reactive Forms component, the <code>'name'</code> control's validator function list\nhas a <code>forbiddenNameValidator</code> at the bottom.</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\" region=\"name-validators\" title=\"reactive/hero-form-reactive.component.ts (name validators)\" linenums=\"false\">\n'name': [this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    Validators.maxLength(24),\n    forbiddenNameValidator(/bob/i)\n  ]\n],\n\n</code-example>\n<p>In the Template Driven example, the <code>&#x3C;input></code> has the selector (<code>forbiddenName</code>)\nof a custom <em>attribute directive</em>, which rejects \"bob\".</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template2.component.html\" region=\"name-input\" title=\"template/hero-form-template2.component.html (name input)\" linenums=\"false\">\n&#x3C;input type=\"text\" id=\"name\" class=\"form-control\"\n       required minlength=\"4\" maxlength=\"24\" forbiddenName=\"bob\"\n       name=\"name\" [(ngModel)]=\"hero.name\" >\n\n</code-example>\n<p>The corresponding <code>ForbiddenValidatorDirective</code> is a wrapper around the <code>forbiddenNameValidator</code>.</p>\n<p>Angular <code>forms</code> recognizes the directive's role in the validation process because the directive registers itself\nwith the <code><a href=\"api/forms/NG_VALIDATORS\">NG_VALIDATORS</a></code> provider, a provider with an extensible collection of validation directives.</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive-providers\" title=\"shared/forbidden-name.directive.ts (providers)\" linenums=\"false\">\nproviders: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}]\n\n</code-example>\n<p>Here is the rest of the directive to help you get an idea of how it all comes together:</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive\" title=\"shared/forbidden-name.directive.ts (directive)\">\n@Directive({\n  selector: '[forbiddenName]',\n  providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}]\n})\nexport class ForbiddenValidatorDirective implements Validator, OnChanges {\n  @Input() forbiddenName: string;\n  private valFn = Validators.nullValidator;\n\n  ngOnChanges(changes: SimpleChanges): void {\n    const change = changes['forbiddenName'];\n    if (change) {\n      const val: string | RegExp = change.currentValue;\n      const re = val instanceof RegExp ? val : new RegExp(val, 'i');\n      this.valFn = forbiddenNameValidator(re);\n    } else {\n      this.valFn = Validators.nullValidator;\n    }\n  }\n\n  validate(control: AbstractControl): {[key: string]: any} {\n    return this.valFn(control);\n  }\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>If you are familiar with Angular validations, you may have noticed\nthat the custom validation directive is instantiated with <code>useExisting</code>\nrather than <code>useClass</code>. The registered validator must be <em>this instance</em> of\nthe <code>ForbiddenValidatorDirective</code>—the instance in the form with\nits <code>forbiddenName</code> property bound to “bob\". If you were to replace\n<code>useExisting</code> with <code>useClass</code>, then you’d be registering a new class instance, one that\ndoesn’t have a <code>forbiddenName</code>.</p>\n<p>To see this in action, run the example and then type “bob” in the name of Hero Form 2.\nNotice that you get a validation error. Now change from <code>useExisting</code> to <code>useClass</code> and try again.\nThis time, when you type “bob”, there's no \"bob\" error message.</p>\n</div>\n<div class=\"l-sub-section\">\n<p>For more information on attaching behavior to elements,\nsee <a href=\"guide/attribute-directives\">Attribute Directives</a>.</p>\n</div>\n<h2 id=\"testing-considerations\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#testing-considerations\"><i class=\"material-icons\">link</i></a>Testing Considerations</h2>\n<p>You can write <em>isolated unit tests</em> of validation and control logic in Reactive Forms.</p>\n<p><em>Isolated unit tests</em> probe the component class directly, independent of its\ninteractions with its template, the DOM, other dependencies, or Angular itself.</p>\n<p>Such tests have minimal setup, are quick to write, and easy to maintain.\nThey do not require the <code>Angular TestBed</code> or asynchronous testing practices.</p>\n<p>That's not possible with Template Driven forms.\nThe Template Driven approach relies on Angular to produce the control model and\nto derive validation rules from the HTML validation attributes.\nYou must use the <code>Angular TestBed</code> to create component test instances,\nwrite asynchronous tests, and interact with the DOM.</p>\n<p>While not difficult, this takes more time, work and\nskill—factors that tend to diminish test code\ncoverage and quality.</p>\n\n</div>"
}