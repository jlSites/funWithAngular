{
  "id": "guide/ngmodule-faq",
  "title": "NgModule FAQs",
  "contents": "\n<div class=\"content\">\n<h1 id=\"ngmodule-faqs\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#ngmodule-faqs\"><i class=\"material-icons\">link</i></a>NgModule FAQs</h1>\n<p>NgModules help organize an application into cohesive blocks of functionality.</p>\n<p>The <a href=\"guide/ngmodule\">NgModules</a> page guides you\nfrom the most elementary <code>@NgModule</code> to a multi-faceted sample with lazy-loaded modules.</p>\n<p>This page answers the questions many developers ask about NgModule design and implementation.</p>\n<div class=\"alert is-important\">\n<p>These FAQs assume that you have read the <a href=\"guide/ngmodule\">NgModules</a> page.</p>\n</div>\n<a id=\"q-what-to-declare\"></a>\n<h2 id=\"what-classes-should-i-add-to-declarations\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-add-to-declarations\"><i class=\"material-icons\">link</i></a>What classes should I add to <em>declarations</em>?</h2>\n<p>Add <a href=\"guide/ngmodule-faq#q-declarable\">declarable</a> classes—components, directives, and pipes—to a <code>declarations</code> list.</p>\n<p>Declare these classes in <em>exactly one</em> module of the application.\nDeclare them in <em>this</em> module if they <em>belong</em> to this module.</p>\n<hr>\n<a id=\"q-declarable\"></a>\n<h2 id=\"what-is-a-declarable\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-a-declarable\"><i class=\"material-icons\">link</i></a>What is a <em>declarable</em>?</h2>\n<p>Declarables are the class types—components, directives, and pipes—that\nyou can add to a module's <code>declarations</code> list.\nThey're the <em>only</em> classes that you can add to <code>declarations</code>.</p>\n<hr>\n<a id=\"q-what-not-to-declare\"></a>\n<h2 id=\"what-classes-should-i-not-add-to-declarations\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\"><i class=\"material-icons\">link</i></a>What classes should I <em>not</em> add to <em>declarations</em>?</h2>\n<p>Add only <a href=\"guide/ngmodule-faq#q-declarable\">declarable</a> classes to a module's <code>declarations</code> list.</p>\n<p>Do <em>not</em> declare the following:</p>\n<ul>\n<li>A class that's already declared in another module, whether an app module, @NgModule, or third-party module.</li>\n<li>An array of directives imported from another module.\nFor example, don't declare FORMS_DIRECTIVES from <code>@angular/forms</code>.</li>\n<li>Module classes.</li>\n<li>Service classes.</li>\n<li>Non-Angular classes and objects, such as\nstrings, numbers, functions, entity models, configurations, business logic, and helper classes.</li>\n</ul>\n<hr>\n<a id=\"q-why-multiple-mentions\"></a>\n<h2 id=\"why-list-the-same-component-in-multiple-ngmodule-properties\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-list-the-same-component-in-multiple-ngmodule-properties\"><i class=\"material-icons\">link</i></a>Why list the same component in multiple <em>NgModule</em> properties?</h2>\n<p><code>AppComponent</code> is often listed in both <code>declarations</code> and <code>bootstrap</code>.\nYou might see <code>HeroComponent</code> listed in <code>declarations</code>, <code>exports</code>, and <code>entryComponents</code>.</p>\n<p>While that seems redundant, these properties have different functions.\nMembership in one list doesn't imply membership in another list.</p>\n<ul>\n<li><code>AppComponent</code> could be declared in this module but not bootstrapped.</li>\n<li><code>AppComponent</code> could be bootstrapped in this module but declared in a different feature module.</li>\n<li><code>HeroComponent</code> could be imported from another app module (so you can't declare it) and re-exported by this module.</li>\n<li><code>HeroComponent</code> could be exported for inclusion in an external component's template\nas well as dynamically loaded in a pop-up dialog.</li>\n</ul>\n<hr>\n<a id=\"q-why-cant-bind-to\"></a>\n<h2 id=\"what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\"><i class=\"material-icons\">link</i></a>What does \"Can't bind to 'x' since it isn't a known property of 'y'\" mean?</h2>\n<p>This error usually means that you haven't declared the directive \"x\"\nor haven't imported the module to which \"x\" belongs.</p>\n<p>For example, if \"x\" is <code>ngModel</code>, you probably haven't imported the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> from <code>@angular/forms</code>.</p>\n<p>Perhaps you declared \"x\" in an application sub-module but forgot to export it?\nThe \"x\" class isn't visible to other modules until you add it to the <code>exports</code> list.</p>\n<hr>\n<a id=\"q-what-to-import\"></a>\n<h2 id=\"what-should-i-import\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-import\"><i class=\"material-icons\">link</i></a>What should I import?</h2>\n<p>Import modules whose public (exported) <a href=\"guide/ngmodule-faq#q-declarable\">declarable classes</a>\nyou need to reference in this module's component templates.</p>\n<p>This always means importing <code><a href=\"api/common/CommonModule\">CommonModule</a></code> from <code>@angular/common</code> for access to\nthe Angular directives such as <code><a href=\"api/common/NgIf\">NgIf</a></code> and <code><a href=\"api/common/NgFor\">NgFor</a></code>.\nYou can import it directly or from another module that <a href=\"guide/ngmodule-faq#q-reexport\">re-exports</a> it.</p>\n<p>Import <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> from <code>@angular/forms</code>\nif your components have <code>[(ngModel)]</code> two-way binding expressions.</p>\n<p>Import <em>shared</em> and <em>feature</em> modules when this module's components incorporate their\ncomponents, directives, and pipes.</p>\n<p>Import only <a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">BrowserModule</a> in the root <code>AppModule</code>.</p>\n<hr>\n<a id=\"q-browser-vs-common-module\"></a>\n<h2 id=\"should-i-import-browsermodule-or-commonmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-import-browsermodule-or-commonmodule\"><i class=\"material-icons\">link</i></a>Should I import <em>BrowserModule</em> or <em>CommonModule</em>?</h2>\n<p>The <em>root application module</em> (<code>AppModule</code>) of almost every browser application\nshould import <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> from <code>@angular/platform-browser</code>.</p>\n<p><code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> provides services that are essential to launch and run a browser app.</p>\n<p><code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> also re-exports <code><a href=\"api/common/CommonModule\">CommonModule</a></code> from <code>@angular/common</code>,\nwhich means that components in the <code>AppModule</code> module also have access to\nthe Angular directives every app needs, such as <code><a href=\"api/common/NgIf\">NgIf</a></code> and <code><a href=\"api/common/NgFor\">NgFor</a></code>.</p>\n<p><em>Do not import</em> <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> in any other module.\n<em>Feature modules</em> and <em>lazy-loaded modules</em> should import <code><a href=\"api/common/CommonModule\">CommonModule</a></code> instead.\nThey need the common directives. They don't need to re-install the app-wide providers.</p>\n<div class=\"l-sub-section\">\n<p><code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> throws an error if you try to lazy load  a module that imports it.</p>\n</div>\n<p>Importing <code><a href=\"api/common/CommonModule\">CommonModule</a></code> also frees feature modules for use on <em>any</em> target platform, not just browsers.</p>\n<hr>\n<a id=\"q-reimport\"></a>\n<h2 id=\"what-if-i-import-the-same-module-twice\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-i-import-the-same-module-twice\"><i class=\"material-icons\">link</i></a>What if I import the same module twice?</h2>\n<p>That's not a problem. When three modules all import Module 'A',\nAngular evaluates Module 'A' once, the first time it encounters it, and doesn't do so again.</p>\n<p>That's true at whatever level <code>A</code> appears in a hierarchy of imported modules.\nWhen Module 'B' imports Module 'A', Module 'C' imports 'B', and Module 'D' imports <code>[C, B, A]</code>,\nthen 'D' triggers the evaluation of 'C', which triggers the evaluation of 'B', which evaluates 'A'.\nWhen Angular gets to the 'B' and 'A' in 'D', they're already cached and ready to go.</p>\n<p>Angular doesn't like modules with circular references, so don't let Module 'A' import Module 'B', which imports Module 'A'.</p>\n<hr>\n<a id=\"q-what-to-export\"></a>\n<h2 id=\"what-should-i-export\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-export\"><i class=\"material-icons\">link</i></a>What should I export?</h2>\n<p>Export <a href=\"guide/ngmodule-faq#q-declarable\">declarable</a> classes that components in <em>other</em> modules\nare able to reference in their templates. These are your <em>public</em> classes.\nIf you don't export a class, it stays <em>private</em>, visible only to other component\ndeclared in this module.</p>\n<p>You <em>can</em> export any declarable class—components, directives, and pipes—whether\nit's declared in this module or in an imported module.</p>\n<p>You <em>can</em> re-export entire imported modules, which effectively re-exports all of their exported classes.\nA module can even export a module that it doesn't import.</p>\n<hr>\n<a id=\"q-what-not-to-export\"></a>\n<h2 id=\"what-should-i-not-export\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-should-i-not-export\"><i class=\"material-icons\">link</i></a>What should I <em>not</em> export?</h2>\n<p>Don't export the following:</p>\n<ul>\n<li>Private components, directives, and pipes that you need only within components declared in this module.\nIf you don't want another module to see it, don't export it.</li>\n<li>Non-declarable objects such as services, functions, configurations, and entity models.</li>\n<li>Components that are only loaded dynamically by the router or by bootstrapping.\nSuch <a href=\"guide/ngmodule-faq#q-entry-component-defined\">entry components</a> can never be selected in another component's template.\nWhile there's no harm in exporting them, there's also no benefit.</li>\n<li>Pure service modules that don't have public (exported) declarations.\nFor example, there's no point in re-exporting <code><a href=\"api/http/HttpModule\">HttpModule</a></code> because it doesn't export anything.\nIt's only purpose is to add http service providers to the application as a whole.</li>\n</ul>\n<hr>\n<a id=\"q-reexport\"></a>\n<a id=\"q-re-export\"></a>\n<h2 id=\"can-i-re-export-classes-and-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#can-i-re-export-classes-and-modules\"><i class=\"material-icons\">link</i></a>Can I re-export classes and modules?</h2>\n<p>Absolutely.</p>\n<p>Modules are a great way to selectively aggregate classes from other modules and\nre-export them in a consolidated, convenience module.</p>\n<p>A module can re-export entire modules, which effectively re-exports all of their exported classes.\nAngular's own <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> exports a couple of modules like this:</p>\n<code-example>\n  exports: [CommonModule, ApplicationModule]\n\n</code-example>\n<p>A module can export a combination of its own declarations, selected imported classes, and imported modules.</p>\n<div class=\"l-sub-section\">\n<p>Don't bother re-exporting pure service modules.\nPure service modules don't export <a href=\"guide/ngmodule-faq#q-declarable\">declarable</a> classes that another module could use.\nFor example, there's no point in re-exporting <code><a href=\"api/http/HttpModule\">HttpModule</a></code> because it doesn't export anything.\nIt's only purpose is to add http service providers to the application as a whole.</p>\n</div>\n<hr>\n<a id=\"q-for-root\"></a>\n<h2 id=\"what-is-the-forroot-method\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-forroot-method\"><i class=\"material-icons\">link</i></a>What is the <em>forRoot</em> method?</h2>\n<p>The <code>forRoot</code> static method is a convention that makes it easy for developers to configure the module's providers.</p>\n<p>The <code>RouterModule.forRoot</code> method is a good example.\nApps pass a <code><a href=\"api/router/Routes\">Routes</a></code> object to <code>RouterModule.forRoot</code> in order to configure the app-wide <code><a href=\"api/router/Router\">Router</a></code> service with routes.\n<code>RouterModule.forRoot</code> returns a <a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>.\nYou add that result to the <code>imports</code> list of the root <code>AppModule</code>.</p>\n<div class=\"alert is-important\">\n<p>Only call and import a <code>.forRoot</code> result in the root application module, <code>AppModule</code>.\nImporting it in any other module, particularly in a lazy-loaded module,\nis contrary to the intent and will likely produce a runtime error.</p>\n</div>\n<p><code><a href=\"api/router/RouterModule\">RouterModule</a></code> also offers a <code>forChild</code> static method for configuring the routes of lazy-loaded modules.</p>\n<p><em>forRoot</em> and <em>forChild</em> are conventional names for methods that\nconfigure services in root and feature modules respectively.</p>\n<p>Angular doesn't recognize these names but Angular developers do.\nFollow this convention when you write similar modules with configurable service providers.</p>\n<hr>\n<a id=\"q-module-provider-visibility\"></a>\n<h2 id=\"why-is-a-service-provided-in-a-feature-module-visible-everywhere\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\"><i class=\"material-icons\">link</i></a>Why is a service provided in a feature module visible everywhere?</h2>\n<p>Providers listed in the <code>@NgModule.providers</code> of a bootstrapped module have <em>application scope</em>.\nAdding a service provider to <code>@NgModule.providers</code> effectively publishes the service to the entire application.</p>\n<p>When you import a module,\nAngular adds the module's service providers (the contents of its <code>providers</code> list)\nto the application <em>root injector</em>.</p>\n<p>This makes the provider visible to every class in the application that knows the provider's lookup token.</p>\n<p>This is by design.\nExtensibility through module imports is a primary goal of the NgModule system.\nMerging module providers into the application injector\nmakes it easy for a module library to enrich the entire application with new services.\nBy adding the <code><a href=\"api/http/HttpModule\">HttpModule</a></code> once, every application component can make http requests.</p>\n<p>However, this might feel like an unwelcome surprise if you expect the module's services\nto be visible only to the components declared by that feature module.\nIf the <code>HeroModule</code> provides the <code>HeroService</code> and the root <code>AppModule</code> imports <code>HeroModule</code>,\nany class that knows the <code>HeroService</code> <em>type</em> can inject that service,\nnot just the classes declared in the <code>HeroModule</code>.</p>\n<hr>\n<a id=\"q-lazy-loaded-module-provider-visibility\"></a>\n<h2 id=\"why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\"><i class=\"material-icons\">link</i></a>Why is a service provided in a <em>lazy-loaded</em> module visible only to that module?</h2>\n<p>Unlike providers of the modules loaded at launch,\nproviders of lazy-loaded modules are <em>module-scoped</em>.</p>\n<p>When the Angular router lazy-loads a module, it creates a new execution context.\nThat <a href=\"guide/ngmodule-faq#q-why-child-injector\" title=\"Why Angular creates a child injector\">context has its own injector</a>,\nwhich is a direct child of the application injector.</p>\n<p>The router adds the lazy module's providers and the providers of its imported modules to this child injector.</p>\n<p>These providers are insulated from changes to application providers with the same lookup token.\nWhen the router creates a component within the lazy-loaded context,\nAngular prefers service instances created from these providers to the service instances of the application root injector.</p>\n<hr>\n<a id=\"q-module-provider-duplicates\"></a>\n<h2 id=\"what-if-two-modules-provide-the-same-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\"><i class=\"material-icons\">link</i></a>What if two modules provide the same service?</h2>\n<p>When two imported modules, loaded at the same time, list a provider with the same token,\nthe second module's provider \"wins\". That's because both providers are added to the same injector.</p>\n<p>When Angular looks to inject a service for that token,\nit creates and delivers the instance created by the second provider.</p>\n<p><em>Every</em> class that injects this service gets the instance created by the second provider.\nEven classes declared within the first module get the instance created by the second provider.</p>\n<p>If Module A provides a service for token 'X' and imports a module B\nthat also provides a service for token 'X', then Module A's service definition \"wins\".</p>\n<p>The service provided by the root <code>AppModule</code> takes precedence over services provided by imported modules.\nThe <code>AppModule</code> always wins.</p>\n<hr>\n<a id=\"q-component-scoped-providers\"></a>\n<h2 id=\"how-do-i-restrict-service-scope-to-a-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\"><i class=\"material-icons\">link</i></a>How do I restrict service scope to a module?</h2>\n<p>When a module is loaded at application launch,\nits <code>@NgModule.providers</code> have <em>application-wide scope</em>;\nthat is, they are available for injection throughout the application.</p>\n<p>Imported providers are easily replaced by providers from another imported module.\nSuch replacement might be by design. It could be unintentional and have adverse consequences.</p>\n<div class=\"alert is-important\">\n<p>As a general rule, import modules with providers <em>exactly once</em>, preferably in the application's <em>root module</em>.\nThat's also usually the best place to configure, wrap, and override them.</p>\n</div>\n<p>Suppose a module requires a customized <code><a href=\"api/common/http/HttpBackend\">HttpBackend</a></code> that adds a special header for all Http requests.\nIf another module elsewhere in the application also customizes <code><a href=\"api/common/http/HttpBackend\">HttpBackend</a></code>\nor merely imports the <code><a href=\"api/http/HttpModule\">HttpModule</a></code>, it could override this module's <code><a href=\"api/common/http/HttpBackend\">HttpBackend</a></code> provider,\nlosing the special header. The server will reject http requests from this module.</p>\n<p>To avoid this problem, import the <code><a href=\"api/http/HttpModule\">HttpModule</a></code> only in the <code>AppModule</code>, the application <em>root module</em>.</p>\n<p>If you must guard against this kind of \"provider corruption\", <em>don't rely on a launch-time module's <code>providers</code>.</em></p>\n<p>Load the module lazily if you can.\nAngular gives a <a href=\"guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\">lazy-loaded module</a> its own child injector.\nThe module's providers are visible only within the component tree created with this injector.</p>\n<p>If you must load the module eagerly, when the application starts,\n<em>provide the service in a component instead.</em></p>\n<p>Continuing with the same example, suppose the components of a module truly require a private, custom <code><a href=\"api/common/http/HttpBackend\">HttpBackend</a></code>.</p>\n<p>Create a \"top component\" that acts as the root for all of the module's components.\nAdd the custom <code><a href=\"api/common/http/HttpBackend\">HttpBackend</a></code> provider to the top component's <code>providers</code> list rather than the module's <code>providers</code>.\nRecall that Angular creates a child injector for each component instance and populates the injector\nwith the component's own providers.</p>\n<p>When a child of this component asks for the <code><a href=\"api/common/http/HttpBackend\">HttpBackend</a></code> service,\nAngular provides the local <code><a href=\"api/common/http/HttpBackend\">HttpBackend</a></code> service,\nnot the version provided in the application root injector.\nChild components make proper http requests no matter what other modules do to <code><a href=\"api/common/http/HttpBackend\">HttpBackend</a></code>.</p>\n<p>Be sure to create module components as children of this module's top component.</p>\n<p>You can embed the child components in the top component's template.\nAlternatively, make the top component a routing host by giving it a <code>&#x3C;router-outlet></code>.\nDefine child routes and let the router load module components into that outlet.</p>\n<hr>\n<a id=\"q-root-component-or-module\"></a>\n<h2 id=\"should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\"><i class=\"material-icons\">link</i></a>Should I add application-wide providers to the root <em>AppModule</em> or the root <em>AppComponent</em>?</h2>\n<p>Register application-wide providers in the root <code>AppModule</code>, not in the <code>AppComponent</code>.</p>\n<p>Lazy-loaded modules and their components can inject <code>AppModule</code> services;\nthey can't inject <code>AppComponent</code> services.</p>\n<p>Register a service in <code>AppComponent</code> providers <em>only</em> if the service must be hidden\nfrom components outside the <code>AppComponent</code> tree. This is a rare use case.</p>\n<p>More generally, <a href=\"guide/ngmodule-faq#q-component-or-module\">prefer registering providers in modules</a> to registering in components.</p>\n<h3 class=\"no-toc\" id=\"discussion\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#discussion\"><i class=\"material-icons\">link</i></a>Discussion</h3>\n<p>Angular registers all startup module providers with the application root injector.\nThe services created from root injector providers are available to the entire application.\nThey are <em>application-scoped</em>.</p>\n<p>Certain services (such as the <code><a href=\"api/router/Router\">Router</a></code>) only work when registered in the application root injector.</p>\n<p>By contrast, Angular registers <code>AppComponent</code> providers with the <code>AppComponent</code>'s own injector.\n<code>AppComponent</code> services are available only to that component and its component tree.\nThey are <em>component-scoped</em>.</p>\n<p>The <code>AppComponent</code>'s injector is a <em>child</em> of the root injector, one down in the injector hierarchy.\nFor applications that don't use the router, that's <em>almost</em> the entire application.\nBut for routed applications, \"almost\" isn't good enough.</p>\n<p><code>AppComponent</code> services don't exist at the root level where routing operates.\nLazy-loaded modules can't reach them.\nIn the NgModule page sample applications, if you had registered <code>UserService</code> in the <code>AppComponent</code>,\nthe <code>HeroComponent</code> couldn't inject it.\nThe application  would fail the moment a user navigated to \"Heroes\".</p>\n<hr>\n<a id=\"q-component-or-module\"></a>\n<h2 id=\"should-i-add-other-providers-to-a-module-or-a-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\"><i class=\"material-icons\">link</i></a>Should I add other providers to a module or a component?</h2>\n<p>In general, prefer registering feature-specific providers in modules (<code>@NgModule.providers</code>)\nto registering in components (<code>@Component.providers</code>).</p>\n<p>Register a provider with a component when you <em>must</em> limit the scope of a service instance\nto that component and its component tree.\nApply the same reasoning to registering a provider with a directive.</p>\n<p>For example, a hero editing component that needs a private copy of a caching hero service should register\nthe <code>HeroService</code> with the <code>HeroEditorComponent</code>.\nThen each new instance of the <code>HeroEditorComponent</code> gets its own cached service instance.\nThe changes that editor makes to heroes in its service don't touch the hero instances elsewhere in the application.</p>\n<p><a href=\"guide/ngmodule-faq#q-root-component-or-module\">Always register <em>application-wide</em> services with the root <code>AppModule</code></a>,\nnot the root <code>AppComponent</code>.</p>\n<hr>\n<a id=\"q-why-bad\"></a>\n<h2 id=\"why-is-it-bad-if-sharedmodule-provides-a-service-to-a-lazy-loaded-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-is-it-bad-if-sharedmodule-provides-a-service-to-a-lazy-loaded-module\"><i class=\"material-icons\">link</i></a>Why is it bad if <em>SharedModule</em> provides a service to a lazy-loaded module?</h2>\n<p>This question is addressed in the <a href=\"guide/ngmodule#no-shared-module-providers\">Why UserService isn't shared</a>\nsection of the <a href=\"guide/ngmodule\">NgModules</a> page,\nwhich discusses the importance of keeping providers out of the <code>SharedModule</code>.</p>\n<p>Suppose the <code>UserService</code> was listed in the module's <code>providers</code> (which it isn't).\nSuppose every module imports this <code>SharedModule</code> (which they all do).</p>\n<p>When the app starts, Angular eagerly loads the <code>AppModule</code> and the <code>ContactModule</code>.</p>\n<p>Both instances of the imported <code>SharedModule</code> would provide the <code>UserService</code>.\nAngular registers one of them in the root app injector (see <a href=\"guide/ngmodule-faq#q-reimport\">What if I import the same module twice?</a>).\nThen some component injects <code>UserService</code>, Angular finds it in the app root injector,\nand delivers the app-wide singleton <code>UserService</code>. No problem.</p>\n<p>Now consider the <code>HeroModule</code> <em>which is lazy loaded</em>.</p>\n<p>When the router lazy loads the <code>HeroModule</code>, it creates a child injector and registers the <code>UserService</code>\nprovider with that child injector. The child injector is <em>not</em> the root injector.</p>\n<p>When Angular creates a lazy <code>HeroComponent</code>, it must inject a <code>UserService</code>.\nThis time it finds a <code>UserService</code> provider in the lazy module's <em>child injector</em>\nand creates a <em>new</em> instance of the <code>UserService</code>.\nThis is an entirely different <code>UserService</code> instance\nthan the app-wide singleton version that Angular injected in one of the eagerly loaded components.</p>\n<p>That's almost certainly a mistake.</p>\n<div class=\"l-sub-section\">\n<p>To demonstrate, run the <live-example name=\"ngmodule\">live example</live-example>.\nModify the <code>SharedModule</code> so that it provides the <code>UserService</code> rather than the <code>CoreModule</code>.\nThen toggle between the \"Contact\" and \"Heroes\" links a few times.\nThe username goes bonkers as the Angular creates a new <code>UserService</code> instance each time.</p>\n<!-- CF: \"goes bonkers\" is jargon. Can you describe the behavior in plain English?  -->\n</div>\n<hr>\n<a id=\"q-why-child-injector\"></a>\n<h2 id=\"why-does-lazy-loading-create-a-child-injector\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\"><i class=\"material-icons\">link</i></a>Why does lazy loading create a child injector?</h2>\n<p>Angular adds <code>@NgModule.providers</code> to the application root injector, unless the module is lazy loaded.\nFor a lazy-loaded module, Angular creates a <em>child injector</em> and adds the module's providers to the child injector.</p>\n<p>This means that a module behaves differently depending on whether it's loaded during application start\nor lazy loaded later. Neglecting that difference can lead to <a href=\"guide/ngmodule-faq#q-why-bad\">adverse consequences</a>.</p>\n<p>Why doesn't Angular add lazy-loaded providers to the app root injector as it does for eagerly loaded modules?</p>\n<p>The answer is grounded in a fundamental characteristic of the Angular dependency-injection system.\nAn injector can add providers <em>until it's first used</em>.\nOnce an injector starts creating and delivering services, its provider list is frozen; no new providers are allowed.</p>\n<p>When an applications starts, Angular first configures the root injector with the providers of all eagerly loaded modules\n<em>before</em> creating its first component and injecting any of the provided services.\nOnce the application begins, the app root injector is closed to new providers.</p>\n<p>Time passes and application logic triggers lazy loading of a module.\nAngular must add the lazy-loaded module's providers to an injector somewhere.\nIt can't added them to the app root injector because that injector is closed to new providers.\nSo Angular creates a new child injector for the lazy-loaded module context.</p>\n<hr>\n<a id=\"q-is-it-loaded\"></a>\n<h2 id=\"how-can-i-tell-if-a-module-or-service-was-previously-loaded\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-can-i-tell-if-a-module-or-service-was-previously-loaded\"><i class=\"material-icons\">link</i></a>How can I tell if a module or service was previously loaded?</h2>\n<p>Some modules and their services should be loaded only once by the root <code>AppModule</code>.\nImporting the module a second time by lazy loading a module could <a href=\"guide/ngmodule-faq#q-why-bad\">produce errant behavior</a>\nthat may be difficult to detect and diagnose.</p>\n<p>To prevent this issue, write a constructor that attempts to inject the module or service\nfrom the root app injector. If the injection succeeds, the class has been loaded a second time.\nYou can throw an error or take other remedial action.</p>\n<p>Certain NgModules (such as <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code>) implement such a guard,\nsuch as this <code>CoreModule</code> constructor from the NgModules page.</p>\n<code-example path=\"ngmodule/src/app/core/core.module.ts\" region=\"ctor\" title=\"src/app/core/core.module.ts (Constructor)\" linenums=\"false\">\nconstructor (@Optional() @SkipSelf() parentModule: CoreModule) {\n  if (parentModule) {\n    throw new Error(\n      'CoreModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<hr>\n<a id=\"q-entry-component-defined\"></a>\n<h2 id=\"what-is-an-entry-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-an-entry-component\"><i class=\"material-icons\">link</i></a>What is an <em>entry component</em>?</h2>\n<p>An entry component is any component that Angular loads <em>imperatively</em> by type.</p>\n<p>A component loaded <em>declaratively</em> via its selector is <em>not</em> an entry component.</p>\n<p>Most application components are loaded declaratively.\nAngular uses the component's selector to locate the element in the template.\nIt then creates the HTML representation of the component and inserts it into the DOM at the selected element.\nThese aren't entry components.</p>\n<p>A few components are only loaded dynamically and are <em>never</em> referenced in a component template.</p>\n<p>The bootstrapped root <code>AppComponent</code> is an <em>entry component</em>.\nTrue, its selector matches an element tag in <code>index.html</code>.\nBut <code>index.html</code> isn't a component template and the <code>AppComponent</code>\nselector doesn't match an element in any component template.</p>\n<p>Angular loads <code>AppComponent</code> dynamically because it's either listed <em>by type</em> in <code>@NgModule.bootstrap</code>\nor boostrapped imperatively with the module's <code>ngDoBootstrap</code> method.</p>\n<p>Components in route definitions are also <em>entry components</em>.\nA route definition refers to a component by its <em>type</em>.\nThe router ignores a routed component's selector (if it even has one) and\nloads the component dynamically into a <code><a href=\"api/router/RouterOutlet\">RouterOutlet</a></code>.</p>\n<p>The compiler can't discover these <em>entry components</em> by looking for them in other component templates.\nYou must tell it about them by adding them to the <code>entryComponents</code> list.</p>\n<p>Angular automatically adds the following types of components to the module's <code>entryComponents</code>:</p>\n<ul>\n<li>The component in the <code>@NgModule.bootstrap</code> list.</li>\n<li>Components referenced in router configuration.</li>\n</ul>\n<p>You don't have to mention these components explicitly, although doing so is harmless.</p>\n<hr>\n<a id=\"q-bootstrap_vs_entry_component\"></a>\n<h2 id=\"whats-the-difference-between-a-bootstrap-component-and-an-entry-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#whats-the-difference-between-a-bootstrap-component-and-an-entry-component\"><i class=\"material-icons\">link</i></a>What's the difference between a <em>bootstrap</em> component and an <em>entry component</em>?</h2>\n<p>A bootstrapped component <em>is</em> an <a href=\"guide/ngmodule-faq#q-entry-component-defined\">entry component</a>\nthat Angular loads into the DOM during the bootstrap (application launch) process.\nOther entry components are loaded dynamically by other means, such as with the router.</p>\n<p>The <code>@NgModule.bootstrap</code> property tells the compiler that this is an entry component <em>and</em>\nit should generate code to bootstrap the application with this component.</p>\n<p>There's no need to list a component in both the <code>bootstrap</code> and <code>entryComponent</code> lists,\nalthough doing so is harmless.</p>\n<hr>\n<a id=\"q-when-entry-components\"></a>\n<h2 id=\"when-do-i-add-components-to-entrycomponents\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#when-do-i-add-components-to-entrycomponents\"><i class=\"material-icons\">link</i></a>When do I add components to <em>entryComponents</em>?</h2>\n<p>Most application developers won't need to add components to the <code>entryComponents</code>.</p>\n<p>Angular adds certain components to <em>entry components</em> automatically.\nComponents listed in <code>@NgModule.bootstrap</code> are added automatically.\nComponents referenced in router configuration are added automatically.\nThese two mechanisms account for almost all entry components.</p>\n<p>If your app happens to bootstrap or dynamically load a component <em>by type</em> in some other manner,\nyou must add it to <code>entryComponents</code> explicitly.</p>\n<p>Although it's harmless to add components to this list,\nit's best to add only the components that are truly <em>entry components</em>.\nDon't include components that <a href=\"guide/ngmodule-faq#q-template-reference\">are referenced</a>\nin the templates of other components.</p>\n<hr>\n<a id=\"q-why-entry-components\"></a>\n<h2 id=\"why-does-angular-need-entrycomponents\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#why-does-angular-need-entrycomponents\"><i class=\"material-icons\">link</i></a>Why does Angular need <em>entryComponents</em>?</h2>\n<p><em>Entry components</em> are also declared.\nWhy doesn't the Angular compiler generate code for every component in <code>@NgModule.declarations</code>?\nThen you wouldn't need entry components.</p>\n<p>The reason is <em>tree shaking</em>. For production apps you want to load the smallest, fastest code possible.\nThe code should contain only the classes that you actually need.\nIt should exclude a component that's never used, whether or not that component is declared.</p>\n<p>In fact, many libraries declare and export components you'll never use.\nIf you don't reference them, the tree shaker drops these components from the final code package.</p>\n<p>If the <a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular compiler</a> generated code for every declared component,\nit would defeat the purpose of the tree shaker.</p>\n<p>Instead, the compiler adopts a recursive strategy that generates code only for the components you use.</p>\n<p>The compiler starts with the entry components,\nthen it generates code for the declared components it <a href=\"guide/ngmodule-faq#q-template-reference\">finds</a> in an entry component's template,\nthen for the declared components it discovers in the templates of previously compiled components,\nand so on. At the end of the process, the compiler has generated code for every  entry component\nand every component reachable from an entry component.</p>\n<p>If a component isn't an <em>entry component</em> or wasn't found in a template,\nthe compiler omits it.</p>\n<hr>\n<a id=\"q-module-recommendations\"></a>\n<h2 id=\"what-kinds-of-modules-should-i-have-and-how-should-i-use-them\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\"><i class=\"material-icons\">link</i></a>What kinds of modules should I have and how should I use them?</h2>\n<p>Every app is different. Developers have various levels of experience and comfort with the available choices.\nSome suggestions and guidelines appear to have wide appeal.</p>\n<div class=\"alert is-important\">\n<p>The following is preliminary guidance based on early experience using NgModules in a few applications.\nRead with appropriate caution and reflection.</p>\n</div>\n<h3 id=\"sharedmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#sharedmodule\"><i class=\"material-icons\">link</i></a><em>SharedModule</em></h3>\n<p>Create a <code>SharedModule</code> with the components, directives, and pipes that you use\neverywhere in your app. This module should consist entirely of <code>declarations</code>,\nmost of them exported.</p>\n<p>The <code>SharedModule</code> may re-export other <a href=\"guide/ngmodule-faq#widget-feature-module\">widget modules</a>, such as <code><a href=\"api/common/CommonModule\">CommonModule</a></code>,\n<code><a href=\"api/forms/FormsModule\">FormsModule</a></code>, and modules with the UI controls that you use most widely.</p>\n<p>The <code>SharedModule</code> should <em>not</em> have <code>providers</code> for reasons <a href=\"guide/ngmodule-faq#q-why-bad\">explained previously</a>.\nNor should any of its imported or re-exported modules have <code>providers</code>.\nIf you deviate from this guideline, know what you're doing and why.</p>\n<p>Import the <code>SharedModule</code> in your <em>feature</em> modules,\nboth those loaded when the app starts and those you lazy load later.</p>\n<h3 id=\"coremodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#coremodule\"><i class=\"material-icons\">link</i></a><em>CoreModule</em></h3>\n<p>Create a <code>CoreModule</code> with <code>providers</code> for the singleton services you load when the application starts.</p>\n<p>Import <code>CoreModule</code> in the root <code>AppModule</code> only.\nNever import <code>CoreModule</code> in any other module.</p>\n<p>Consider making <code>CoreModule</code> a <a href=\"guide/ngmodule-faq#service-feature-module\">pure services module</a> with no <code>declarations</code>.</p>\n<div class=\"l-sub-section\">\n<p>This page sample departs from that advice by declaring and exporting two components that are\nonly used within the root <code>AppComponent</code> declared by <code>AppModule</code>.\nSomeone following this guideline strictly would have declared these components in the <code>AppModule</code> instead.</p>\n</div>\n<h3 id=\"feature-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#feature-modules\"><i class=\"material-icons\">link</i></a>Feature Modules</h3>\n<p>Create feature modules around specific application business domains, user workflows, and utility collections.</p>\n<p>Feature modules tend to fall into one of the following groups:</p>\n<ul>\n<li><a href=\"guide/ngmodule-faq#domain-feature-module\">Domain feature modules</a>.</li>\n<li><a href=\"guide/ngmodule-faq#routed-feature-module\">Routed feature modules</a>.</li>\n<li><a href=\"guide/ngmodule-faq#routing-module\">Routing modules</a>.</li>\n<li><a href=\"guide/ngmodule-faq#service-feature-module\">Service feature modules</a>.</li>\n<li><a href=\"guide/ngmodule-faq#widget-feature-module\">Widget feature modules</a>.</li>\n</ul>\n<div class=\"l-sub-section\">\n<p>Real-world modules are often hybrids that purposefully deviate from the following guidelines.\nThese guidelines are not laws;\nfollow them unless you have a good reason to do otherwise.</p>\n</div>\n<table>\n  <tbody><tr>\n    <th style=\"vertical-align: top\">\n      Feature Module\n    </th>\n    <th style=\"vertical-align: top\">\n      Guidelines\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"domain-feature-module\"></a>Domain\n    </td>\n    <td>\n<p>      Domain feature modules deliver a user experience <em>dedicated to a particular application domain</em>\nlike editing a customer or placing an order.</p>\n<p>      They typically have a top component that acts as the feature root.\nPrivate, supporting sub-components descend from it.</p>\n<p>      Domain feature modules consist mostly of <em>declarations</em>.\nOnly the top component is exported.</p>\n<p>      Domain feature modules rarely have <em>providers</em>.\nWhen they do, the lifetime of the provided services\nshould be the same as the lifetime of the module.</p>\n<p>      Don't provide application-wide singleton services in a domain feature module.</p>\n<p>      Domain feature modules are typically imported <em>exactly once</em> by a larger feature module.</p>\n<p>      They might be imported by the root <code>AppModule</code> of a small application that lacks routing.</p>\n<div class=\"l-sub-section\">\n<p>      For an example, see the <a href=\"guide/ngmodule#contact-module-v1\">Make <em>Contact</em> a feature module</a>\nsection of the <a href=\"guide/ngmodule\">NgModules</a> page, before routing is introduced.      </p>\n</div>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"routed-feature-module\"></a>Routed\n    </td>\n    <td>\n<p>      <em>Routed feature modules</em> are <em>domain feature modules</em>\nwhose top components are the <em>targets of router navigation routes</em>.</p>\n<p>      All lazy-loaded modules are routed feature modules by definition.</p>\n<p>      This page's <code>ContactModule</code>, <code>HeroModule</code>, and <code>CrisisModule</code> are routed feature modules.</p>\n<p>      Routed feature modules <em>shouldn't export anything</em>.\nThey don't have to because their components never appear in the template of an external component.</p>\n<p>      A lazy-loaded routed feature module should <em>not be imported</em> by any module.\nDoing so would trigger an eager load, defeating the purpose of lazy loading.\n<code>HeroModule</code> and <code>CrisisModule</code> are lazy loaded. They aren't mentioned among the <code>AppModule</code> imports.</p>\n<p>      But an eager loaded routed feature module must be imported by another module\nso that the compiler learns about its components.\n<code>ContactModule</code> is eager loaded and therefore listed among the <code>AppModule</code> imports.</p>\n<p>      Routed Feature Modules rarely have <em>providers</em> for reasons <a href=\"guide/ngmodule-faq#q-why-bad\">explained earlier</a>.\nWhen they do, the lifetime of the provided services\nshould be the same as the lifetime of the module.</p>\n<p>      Don't provide application-wide singleton services in a routed feature module\nor in a module that the routed module imports.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"routing-module\"></a>Routing\n    </td>\n    <td>\n<p>      A <a href=\"guide/router#routing-module\">routing module</a> <em>provides routing configuration</em> for another module.</p>\n<p>      A routing module separates routing concerns from its companion module.</p>\n<p>      A routing module typically does the following:</p>\n<p>      <em> Defines routes.\n</em> Adds router configuration to the module's <code>imports</code>.\n<em> Re-exports <code><a href=\"api/router/RouterModule\">RouterModule</a></code>.\n</em> Adds guard and resolver service providers to the module's <code>providers</code>.</p>\n<p>      The name of the routing module should parallel the name of its companion module, using the suffix \"Routing\".\nFor example, <code>FooModule</code> in <code>foo.module.ts</code> has a routing module named <code>FooRoutingModule</code>\nin <code>foo-routing.module.ts</code></p>\n<p>      If the companion module is the <em>root</em> <code>AppModule</code>,\nthe <code>AppRoutingModule</code> adds router configuration to its <code>imports</code> with <code>RouterModule.forRoot(routes)</code>.\nAll other routing modules are children that import <code>RouterModule.forChild(routes)</code>.</p>\n<p>      A routing module re-exports the <code><a href=\"api/router/RouterModule\">RouterModule</a></code> as a convenience\nso that components of the companion module have access to\nrouter directives such as <code><a href=\"api/router/RouterLink\">RouterLink</a></code> and <code><a href=\"api/router/RouterOutlet\">RouterOutlet</a></code>.</p>\n<p>      A routing module <em>should not have its own <code>declarations</code></em>.\nComponents, directives, and pipes are the <em>responsibility of the feature module</em>,\nnot the <em>routing</em> module.</p>\n<p>      A routing module should <em>only</em> be imported by its companion module.</p>\n<p>      The <code>AppRoutingModule</code>, <code>ContactRoutingModule</code>, and <code>HeroRoutingModule</code> are good examples.      </p>\n<div class=\"l-sub-section\">\n<p>      See also <a href=\"guide/router#why-routing-module\">Do you need a <em>Routing Module</em>?</a> on the\n<a href=\"guide/router\">Routing &#x26; Navigation</a> page.</p>\n</div>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"service-feature-module\"></a>Service\n    </td>\n    <td>\n<p>      Service modules <em>provide utility services</em> such as data access and messaging.</p>\n<p>      Ideally, they consist entirely of <em>providers</em> and have no <em>declarations</em>.\nThe <code>CoreModule</code> and Angular's <code><a href=\"api/http/HttpModule\">HttpModule</a></code> are good examples.</p>\n<p>      Service Modules should <em>only</em> be imported by the root <code>AppModule</code>.</p>\n<p>      Do <em>not</em> import service modules in other feature modules.\nIf you deviate from this guideline, know what you're doing and why.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"widget-feature-module\"></a>Widget\n    </td>\n    <td>\n<p>      A widget module makes <em>components, directives, and pipes</em> available to external modules.</p>\n<p>      <code><a href=\"api/common/CommonModule\">CommonModule</a></code> and <code>SharedModule</code> are widget modules.\nMany third-party UI component libraries are widget modules.</p>\n<p>      A widget module should consist entirely of <em>declarations</em>, most of them exported.</p>\n<p>      A widget module should rarely have <em>providers</em>.\nIf you deviate from this guideline, know what you're doing and why.</p>\n<p>      Import widget modules in any module whose component templates need the widgets.</p>\n    </td>\n  </tr>\n</tbody></table>\n<p>The following table summarizes the key characteristics of each <em>feature module</em> group.</p>\n<div class=\"l-sub-section\">\n<p>Real-world modules are often hybrids that knowingly deviate from these guidelines.</p>\n</div>\n<table>\n  <tbody><tr>\n    <th>\n      Feature Module\n    </th>\n    <th>\n      Declarations\n    </th>\n    <th>\n      Providers\n    </th>\n    <th>\n      Exports\n    </th>\n    <th>\n      Imported By\n    </th>\n    <th>\n      Examples\n    </th>\n  </tr>\n  <tr>\n    <td>\n      Domain\n    </td>\n    <td>\n      Yes\n    </td>\n    <td>\n      Rare\n    </td>\n    <td>\n      Top component\n    </td>\n    <td>\n      Feature, <code>AppModule</code>\n    </td>\n    <td>\n      <code>ContactModule</code> (before routing)\n    </td>\n  </tr>\n  <tr>\n    <td>\n      Routed\n    </td>\n    <td>\n      Yes\n    </td>\n    <td>\n      Rare\n    </td>\n    <td>\n      No\n    </td>\n    <td>\n      Nobody\n    </td>\n    <td>\n      <code>ContactModule</code>, <code>HeroModule</code>, <code>CrisisModule</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      Routing\n    </td>\n    <td>\n      No\n    </td>\n    <td>\n      Yes (Guards)\n    </td>\n    <td>\n      <code><a href=\"api/router/RouterModule\">RouterModule</a></code>\n    </td>\n    <td>\n      Feature (for routing)\n    </td>\n    <td>\n      <code>AppRoutingModule</code>, <code>ContactRoutingModule</code>, <code>HeroRoutingModule</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      Service\n    </td>\n    <td>\n      No\n    </td>\n    <td>\n      Yes\n    </td>\n    <td>\n      No\n    </td>\n    <td>\n      <code>AppModule</code>\n    </td>\n    <td>\n      <code><a href=\"api/http/HttpModule\">HttpModule</a></code>, <code>CoreModule</code>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      Widget\n    </td>\n    <td>\n      Yes\n    </td>\n    <td>\n      Rare\n    </td>\n    <td>\n      Yes\n    </td>\n    <td>\n      Feature\n    </td>\n    <td>\n      <code><a href=\"api/common/CommonModule\">CommonModule</a></code>, <code>SharedModule</code>\n    </td>\n  </tr>\n</tbody></table>\n<hr>\n<a id=\"q-ng-vs-js-modules\"></a>\n<h2 id=\"whats-the-difference-between-angular-and-javascript-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#whats-the-difference-between-angular-and-javascript-modules\"><i class=\"material-icons\">link</i></a>What's the difference between Angular and JavaScript Modules?</h2>\n<p>Angular and JavaScript are different yet complementary module systems.</p>\n<p>In modern JavaScript, every file is a <em>module</em>\n(see the <a href=\"http://exploringjs.com/es6/ch_modules.html\">Modules</a> page of the Exploring ES6 website).\nWithin each file you write an <code>export</code> statement to make parts of the module public:</p>\n<code-example format=\".\">\n  export class AppComponent { ... }\n\n</code-example>\n<p>Then you <code>import</code> a part in another module:</p>\n<code-example format=\".\">\n  import { AppComponent }  from './app.component';\n\n</code-example>\n<p>This kind of modularity is a feature of the <em>JavaScript language</em>.</p>\n<p>An <em>NgModule</em> is a feature of <em>Angular</em> itself.</p>\n<p>Angular's <code><a href=\"api/core/NgModule\">NgModule</a></code> also has <code>imports</code> and <code>exports</code> and they serve a similar purpose.</p>\n<p>You <em>import</em> other NgModules so you can use their exported classes in component templates.\nYou <em>export</em> this NgModule's classes so they can be imported and used by components of <em>other</em> modules.</p>\n<p>The NgModule classes differ from JavaScript module class in the following key ways:</p>\n<ul>\n<li>An NgModule bounds <a href=\"guide/ngmodule-faq#q-declarable\">declarable classes</a> only.\nDeclarables are the only classes that matter to the <a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular compiler</a>.</li>\n<li>Instead of defining all member classes in one giant file (as in a JavaScript module),\nyou list the module's classes in the <code>@NgModule.declarations</code> list.</li>\n<li>An NgModule can only export the <a href=\"guide/ngmodule-faq#q-declarable\">declarable classes</a>\nit owns or imports from other modules.\nIt doesn't declare or export any other kind of class.</li>\n</ul>\n<p>The NgModule is also special in another way.\nUnlike JavaScript modules, an NgModule can extend the <em>entire</em> application with services\nby adding providers to the <code>@NgModule.providers</code> list.</p>\n<!-- CF: Should this sentence be a bullet point in the list above? -->\n<div class=\"alert is-important\">\n<p>The provided services don't belong to the module nor are they scoped to the declared classes.\nThey are available <em>everywhere</em>.</p>\n</div>\n<p>Here's an <em>NgModule</em> class with imports, exports, and declarations.</p>\n<code-example path=\"ngmodule/src/app/contact/contact.module.2.ts\" region=\"class\" title=\"ngmodule/src/app/contact/contact.module.ts\" linenums=\"false\">\n@NgModule({\n  imports:      [ CommonModule, FormsModule ],\n  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],\n  exports:      [ ContactComponent ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n</code-example>\n<p>Of course you use <em>JavaScript</em> modules to write NgModules as seen in the complete <code>contact.module.ts</code> file:</p>\n<code-example path=\"ngmodule/src/app/contact/contact.module.2.ts\" title=\"src/app/contact/contact.module.ts\" linenums=\"false\">\nimport { NgModule }           from '@angular/core';\nimport { CommonModule }       from '@angular/common';\nimport { FormsModule }        from '@angular/forms';\n\nimport { AwesomePipe }        from './awesome.pipe';\n\nimport\n       { ContactComponent }   from './contact.component';\nimport { ContactService }     from './contact.service';\nimport { HighlightDirective } from './highlight.directive';\n\n@NgModule({\n  imports:      [ CommonModule, FormsModule ],\n  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],\n  exports:      [ ContactComponent ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n</code-example>\n<hr>\n<a id=\"q-template-reference\"></a>\n<h2 id=\"how-does-angular-find-components-directives-and-pipes-in-a-templatewhat-is-a-template-reference\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-templatewhat-is-a-template-reference\"><i class=\"material-icons\">link</i></a>How does Angular find components, directives, and pipes in a template?<br>What is a <i><b>template reference</b></i>?</h2>\n<p>The <a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular compiler</a> looks inside component templates\nfor other components, directives, and pipes. When it finds one, that's a \"template reference\".</p>\n<p>The Angular compiler finds a component or directive in a template when it can match the <em>selector</em> of that\ncomponent or directive to some HTML in that template.</p>\n<p>The compiler finds a pipe if the pipe's <em>name</em> appears within the pipe syntax of the template HTML.</p>\n<p>Angular only matches selectors and pipe names for classes that are declared by this module\nor exported by a module that this module imports.</p>\n<hr>\n<a id=\"q-angular-compiler\"></a>\n<h2 id=\"what-is-the-angular-compiler\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#what-is-the-angular-compiler\"><i class=\"material-icons\">link</i></a>What is the Angular compiler?</h2>\n<p>The Angular compiler converts the application code you write into highly performant JavaScript code.\nThe <code>@NgModule</code> metadata play an important role in guiding the compilation process.</p>\n<p>The code you write isn't immediately executable.\nConsider <em>components</em>.\nComponents have templates that contain custom elements, attribute directives, Angular binding declarations,\nand some peculiar syntax that clearly isn't native HTML.</p>\n<p>The Angular compiler reads the template markup,\ncombines it with the corresponding component class code, and emits <em>component factories</em>.</p>\n<p>A component factory creates a pure, 100% JavaScript representation\nof the component that incorporates everything described in its <code>@Component</code> metadata:\nthe HTML, the binding instructions, the attached styles.</p>\n<p>Because <em>directives</em> and <em>pipes</em> appear in component templates,\nthe Angular compiler incorporates them into compiled component code too.</p>\n<p><code>@NgModule</code> metadata tells the Angular compiler what components to compile for this module and\nhow to link this module with other modules.</p>\n<hr>\n<a id=\"q-ngmodule-api\"></a>\n<h2 id=\"ngmodule-api\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule-faq#ngmodule-api\"><i class=\"material-icons\">link</i></a>NgModule API</h2>\n<p>The following table summarizes the <code><a href=\"api/core/NgModule\">NgModule</a></code> metadata properties.</p>\n<table>\n  <tbody><tr>\n    <th>\n      Property\n    </th>\n    <th>\n      Description\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>declarations</code>\n    </td>\n    <td>\n<p>      A list of <a href=\"guide/ngmodule-faq#q-declarable\">declarable</a> classes,\nthe <em>component</em>, <em>directive</em>, and <em>pipe</em> classes that <em>belong to this module</em>.</p>\n<p>      These declared classes are visible within the module but invisible to\ncomponents in a different module unless they are <em>exported</em> from this module and\nthe other module <em>imports</em> this one.</p>\n<p>      Components, directives, and pipes must belong to <em>exactly</em> one module.\nThe compiler emits an error if you try to declare the same class in more than one module.</p>\n<p>      <em>Do not re-declare a class imported from another module.</em></p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>providers</code>\n    </td>\n    <td>\n<p>      A list of dependency-injection providers.</p>\n<p>      Angular registers these providers with the root injector of the module's execution context.\nThat's the application's root injector for all modules loaded when the application starts.</p>\n<p>      Angular can inject one of these provider services into any component in the application.\nIf this module or any module loaded at launch provides the <code>HeroService</code>,\nAngular can inject the same <code>HeroService</code> intance into any app component.</p>\n<p>      A lazy-loaded module has its own sub-root injector which typically\nis a direct child of the application root injector.</p>\n<p>      Lazy-loaded services are scoped to the lazy module's injector.\nIf a lazy-loaded module also provides the <code>HeroService</code>,\nany component created within that module's context (such as by router navigation)\ngets the local instance of the service, not the instance in the root application injector.</p>\n<p>      Components in external modules continue to receive the instance created for the application root.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>imports</code>\n    </td>\n    <td>\n<p>      A list of supporting modules.</p>\n<p>      Specifically, the list of modules whose exported components, directives, or pipes\nare referenced by the component templates declared in this module.</p>\n<p>      A component template can <a href=\"guide/ngmodule-faq#q-template-reference\">reference</a> another component, directive, or pipe\nwhen the referenced class is declared in this module\nor the class was imported from another module.</p>\n<p>      A component can use the <code><a href=\"api/common/NgIf\">NgIf</a></code> and <code><a href=\"api/common/NgFor\">NgFor</a></code> directives only because its parent module\nimported the Angular <code><a href=\"api/common/CommonModule\">CommonModule</a></code> (perhaps indirectly by importing <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code>).</p>\n<p>      You can import many standard directives with the <code><a href=\"api/common/CommonModule\">CommonModule</a></code>\nbut some familiar directives belong to other modules.\nA component template can bind with <code>[(ngModel)]</code> only after importing the Angular <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>exports</code>\n    </td>\n    <td>\n<p>      A list of declarations—<em>component</em>, <em>directive</em>, and <em>pipe</em> classes—that\nan importing module can use.</p>\n<p>      Exported declarations are the module's <em>public API</em>.\nA component in another module can <a href=\"guide/ngmodule-faq#q-template-reference\">reference</a> <em>this</em> module's <code>HeroComponent</code>\nif it imports this module and this module exports <code>HeroComponent</code>.</p>\n<p>      Declarations are private by default.\nIf this module does <em>not</em> export <code>HeroComponent</code>, no other module can see it.</p>\n<p>      Importing a module does <em>not</em> automatically re-export the imported module's imports.\nModule 'B' can't use <code>ngIf</code> just because it imported module <code>A</code> which imported <code><a href=\"api/common/CommonModule\">CommonModule</a></code>.\nModule 'B' must import <code><a href=\"api/common/CommonModule\">CommonModule</a></code> itself.</p>\n<p>      A module can list another module among its <code>exports</code>, in which case\nall of that module's public components, directives, and pipes are exported.</p>\n<p>      <a href=\"guide/ngmodule-faq#q-re-export\">Re-export</a> makes module transitivity explicit.\nIf Module 'A' re-exports <code><a href=\"api/common/CommonModule\">CommonModule</a></code> and Module 'B' imports Module 'A',\nModule 'B' components can use <code>ngIf</code> even though 'B' itself didn't import <code><a href=\"api/common/CommonModule\">CommonModule</a></code>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>bootstrap</code>\n    </td>\n    <td>\n<p>      A list of components that can be bootstrapped.</p>\n<p>      Usually there's only one component in this list, the <em>root component</em> of the application.</p>\n<p>      Angular can launch with multiple bootstrap components,\neach with its own location in the host web page.</p>\n<p>      A bootstrap component is automatically an <code>entryComponent</code>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>entryComponents</code>\n    </td>\n    <td>\n<p>      A list of components that are <em>not</em> <a href=\"guide/ngmodule-faq#q-template-reference\">referenced</a> in a reachable component template.</p>\n<p>      Most developers never set this property.\nThe <a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular compiler</a> must know about every component actually used in the application.\nThe compiler can discover most components by walking the tree of references\nfrom one component template to another.</p>\n<p>      But there's always at least one component that's not referenced in any template:\nthe root component, <code>AppComponent</code>, that you bootstrap to launch the app.\nThat's why it's called an <em>entry component</em>.</p>\n<p>      Routed components are also <em>entry components</em> because they aren't referenced in a template either.\nThe router creates them and drops them into the DOM near a <code>&#x3C;router-outlet></code>.</p>\n<p>      While the bootstrapped and routed components are <em>entry components</em>,\nyou usually don't have to add them to a module's <code>entryComponents</code> list.</p>\n<p>      Angular automatically adds components in the module's <code>bootstrap</code> list to the <code>entryComponents</code> list.\nThe <code><a href=\"api/router/RouterModule\">RouterModule</a></code> adds routed components to that list.</p>\n<p>      That leaves only the following sources of undiscoverable components:</p>\n<p>      <em> Components bootstrapped using one of the imperative techniques.\n</em> Components dynamically loaded into the DOM by some means other than the router.</p>\n<p>      Both are advanced techniques that few developers ever employ.\nIf you are one of those few, you must add these components to the\n<code>entryComponents</code> list yourself, either programmatically or by hand.</p>\n    </td>\n  </tr>\n</tbody></table>\n\n</div>"
}