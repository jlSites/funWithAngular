{
  "id": "guide/dependency-injection",
  "title": "Dependency Injection",
  "contents": "\n<div class=\"content\">\n<h1 id=\"dependency-injection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection\"><i class=\"material-icons\">link</i></a>Dependency Injection</h1>\n<p><strong>Dependency injection</strong> is an important application design pattern.\nAngular has its own dependency injection framework, and\nyou really can't build an Angular application without it.\nIt's used so widely that almost everyone just calls it <em>DI</em>.</p>\n<p>This page covers what DI is, why it's so useful,\nand <a href=\"guide/dependency-injection#angular-di\">how to use it</a> in an Angular app.</p>\n<p>Run the <live-example></live-example>.</p>\n<a id=\"why-di\"></a>\n<h2 id=\"why-dependency-injection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#why-dependency-injection\"><i class=\"material-icons\">link</i></a>Why dependency injection?</h2>\n<p>To understand why dependency injection is so important, consider an example without it.\nImagine writing the following code:</p>\n<code-example path=\"dependency-injection/src/app/car/car-no-di.ts\" region=\"car\" title=\"src/app/car/car.ts (without DI)\">\nexport class Car {\n\n  public engine: Engine;\n  public tires: Tires;\n  public description = 'No DI';\n\n  constructor() {\n    this.engine = new Engine();\n    this.tires = new Tires();\n  }\n\n  // Method using the engine and tires\n  drive() {\n    return `${this.description} car with ` +\n      `${this.engine.cylinders} cylinders and ${this.tires.make} tires.`;\n  }\n}\n\n</code-example>\n<p>The <code>Car</code> class creates everything it needs inside its constructor.\nWhat's the problem?\nThe problem is that the <code>Car</code> class is brittle, inflexible, and hard to test.</p>\n<p>This <code>Car</code> needs an engine and tires. Instead of asking for them,\nthe <code>Car</code> constructor instantiates its own copies from\nthe very specific classes <code>Engine</code> and <code>Tires</code>.</p>\n<p>What if the <code>Engine</code> class evolves and its constructor requires a parameter?\nThat would break the <code>Car</code> class and it would stay broken until you rewrote it along the lines of\n<code>this.engine = new Engine(theNewParameter)</code>.\nThe <code>Engine</code> constructor parameters weren't even a consideration when you first wrote <code>Car</code>.\nYou may not anticipate them even now.\nBut you'll <em>have</em> to start caring because\nwhen the definition of <code>Engine</code> changes, the <code>Car</code> class must change.\nThat makes <code>Car</code> brittle.</p>\n<p>What if you want to put a different brand of tires on your <code>Car</code>? Too bad.\nYou're locked into whatever brand the <code>Tires</code> class creates. That makes the\n<code>Car</code> class inflexible.</p>\n<p>Right now each new car gets its own <code>engine</code>. It can't share an <code>engine</code> with other cars.\nWhile that makes sense for an automobile engine,\nsurely you can think of other dependencies that should be shared, such as the onboard\nwireless connection to the manufacturer's service center. This <code>Car</code> lacks the flexibility\nto share services that have been created previously for other consumers.</p>\n<p>When you write tests for <code>Car</code> you're at the mercy of its hidden dependencies.\nIs it even possible to create a new <code>Engine</code> in a test environment?\nWhat does <code>Engine</code> depend upon? What does that dependency depend on?\nWill a new instance of <code>Engine</code> make an asynchronous call to the server?\nYou certainly don't want that going on during tests.</p>\n<p>What if the <code>Car</code> should flash a warning signal when tire pressure is low?\nHow do you confirm that it actually does flash a warning\nif you can't swap in low-pressure tires during the test?</p>\n<p>You have no control over the car's hidden dependencies.\nWhen you can't control the dependencies, a class becomes difficult to test.</p>\n<p>How can you make <code>Car</code> more robust, flexible, and testable?</p>\n<a id=\"ctor-injection\"></a>\n<p>That's super easy. Change the <code>Car</code> constructor to a version with DI:</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/car/car.ts (excerpt with DI)\" path=\"dependency-injection/src/app/car/car.ts\" region=\"car-ctor\">\npublic description = 'DI';\n\nconstructor(public engine: Engine, public tires: Tires) { }\n\n</code-pane>\n\n  <code-pane title=\"src/app/car/car.ts (excerpt without DI)\" path=\"dependency-injection/src/app/car/car-no-di.ts\" region=\"car-ctor\">\npublic engine: Engine;\npublic tires: Tires;\npublic description = 'No DI';\n\nconstructor() {\n  this.engine = new Engine();\n  this.tires = new Tires();\n}\n\n</code-pane>\n\n</code-tabs>\n<p>See what happened? The definition of the dependencies are\nnow in the constructor.\nThe <code>Car</code> class no longer creates an <code>engine</code> or <code>tires</code>.\nIt just consumes them.</p>\n<div class=\"l-sub-section\">\n<p>This example leverages TypeScript's constructor syntax for declaring\nparameters and properties simultaneously.</p>\n</div>\n<p>Now you can create a car by passing the engine and tires to the constructor.</p>\n<code-example path=\"dependency-injection/src/app/car/car-creations.ts\" region=\"car-ctor-instantiation\" linenums=\"false\">\n// Simple car with 4 cylinders and Flintstone tires.\nlet car = new Car(new Engine(), new Tires());\n\n</code-example>\n<p>How cool is that?\nThe definition of the <code>engine</code> and <code>tire</code> dependencies are\ndecoupled from the <code>Car</code> class.\nYou can pass in any kind of <code>engine</code> or <code>tires</code> you like, as long as they\nconform to the general API requirements of an <code>engine</code> or <code>tires</code>.</p>\n<p>Now, if someone extends the <code>Engine</code> class, that is not <code>Car</code>'s problem.</p>\n<div class=\"l-sub-section\">\n<p>The <em>consumer</em> of <code>Car</code> has the problem. The consumer must update the car creation code to\nsomething like this:</p>\n<code-example path=\"dependency-injection/src/app/car/car-creations.ts\" region=\"car-ctor-instantiation-with-param\" linenums=\"false\">\nclass Engine2 {\n  constructor(public cylinders: number) { }\n}\n// Super car with 12 cylinders and Flintstone tires.\nlet bigCylinders = 12;\nlet car = new Car(new Engine2(bigCylinders), new Tires());\n\n</code-example>\n<p>The critical point is this: the <code>Car</code> class did not have to change.\nYou'll take care of the consumer's problem shortly.</p>\n</div>\n<p>The <code>Car</code> class is much easier to test now because you are in complete control\nof its dependencies.\nYou can pass mocks to the constructor that do exactly what you want them to do\nduring each test:</p>\n<code-example path=\"dependency-injection/src/app/car/car-creations.ts\" region=\"car-ctor-instantiation-with-mocks\" linenums=\"false\">\nclass MockEngine extends Engine { cylinders = 8; }\nclass MockTires  extends Tires  { make = 'YokoGoodStone'; }\n\n// Test car with 8 cylinders and YokoGoodStone tires.\nlet car = new Car(new MockEngine(), new MockTires());\n\n</code-example>\n<p><strong>You just learned what dependency injection is</strong>.</p>\n<p>It's a coding pattern in which a class receives its dependencies from external\nsources rather than creating them itself.</p>\n<p>Cool! But what about that poor consumer?\nAnyone who wants a <code>Car</code> must now\ncreate all three parts: the <code>Car</code>, <code>Engine</code>, and <code>Tires</code>.\nThe <code>Car</code> class shed its problems at the consumer's expense.\nYou need something that takes care of assembling these parts.</p>\n<p>You <em>could</em> write a giant class to do that:</p>\n<code-example path=\"dependency-injection/src/app/car/car-factory.ts\" title=\"src/app/car/car-factory.ts\">\nimport { Engine, Tires, Car } from './car';\n\n// BAD pattern!\nexport class CarFactory {\n  createCar() {\n    let car = new Car(this.createEngine(), this.createTires());\n    car.description = 'Factory';\n    return car;\n  }\n\n  createEngine() {\n    return new Engine();\n  }\n\n  createTires() {\n    return new Tires();\n  }\n}\n\n\n</code-example>\n<p>It's not so bad now with only three creation methods.\nBut maintaining it will be hairy as the application grows.\nThis factory is going to become a huge spiderweb of\ninterdependent factory methods!</p>\n<p>Wouldn't it be nice if you could simply list the things you want to build without\nhaving to define which dependency gets injected into what?</p>\n<p>This is where the dependency injection framework comes into play.\nImagine the framework had something called an <em>injector</em>.\nYou register some classes with this injector, and it figures out how to create them.</p>\n<p>When you need a <code>Car</code>, you simply ask the injector to get it for you and you're good to go.</p>\n<code-example path=\"dependency-injection/src/app/car/car-injector.ts\" region=\"injector-call\" title=\"src/app/car/car-injector.ts\" linenums=\"false\">\nlet car = injector.get(Car);\n\n</code-example>\n<p>Everyone wins. The <code>Car</code> knows nothing about creating an <code>Engine</code> or <code>Tires</code>.\nThe consumer knows nothing about creating a <code>Car</code>.\nYou don't have a gigantic factory class to maintain.\nBoth <code>Car</code> and consumer simply ask for what they need and the injector delivers.</p>\n<p>This is what a <strong>dependency injection framework</strong> is all about.</p>\n<p>Now that you know what dependency injection is and appreciate its benefits,\nread on to see how it is implemented in Angular.</p>\n<a id=\"angular-di\"></a>\n<h2 id=\"angular-dependency-injection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#angular-dependency-injection\"><i class=\"material-icons\">link</i></a>Angular dependency injection</h2>\n<p>Angular ships with its own dependency injection framework. This framework can also be used\nas a standalone module by other applications and frameworks.</p>\n<p>To see what it can do when building components in Angular,\nstart with a simplified version of the <code>HeroesComponent</code>\nthat from the <a href=\"tutorial/\">The Tour of Heroes</a>.</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/heroes.component.ts\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"v1\">\nimport { Component }          from '@angular/core';\n\n@Component({\n  selector: 'my-heroes',\n  template: `\n  &#x3C;h2>Heroes&#x3C;/h2>\n  &#x3C;hero-list>&#x3C;/hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero-list.component.ts\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { Component }   from '@angular/core';\n\nimport { HEROES }      from './mock-heroes';\n\n@Component({\n  selector: 'hero-list',\n  template: `\n  &#x3C;div *ngFor=\"let hero of heroes\">\n    {{hero.id}} - {{hero.name}}\n  &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero.ts\" path=\"dependency-injection/src/app/heroes/hero.ts\">\nexport class Hero {\n  id: number;\n  name: string;\n  isSecret = false;\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/mock-heroes.ts\" path=\"dependency-injection/src/app/heroes/mock-heroes.ts\">\nimport { Hero } from './hero';\n\nexport const HEROES: Hero[] = [\n  { id: 11, isSecret: false, name: 'Mr. Nice' },\n  { id: 12, isSecret: false, name: 'Narco' },\n  { id: 13, isSecret: false, name: 'Bombasto' },\n  { id: 14, isSecret: false, name: 'Celeritas' },\n  { id: 15, isSecret: false, name: 'Magneta' },\n  { id: 16, isSecret: false, name: 'RubberMan' },\n  { id: 17, isSecret: false, name: 'Dynama' },\n  { id: 18, isSecret: true,  name: 'Dr IQ' },\n  { id: 19, isSecret: true,  name: 'Magma' },\n  { id: 20, isSecret: true,  name: 'Tornado' }\n];\n\n\n</code-pane>\n\n</code-tabs>\n<p>The <code>HeroesComponent</code> is the root component of the <em>Heroes</em> feature area.\nIt governs all the child components of this area.\nThis stripped down version has only one child, <code>HeroListComponent</code>,\nwhich displays a list of heroes.</p>\n<p>Right now <code>HeroListComponent</code> gets heroes from <code>HEROES</code>, an in-memory collection\ndefined in another file.\nThat may suffice in the early stages of development, but it's far from ideal.\nAs soon as you try to test this component or want to get your heroes data from a remote server,\nyou'll have to change the implementation of <code>heroes</code> and\nfix every other use of the <code>HEROES</code> mock data.</p>\n<p>It's better to make a service that hides how the app gets hero data.</p>\n<div class=\"l-sub-section\">\n<p>Given that the service is a\n<a href=\"https://en.wikipedia.org/wiki/Separation_of_concerns\">separate concern</a>,\nconsider writing the service code in its own file.</p>\n<p>See <a href=\"guide/dependency-injection#one-class-per-file\">this note</a> for details.</p>\n</div>\n<p>The following <code>HeroService</code> exposes a <code>getHeroes</code> method that returns\nthe same mock data as before, but none of its consumers need to know that.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.1.ts\" title=\"src/app/heroes/hero.service.ts\">\nimport { Injectable } from '@angular/core';\n\nimport { HEROES }     from './mock-heroes';\n\n@Injectable()\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>The <code>@Injectable()</code> decorator above the service class is\ncovered <a href=\"guide/dependency-injection#injectable\">shortly</a>.</p>\n</div>\n<div class=\"l-sub-section\">\n<p>Of course, this isn't a real service.\nIf the app were actually getting data from a remote server, the API would have to be\nasynchronous, perhaps returning a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a>.\nYou'd also have to rewrite the way components consume the service.\nThis is important in general, but not in this example.</p>\n</div>\n<p>A service is nothing more than a class in Angular.\nIt remains nothing more than a class until you register it with an Angular injector.</p>\n<div id=\"bootstrap\">\n</div>\n<a id=\"injector-config\"></a>\n<h3 id=\"configuring-the-injector\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#configuring-the-injector\"><i class=\"material-icons\">link</i></a>Configuring the injector</h3>\n<p>You don't have to create an Angular injector.\nAngular creates an application-wide injector for you during the bootstrap process.</p>\n<code-example path=\"dependency-injection/src/main.ts\" linenums=\"false\" title=\"src/main.ts (bootstrap)\" region=\"bootstrap\">\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n</code-example>\n<p>You do have to configure the injector by registering the <strong>providers</strong>\nthat create the services the application requires.\nThis guide explains what <a href=\"guide/dependency-injection#providers\">providers</a> are later.</p>\n<p>You can either register a provider within an <a href=\"guide/ngmodule\">NgModule</a> or in application components.</p>\n<a id=\"register-providers-ngmodule\"></a>\n<h3 id=\"registering-providers-in-an-ngmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#registering-providers-in-an-ngmodule\"><i class=\"material-icons\">link</i></a>Registering providers in an <em>NgModule</em></h3>\n<p>Here's the <code>AppModule</code> that registers two providers, <code>UserService</code> and an <code>APP_CONFIG</code> provider,\nin its <code>providers</code> array.</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" linenums=\"false\" title=\"src/app/app.module.ts (excerpt)\" region=\"ngmodule\">\n@NgModule({\n  imports: [\n    BrowserModule\n  ],\n  declarations: [\n    AppComponent,\n    CarComponent,\n    HeroesComponent,\n/* . . . */\n  ],\n  providers: [\n    UserService,\n    { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<p>Because the <code>HeroService</code> is used <em>only</em> within the <code>HeroesComponent</code>\nand its subcomponents, the top-level <code>HeroesComponent</code> is the ideal\nplace to register it.</p>\n<a id=\"register-providers-component\"></a>\n<h3 id=\"registering-providers-in-a-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#registering-providers-in-a-component\"><i class=\"material-icons\">link</i></a>Registering providers in a component</h3>\n<p>Here's a revised <code>HeroesComponent</code> that registers the <code>HeroService</code> in its <code>providers</code> array.</p>\n<code-example path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"full\" title=\"src/app/heroes/heroes.component.ts\" linenums=\"false\">\nimport { Component }          from '@angular/core';\n\nimport { HeroService }        from './hero.service';\n\n@Component({\n  selector: 'my-heroes',\n  providers: [HeroService],\n  template: `\n  &#x3C;h2>Heroes&#x3C;/h2>\n  &#x3C;hero-list>&#x3C;/hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-example>\n<a id=\"ngmodule-vs-comp\"></a>\n<h3 id=\"when-to-use-ngmodule-versus-an-application-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#when-to-use-ngmodule-versus-an-application-component\"><i class=\"material-icons\">link</i></a>When to use <em>NgModule</em> versus an application component</h3>\n<p>On the one hand, a provider in an <code><a href=\"api/core/NgModule\">NgModule</a></code> is registered in the root injector. That means that every provider\nregistered within an <code><a href=\"api/core/NgModule\">NgModule</a></code> will be accessible in the <em>entire application</em>.</p>\n<p>On the other hand, a provider registered in an application component is available only on\nthat component and all its children.</p>\n<p>Here, the <code>APP_CONFIG</code> service needs to be available all across the application, so it's\nregistered in the <code>AppModule</code> <code>@NgModule</code> <code>providers</code> array.\nBut since the <code>HeroService</code> is only used within the <em>Heroes</em>\nfeature area and nowhere else, it makes sense to register it in\nthe <code>HeroesComponent</code>.</p>\n<div class=\"l-sub-section\">\n<p>Also see <em>\"Should I add app-wide providers to the root <code>AppModule</code> or\nthe root <code>AppComponent</code>?\"</em> in the <a href=\"guide/ngmodule-faq#q-root-component-or-module\">NgModule FAQ</a>.</p>\n</div>\n<a id=\"prep-for-injection\"></a>\n<h3 id=\"preparing-the-herolistcomponent-for-injection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#preparing-the-herolistcomponent-for-injection\"><i class=\"material-icons\">link</i></a>Preparing the <em>HeroListComponent</em> for injection</h3>\n<p>The <code>HeroListComponent</code> should get heroes from the injected <code>HeroService</code>.\nPer the dependency injection pattern, the component must ask for the service in its\nconstructor, <a href=\"guide/dependency-injection#ctor-injection\">as discussed earlier</a>.\nIt's a small change:</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/hero-list.component (with DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.2.ts\">\nimport { Component }   from '@angular/core';\n\nimport { Hero }        from './hero';\nimport { HeroService } from './hero.service';\n\n@Component({\n  selector: 'hero-list',\n  template: `\n  &#x3C;div *ngFor=\"let hero of heroes\">\n    {{hero.id}} - {{hero.name}}\n  &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes: Hero[];\n\n  constructor(heroService: HeroService) {\n    this.heroes = heroService.getHeroes();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero-list.component (without DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { Component }   from '@angular/core';\n\nimport { HEROES }      from './mock-heroes';\n\n@Component({\n  selector: 'hero-list',\n  template: `\n  &#x3C;div *ngFor=\"let hero of heroes\">\n    {{hero.id}} - {{hero.name}}\n  &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n\n</code-tabs>\n<div class=\"l-sub-section\">\n<h4 id=\"focus-on-the-constructor\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#focus-on-the-constructor\"><i class=\"material-icons\">link</i></a>Focus on the constructor</h4>\n<p>Adding a parameter to the constructor isn't all that's happening here.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.2.ts\" region=\"ctor\" title=\"src/app/heroes/hero-list.component.ts\" linenums=\"false\">\nconstructor(heroService: HeroService) {\n  this.heroes = heroService.getHeroes();\n}\n\n</code-example>\n<p>Note that the constructor parameter has the type <code>HeroService</code>, and that\nthe <code>HeroListComponent</code> class has an <code>@Component</code> decorator\n(scroll up to confirm that fact).\nAlso recall that the parent component (<code>HeroesComponent</code>)\nhas <code>providers</code> information for <code>HeroService</code>.</p>\n<p>The constructor parameter type, the <code>@Component</code> decorator,\nand the parent's <code>providers</code> information combine to tell the\nAngular injector to inject an instance of\n<code>HeroService</code> whenever it creates a new <code>HeroListComponent</code>.</p>\n</div>\n<a id=\"di-metadata\"></a>\n<h3 id=\"implicit-injector-creation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#implicit-injector-creation\"><i class=\"material-icons\">link</i></a>Implicit injector creation</h3>\n<p>You saw how to use an injector to create a new\n<code>Car</code> earlier in this guide.\nYou <em>could</em> create such an injector\nexplicitly:</p>\n<code-example path=\"dependency-injection/src/app/car/car-injector.ts\" region=\"injector-create-and-call\" title=\"src/app/car/car-injector.ts\" linenums=\"false\">\ninjector = ReflectiveInjector.resolveAndCreate([Car, Engine, Tires]);\nlet car = injector.get(Car);\n\n</code-example>\n<p>You won't find code like that in the Tour of Heroes or any of the other\ndocumentation samples.\nYou <em>could</em> write code that <a href=\"guide/dependency-injection#explicit-injector\">explicitly creates an injector</a> if you <em>had</em> to,\nbut it's not always the best choice.\nAngular takes care of creating and calling injectors\nwhen it creates components for you—whether through HTML markup, as in <code>&#x3C;hero-list>&#x3C;/hero-list></code>,\nor after navigating to a component with the <a href=\"guide/router\">router</a>.\nIf you let Angular do its job, you'll enjoy the benefits of automated dependency injection.</p>\n<a id=\"singleton-services\"></a>\n<h3 id=\"singleton-services\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#singleton-services\"><i class=\"material-icons\">link</i></a>Singleton services</h3>\n<p>Dependencies are singletons within the scope of an injector.\nIn this guide's example, a single <code>HeroService</code> instance is shared among the\n<code>HeroesComponent</code> and its <code>HeroListComponent</code> children.</p>\n<p>However, Angular DI is a hierarchical injection\nsystem, which means that nested injectors can create their own service instances.\nFor more information, see <a href=\"guide/hierarchical-dependency-injection\">Hierarchical Injectors</a>.</p>\n<a id=\"testing-the-component\"></a>\n<h3 id=\"testing-the-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#testing-the-component\"><i class=\"material-icons\">link</i></a>Testing the component</h3>\n<p>Earlier you saw that designing a class for dependency injection makes the class easier to test.\nListing dependencies as constructor parameters may be all you need to test application parts effectively.</p>\n<p>For example, you can create a new <code>HeroListComponent</code> with a mock service that you can manipulate\nunder test:</p>\n<code-example path=\"dependency-injection/src/app/test.component.ts\" region=\"spec\" title=\"src/app/test.component.ts\" linenums=\"false\">\nlet expectedHeroes = [{name: 'A'}, {name: 'B'}]\nlet mockService = &#x3C;HeroService> {getHeroes: () => expectedHeroes }\n\nit('should have heroes when HeroListComponent created', () => {\n  let hlc = new HeroListComponent(mockService);\n  expect(hlc.heroes.length).toEqual(expectedHeroes.length);\n});\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>Learn more in <a href=\"guide/testing\">Testing</a>.</p>\n</div>\n<a id=\"service-needs-service\"></a>\n<h3 id=\"when-the-service-needs-a-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#when-the-service-needs-a-service\"><i class=\"material-icons\">link</i></a>When the service needs a service</h3>\n<p>The <code>HeroService</code> is very simple. It doesn't have any dependencies of its own.</p>\n<p>What if it had a dependency? What if it reported its activities through a logging service?\nYou'd apply the same <em>constructor injection</em> pattern,\nadding a constructor that takes a <code>Logger</code> parameter.</p>\n<p>Here is the revision compared to the original.</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/hero.service (v2)\" path=\"dependency-injection/src/app/heroes/hero.service.2.ts\">\nimport { Injectable } from '@angular/core';\n\nimport { HEROES }     from './mock-heroes';\nimport { Logger }     from '../logger.service';\n\n@Injectable()\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero.service (v1)\" path=\"dependency-injection/src/app/heroes/hero.service.1.ts\">\nimport { Injectable } from '@angular/core';\n\nimport { HEROES }     from './mock-heroes';\n\n@Injectable()\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p>The constructor now asks for an injected instance of a <code>Logger</code> and stores it in a private property called <code>logger</code>.\nYou call that property within the <code>getHeroes()</code> method when anyone asks for heroes.</p>\n<a id=\"injectable\"></a>\n<h3 id=\"why-injectable\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#why-injectable\"><i class=\"material-icons\">link</i></a>Why <em>@Injectable()</em>?</h3>\n<p><strong><a href=\"api/core/Injectable\">@Injectable()</a></strong> marks a class as available to an\ninjector for instantiation. Generally speaking, an injector reports an\nerror when trying to instantiate a class that is not marked as\n<code>@Injectable()</code>.</p>\n<div class=\"l-sub-section\">\n<p>As it happens, you could have omitted <code>@Injectable()</code> from the first\nversion of <code>HeroService</code> because it had no injected parameters.\nBut you must have it now that the service has an injected dependency.\nYou need it because Angular requires constructor parameter metadata\nin order to inject a <code>Logger</code>.</p>\n</div>\n<div class=\"callout is-helpful\">\n<header>\n  Suggestion: add @Injectable() to every service class\n</header>\n<p>Consider adding <code>@Injectable()</code> to every service class, even those that don't have dependencies\nand, therefore, do not technically require it. Here's why:</p>\n<ul style=\"font-size:inherit\">\n  <li>\n    <b>Future proofing:</b> No need to remember <code>@Injectable()</code> when you add a dependency later.\n  </li>\n  <li>\n    <b>Consistency:</b> All services follow the same rules, and you don't have to wonder why a decorator is missing.\n  </li>\n</ul>\n</div>\n<p>Injectors are also responsible for instantiating components\nlike <code>HeroesComponent</code>. So why doesn't <code>HeroesComponent</code> have\n<code>@Injectable()</code>?</p>\n<p>You <em>can</em> add it if you really want to. It isn't necessary because the\n<code>HeroesComponent</code> is already marked with <code>@Component</code>, and this\ndecorator class (like <code>@Directive</code> and <code>@Pipe</code>, which you learn about later)\nis a subtype of <a href=\"api/core/Injectable\">@Injectable()</a>.  It is in\nfact <code>@Injectable()</code> decorators that\nidentify a class as a target for instantiation by an injector.</p>\n<div class=\"l-sub-section\">\n<p>At runtime, injectors can read class metadata in the transpiled JavaScript code\nand use the constructor parameter type information\nto determine what things to inject.</p>\n<p>Not every JavaScript class has metadata.\nThe TypeScript compiler discards metadata by default.\nIf the <code>emitDecoratorMetadata</code> compiler option is true\n(as it should be in the <code>tsconfig.json</code>),\nthe compiler adds the metadata to the generated JavaScript\nfor <em>every class with at least one decorator</em>.</p>\n<p>While any decorator will trigger this effect, mark the service class with the\n<a href=\"api/core/Injectable\">@Injectable()</a> decorator\nto make the intent clear.</p>\n</div>\n<div class=\"callout is-critical\">\n<header>\n  Always include the parentheses\n</header>\n<p>Always write <code>@Injectable()</code>, not just <code>@Injectable</code>.\nThe application will fail mysteriously if you forget the parentheses.</p>\n</div>\n<a id=\"logger-service\"></a>\n<h2 id=\"creating-and-registering-a-logger-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#creating-and-registering-a-logger-service\"><i class=\"material-icons\">link</i></a>Creating and registering a logger service</h2>\n<p>Inject a logger into <code>HeroService</code> in two steps:</p>\n<ol>\n<li>Create the logger service.</li>\n<li>Register it with the application.</li>\n</ol>\n<p>The logger service is quite simple:</p>\n<code-example path=\"dependency-injection/src/app/logger.service.ts\" title=\"src/app/logger.service.ts\">\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class Logger {\n  logs: string[] = []; // capture logs for testing\n\n  log(message: string) {\n    this.logs.push(message);\n    console.log(message);\n  }\n}\n\n\n</code-example>\n<p>You're likely to need the same logger service everywhere in your application,\nso put it in the project's <code>app</code> folder and\nregister it in the <code>providers</code> array of the application module, <code>AppModule</code>.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" linenums=\"false\" title=\"src/app/providers.component.ts (excerpt)\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p>If you forget to register the logger, Angular throws an exception when it first looks for the logger:</p>\n<code-example format=\"nocode\">\n  EXCEPTION: No provider for Logger! (HeroListComponent -> HeroService -> Logger)\n\n</code-example>\n<p>That's Angular telling you that the dependency injector couldn't find the <em>provider</em> for the logger.\nIt needed that provider to create a <code>Logger</code> to inject into a new\n<code>HeroService</code>, which it needed to\ncreate and inject into a new <code>HeroListComponent</code>.</p>\n<p>The chain of creations started with the <code>Logger</code> provider. <em>Providers</em> are the subject of the next section.</p>\n<a id=\"providers\"></a>\n<h2 id=\"injector-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injector-providers\"><i class=\"material-icons\">link</i></a>Injector providers</h2>\n<p>A provider <em>provides</em> the concrete, runtime version of a dependency value.\nThe injector relies on <strong>providers</strong> to create instances of the services\nthat the injector injects into components and other services.</p>\n<p>You must register a service <em>provider</em> with the injector, or it won't know how to create the service.</p>\n<p>Earlier you registered the <code>Logger</code> service in the <code>providers</code> array of the metadata for the <code>AppModule</code> like this:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\" title=\"src/app/providers.component.ts\">\nproviders: [Logger]\n\n</code-example>\n<p>There are many ways to <em>provide</em> something that looks and behaves like a <code>Logger</code>.\nThe <code>Logger</code> class itself is an obvious and natural provider.\nBut it's not the only way.</p>\n<p>You can configure the injector with alternative providers that can deliver an object that behaves like a <code>Logger</code>.\nYou could provide a substitute class. You could provide a logger-like object.\nYou could give it a provider that calls a logger factory function.\nAny of these approaches might be a good choice under the right circumstances.</p>\n<p>What matters is that the injector has a provider to go to when it needs a <code>Logger</code>.</p>\n<div id=\"provide\">\n</div>\n<h3 id=\"the-provider-class-and-provide-object-literal\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#the-provider-class-and-provide-object-literal\"><i class=\"material-icons\">link</i></a>The <em>Provider</em> class and <em>provide</em> object literal</h3>\n<p>You wrote the <code>providers</code> array like this:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-1\" title=\"src/app/providers.component.ts\">\nproviders: [Logger]\n\n</code-example>\n<p>This is actually a shorthand expression for a provider registration\nusing a <em>provider</em> object literal with two properties:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\" title=\"src/app/providers.component.ts\">\n[{ provide: Logger, useClass: Logger }]\n\n</code-example>\n<p>The first is the <a href=\"guide/dependency-injection#token\">token</a> that serves as the key for both locating a dependency value\nand registering the provider.</p>\n<p>The second is a provider definition object,\nwhich you can think of as a <em>recipe</em> for creating the dependency value.\nThere are many ways to create dependency values just as there are many ways to write a recipe.</p>\n<div id=\"class-provider\">\n</div>\n<h3 id=\"alternative-class-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#alternative-class-providers\"><i class=\"material-icons\">link</i></a>Alternative class providers</h3>\n<p>Occasionally you'll ask a different class to provide the service.\nThe following code tells the injector\nto return a <code>BetterLogger</code> when something asks for the <code>Logger</code>.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\" title=\"src/app/providers.component.ts\">\n[{ provide: Logger, useClass: BetterLogger }]\n\n</code-example>\n<a id=\"class-provider-dependencies\"></a>\n<h3 id=\"class-provider-with-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#class-provider-with-dependencies\"><i class=\"material-icons\">link</i></a>Class provider with dependencies</h3>\n<p>Maybe an <code>EvenBetterLogger</code> could display the user name in the log message.\nThis logger gets the user from the injected <code>UserService</code>,\nwhich is also injected at the application level.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\" title=\"src/app/providers.component.ts\" linenums=\"false\">\n@Injectable()\nclass EvenBetterLogger extends Logger {\n  constructor(private userService: UserService) { super(); }\n\n  log(message: string) {\n    let name = this.userService.user.name;\n    super.log(`Message to ${name}: ${message}`);\n  }\n}\n\n</code-example>\n<p>Configure it like <code>BetterLogger</code>.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\" title=\"src/app/providers.component.ts\" linenums=\"false\">\n[ UserService,\n  { provide: Logger, useClass: EvenBetterLogger }]\n\n</code-example>\n<a id=\"aliased-class-providers\"></a>\n<h3 id=\"aliased-class-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#aliased-class-providers\"><i class=\"material-icons\">link</i></a>Aliased class providers</h3>\n<p>Suppose an old component depends upon an <code>OldLogger</code> class.\n<code>OldLogger</code> has the same interface as the <code>NewLogger</code>, but for some reason\nyou can't update the old component to use it.</p>\n<p>When the <em>old</em> component logs a message with <code>OldLogger</code>,\nyou'd like the singleton instance of <code>NewLogger</code> to handle it instead.</p>\n<p>The dependency injector should inject that singleton instance\nwhen a component asks for either the new or the old logger.\nThe <code>OldLogger</code> should be an alias for <code>NewLogger</code>.</p>\n<p>You certainly do not want two different <code>NewLogger</code> instances in your app.\nUnfortunately, that's what you get if you try to alias <code>OldLogger</code> to <code>NewLogger</code> with <code>useClass</code>.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6a\" title=\"src/app/providers.component.ts\" linenums=\"false\">\n[ NewLogger,\n  // Not aliased! Creates two instances of `NewLogger`\n  { provide: OldLogger, useClass: NewLogger}]\n\n</code-example>\n<p>The solution: alias with the <code>useExisting</code> option.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\" linenums=\"false\">\n[ NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger}]\n\n</code-example>\n<a id=\"value-provider\"></a>\n<h3 id=\"value-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#value-providers\"><i class=\"material-icons\">link</i></a>Value providers</h3>\n<p>Sometimes it's easier to provide a ready-made object rather than ask the injector to create it from a class.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"silent-logger\" title=\"src/app/providers.component.ts\" linenums=\"false\">\n// An object in the shape of the logger service\nlet silentLogger = {\n  logs: ['Silent logger says \"Shhhhh!\". Provided via \"useValue\"'],\n  log: () => {}\n};\n\n</code-example>\n<p>Then you register a provider with the <code>useValue</code> option,\nwhich makes this object play the logger role.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-7\" linenums=\"false\">\n[{ provide: Logger, useValue: silentLogger }]\n\n</code-example>\n<p>See more <code>useValue</code> examples in the\n<a href=\"guide/dependency-injection#non-class-dependencies\">Non-class dependencies</a> and\n<a href=\"guide/dependency-injection#injection-token\">InjectionToken</a> sections.</p>\n<div id=\"factory-provider\">\n</div>\n<h3 id=\"factory-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#factory-providers\"><i class=\"material-icons\">link</i></a>Factory providers</h3>\n<p>Sometimes you need to create the dependent value dynamically,\nbased on information you won't have until the last possible moment.\nMaybe the information changes repeatedly in the course of the browser session.</p>\n<p>Suppose also that the injectable service has no independent access to the source of this information.</p>\n<p>This situation calls for a <strong>factory provider</strong>.</p>\n<p>To illustrate the point, add a new business requirement:\nthe <code>HeroService</code> must hide <em>secret</em> heroes from normal users.\nOnly authorized users should see secret heroes.</p>\n<p>Like the <code>EvenBetterLogger</code>, the <code>HeroService</code> needs a fact about the user.\nIt needs to know if the user is authorized to see secret heroes.\nThat authorization can change during the course of a single application session,\nas when you log in a different user.</p>\n<p>Unlike <code>EvenBetterLogger</code>, you can't inject the <code>UserService</code> into the <code>HeroService</code>.\nThe <code>HeroService</code> won't have direct access to the user information to decide\nwho is authorized and who is not.</p>\n<p>Instead, the <code>HeroService</code> constructor takes a boolean flag to control display of secret heroes.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" title=\"src/app/heroes/hero.service.ts (excerpt)\" linenums=\"false\">\nconstructor(\n  private logger: Logger,\n  private isAuthorized: boolean) { }\n\ngetHeroes() {\n  let auth = this.isAuthorized ? 'authorized ' : 'unauthorized';\n  this.logger.log(`Getting heroes for ${auth} user.`);\n  return HEROES.filter(hero => this.isAuthorized || !hero.isSecret);\n}\n\n</code-example>\n<p>You can inject the <code>Logger</code>, but you can't inject the  boolean <code>isAuthorized</code>.\nYou'll have to take over the creation of new instances of this <code>HeroService</code> with a factory provider.</p>\n<p>A factory provider needs a factory function:</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" title=\"src/app/heroes/hero.service.provider.ts (excerpt)\" linenums=\"false\">\nlet heroServiceFactory = (logger: Logger, userService: UserService) => {\n  return new HeroService(logger, userService.user.isAuthorized);\n};\n\n</code-example>\n<p>Although the <code>HeroService</code> has no access to the <code>UserService</code>, the factory function does.</p>\n<p>You inject both the <code>Logger</code> and the <code>UserService</code> into the factory provider\nand let the injector pass them along to the factory function:</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" title=\"src/app/heroes/hero.service.provider.ts (excerpt)\" linenums=\"false\">\nexport let heroServiceProvider =\n  { provide: HeroService,\n    useFactory: heroServiceFactory,\n    deps: [Logger, UserService]\n  };\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>The <code>useFactory</code> field tells Angular that the provider is a factory function\nwhose implementation is the <code>heroServiceFactory</code>.</p>\n<p>The <code>deps</code> property is an array of <a href=\"guide/dependency-injection#token\">provider tokens</a>.\nThe <code>Logger</code> and <code>UserService</code> classes serve as tokens for their own class providers.\nThe injector resolves these tokens and injects the corresponding services into the matching factory function parameters.</p>\n</div>\n<p>Notice that you captured the factory provider in an exported variable, <code>heroServiceProvider</code>.\nThis extra step makes the factory provider reusable.\nYou can register the <code>HeroService</code> with this variable wherever you need it.</p>\n<p>In this sample, you need it only in the <code>HeroesComponent</code>,\nwhere it replaces the previous <code>HeroService</code> registration in the metadata <code>providers</code> array.\nHere you see the new and the old implementation side-by-side:</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/heroes.component (v3)\" path=\"dependency-injection/src/app/heroes/heroes.component.ts\">\nimport { Component }          from '@angular/core';\n\nimport { heroServiceProvider } from './hero.service.provider';\n\n@Component({\n  selector: 'my-heroes',\n  template: `\n  &#x3C;h2>Heroes&#x3C;/h2>\n  &#x3C;hero-list>&#x3C;/hero-list>\n  `,\n  providers: [heroServiceProvider]\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/heroes.component (v2)\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"full\">\nimport { Component }          from '@angular/core';\n\nimport { HeroService }        from './hero.service';\n\n@Component({\n  selector: 'my-heroes',\n  providers: [HeroService],\n  template: `\n  &#x3C;h2>Heroes&#x3C;/h2>\n  &#x3C;hero-list>&#x3C;/hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n</code-tabs>\n<a id=\"token\"></a>\n<h2 id=\"dependency-injection-tokens\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection-tokens\"><i class=\"material-icons\">link</i></a>Dependency injection tokens</h2>\n<p>When you register a provider with an injector, you associate that provider with a dependency injection token.\nThe injector maintains an internal <em>token-provider</em> map that it references when\nasked for a dependency. The token is the key to the map.</p>\n<p>In all previous examples, the dependency value has been a class <em>instance</em>, and\nthe class <em>type</em> served as its own lookup key.\nHere you get a <code>HeroService</code> directly from the injector by supplying the <code>HeroService</code> type as the token:</p>\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" title=\"src/app/injector.component.ts\" linenums=\"false\">\nheroService: HeroService;\n\n</code-example>\n<p>You have similar good fortune when you write a constructor that requires an injected class-based dependency.\nWhen you define a constructor parameter with the <code>HeroService</code> class type,\nAngular knows to inject the\nservice associated with that <code>HeroService</code> class token:</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" title=\"src/app/heroes/hero-list.component.ts\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p>This is especially convenient when you consider that most dependency values are provided by classes.</p>\n<a id=\"non-class-dependencies\"></a>\n<h3 id=\"non-class-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#non-class-dependencies\"><i class=\"material-icons\">link</i></a>Non-class dependencies</h3>\n<p>\n  What if the dependency value isn't a class? Sometimes the thing you want to inject is a\n  string, function, or object.\n</p>\n<p>\n  Applications often define configuration objects with lots of small facts\n  (like the title of the application or the address of a web API endpoint)\n  but these configuration objects aren't always instances of a class.\n  They can be object literals such as this one:\n</p>\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"config\" title=\"src/app/app-config.ts (excerpt)\" linenums=\"false\">\nexport interface AppConfig {\n  apiEndpoint: string;\n  title: string;\n}\n\nexport const HERO_DI_CONFIG: AppConfig = {\n  apiEndpoint: 'api.heroes.com',\n  title: 'Dependency Injection'\n};\n\n\n</code-example>\n<p>What if you'd like to make this configuration object available for injection?\nYou know you can register an object with a <a href=\"guide/dependency-injection#value-provider\">value provider</a>.</p>\n<p>But what should you use as the token?\nYou don't have a class to serve as a token.\nThere is no <code>AppConfig</code> class.</p>\n<div class=\"l-sub-section\">\n<h3 id=\"typescript-interfaces-arent-valid-tokens\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#typescript-interfaces-arent-valid-tokens\"><i class=\"material-icons\">link</i></a>TypeScript interfaces aren't valid tokens</h3>\n<p>The <code>HERO_DI_CONFIG</code> constant has an interface, <code>AppConfig</code>. Unfortunately, you\ncannot use a TypeScript interface as a token:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\" title=\"src/app/providers.component.ts\" linenums=\"false\">\n// FAIL! Can't use interface as provider token\n[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\" title=\"src/app/providers.component.ts\" linenums=\"false\">\n// FAIL! Can't inject using the interface as the parameter type\nconstructor(private config: AppConfig){ }\n\n</code-example>\n<p>That seems strange if you're used to dependency injection in strongly typed languages, where\nan interface is the preferred dependency lookup key.</p>\n<p>It's not Angular's doing. An interface is a TypeScript design-time artifact. JavaScript doesn't have interfaces.\nThe TypeScript interface disappears from the generated JavaScript.\nThere is no interface type information left for Angular to find at runtime.</p>\n</div>\n<a id=\"injection-token\"></a>\n<h3 id=\"injectiontoken\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injectiontoken\"><i class=\"material-icons\">link</i></a><em>InjectionToken</em></h3>\n<p>One solution to choosing a provider token for non-class dependencies is\nto define and use an <a href=\"api/core/InjectionToken\"><em>InjectionToken</em></a>.\nThe definition of such a token looks like this:</p>\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"token\" title=\"src/app/app.config.ts\" linenums=\"false\">\nimport { InjectionToken } from '@angular/core';\n\nexport let APP_CONFIG = new InjectionToken&#x3C;AppConfig>('app.config');\n\n</code-example>\n<p>The type parameter, while optional, conveys the dependency's type to developers and tooling.\nThe token description is another developer aid.</p>\n<p>Register the dependency provider using the <code><a href=\"api/core/InjectionToken\">InjectionToken</a></code> object:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9\" title=\"src/app/providers.component.ts\" linenums=\"false\">\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]\n\n</code-example>\n<p>Now you can inject the configuration object into any constructor that needs it, with\nthe help of an <code>@Inject</code> decorator:</p>\n<code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" title=\"src/app/app.component.ts\" linenums=\"false\">\nconstructor(@Inject(APP_CONFIG) config: AppConfig) {\n  this.title = config.title;\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>Although the <code>AppConfig</code> interface plays no role in dependency injection,\nit supports typing of the configuration object within the class.</p>\n</div>\n<p>Alternatively, you can provide and inject the configuration object in an ngModule like <code>AppModule</code>.</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" region=\"ngmodule-providers\" title=\"src/app/app.module.ts (ngmodule-providers)\">\nproviders: [\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<div id=\"optional\">\n</div>\n<h2 id=\"optional-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#optional-dependencies\"><i class=\"material-icons\">link</i></a>Optional dependencies</h2>\n<p>The <code>HeroService</code> <em>requires</em> a <code>Logger</code>, but what if it could get by without\na <code>logger</code>?\nYou can tell Angular that the dependency is optional by annotating the\nconstructor argument with <code>@Optional()</code>:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"import-optional\">\nimport { Optional } from '@angular/core';\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-10-ctor\" linenums=\"false\">\nconstructor(@Optional() private logger: Logger) {\n  if (this.logger) {\n    this.logger.log(some_message);\n  }\n}\n\n</code-example>\n<p>When using <code>@Optional()</code>, your code must be prepared for a null value. If you\ndon't register a <code>logger</code> somewhere up the line, the injector will set the\nvalue of <code>logger</code> to null.</p>\n<h2 id=\"summary\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#summary\"><i class=\"material-icons\">link</i></a>Summary</h2>\n<p>You learned the basics of Angular dependency injection in this page.\nYou can register various kinds of providers,\nand you know how to ask for an injected object (such as a service) by\nadding a parameter to a constructor.</p>\n<p>Angular dependency injection is more capable than this guide has described.\nYou can learn more about its advanced features, beginning with its support for\nnested injectors, in\n<a href=\"guide/hierarchical-dependency-injection\">Hierarchical Dependency Injection</a>.</p>\n<a id=\"explicit-injector\"></a>\n<h2 id=\"appendix-working-with-injectors-directly\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#appendix-working-with-injectors-directly\"><i class=\"material-icons\">link</i></a>Appendix: Working with injectors directly</h2>\n<p>Developers rarely work directly with an injector, but\nhere's an <code>InjectorComponent</code> that does.</p>\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"injector\" title=\"src/app/injector.component.ts\">\n@Component({\n  selector: 'my-injectors',\n  template: `\n  &#x3C;h2>Other Injections&#x3C;/h2>\n  &#x3C;div id=\"car\">{{car.drive()}}&#x3C;/div>\n  &#x3C;div id=\"hero\">{{hero.name}}&#x3C;/div>\n  &#x3C;div id=\"rodent\">{{rodent}}&#x3C;/div>\n  `,\n  providers: [Car, Engine, Tires, heroServiceProvider, Logger]\n})\nexport class InjectorComponent implements OnInit {\n  car: Car;\n\n  heroService: HeroService;\n  hero: Hero;\n\n  constructor(private injector: Injector) { }\n\n  ngOnInit() {\n    this.car = this.injector.get(Car);\n    this.heroService = this.injector.get(HeroService);\n    this.hero = this.heroService.getHeroes()[0];\n  }\n\n  get rodent() {\n    let rousDontExist = `R.O.U.S.'s? I don't think they exist!`;\n    return this.injector.get(ROUS, rousDontExist);\n  }\n}\n\n</code-example>\n<p>An <code><a href=\"api/core/Injector\">Injector</a></code> is itself an injectable service.</p>\n<p>In this example, Angular injects the component's own <code><a href=\"api/core/Injector\">Injector</a></code> into the component's constructor.\nThe component then asks the injected injector for the services it wants in <code>ngOnInit()</code>.</p>\n<p>Note that the services themselves are not injected into the component.\nThey are retrieved by calling <code>injector.get()</code>.</p>\n<p>The <code>get()</code> method throws an error if it can't resolve the requested service.\nYou can call <code>get()</code> with a second parameter, which is the value to return if the service\nis not found. Angular can't find the service if it's not registered with this or any ancestor injector.</p>\n<div class=\"l-sub-section\">\n<p>The technique is an example of the\n<a href=\"https://en.wikipedia.org/wiki/Service_locator_pattern\">service locator pattern</a>.</p>\n<p><strong>Avoid</strong> this technique unless you genuinely need it.\nIt encourages a careless grab-bag approach such as you see here.\nIt's difficult to explain, understand, and test.\nYou can't know by inspecting the constructor what this class requires or what it will do.\nIt could acquire services from any ancestor component, not just its own.\nYou're forced to spelunk the implementation to discover what it does.</p>\n<p>Framework developers may take this approach when they\nmust acquire services generically and dynamically.</p>\n</div>\n<a id=\"one-class-per-file\"></a>\n<h2 id=\"appendix-why-have-one-class-per-file\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#appendix-why-have-one-class-per-file\"><i class=\"material-icons\">link</i></a>Appendix: Why have one class per file</h2>\n<p>Having multiple classes in the same file is confusing and best avoided.\nDevelopers expect one class per file. Keep them happy.</p>\n<p>If you combine the <code>HeroService</code> class with\nthe <code>HeroesComponent</code> in the same file,\n<strong>define the component last</strong>.\nIf you define the component before the service,\nyou'll get a runtime null reference error.</p>\n<div class=\"l-sub-section\">\n<p>You actually can define the component first with the help of the <code>forwardRef()</code> method as explained\nin this <a href=\"http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\">blog post</a>.\nBut why flirt with trouble?\nAvoid the problem altogether by defining components and services in separate files.</p>\n</div>\n\n</div>"
}