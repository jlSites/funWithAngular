{
  "id": "guide/testing",
  "title": "Testing",
  "contents": "\n<div class=\"content\">\n<h1 id=\"testing\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#testing\"><i class=\"material-icons\">link</i></a>Testing</h1>\n<p>This guide offers tips and techniques for testing Angular applications.\nThough this page includes some general testing principles and techniques,\nthe focus is on testing applications written with Angular.</p>\n<a id=\"top\"></a>\n<h2 id=\"live-examples\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#live-examples\"><i class=\"material-icons\">link</i></a>Live examples</h2>\n<p>This guide presents tests of a sample application that is much like the <a href=\"tutorial\"><em>Tour of Heroes</em> tutorial</a>.\nThe sample application and all tests in this guide are available as live examples for inspection, experiment, and download:</p>\n<ul>\n<li><live-example plnkr=\"1st-specs\" embedded-style=\"\">A spec to verify the test environment</live-example>.</li>\n<li><live-example plnkr=\"banner-inline-specs\" embedded-style=\"\">The first component spec with inline template</live-example>.</li>\n<li><live-example plnkr=\"banner-specs\" embedded-style=\"\">A component spec with external template</live-example>.</li>\n<li><live-example name=\"setup\" plnkr=\"quickstart-specs\" embedded-style=\"\">The QuickStart seed's AppComponent spec</live-example>.</li>\n<li><live-example embedded-style=\"\">The sample application to be tested</live-example>.</li>\n<li><live-example plnkr=\"app-specs\" embedded-style=\"\">All specs that test the sample application</live-example>.</li>\n<li><live-example plnkr=\"bag-specs\" embedded-style=\"\">A grab bag of additional specs</live-example>.<a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></li>\n</ul>\n<hr>\n<a id=\"testing-intro\"></a>\n<h2 id=\"introduction-to-angular-testing\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#introduction-to-angular-testing\"><i class=\"material-icons\">link</i></a>Introduction to Angular Testing</h2>\n<p>This page guides you through writing tests to explore\nand confirm the behavior of the application. Testing\ndoes the following:</p>\n<ol>\n<li>\n<p>Guards against changes that break existing code (“regressions”).</p>\n</li>\n<li>\n<p>Clarifies what the code does both when used as intended and when faced with deviant conditions.</p>\n</li>\n<li>\n<p>Reveals mistakes in design and implementation.\nTests shine a harsh light on the code from many angles.\nWhen a part of the application seems hard to test, the root cause is often a design flaw,\nsomething to cure now rather than later when it becomes expensive to fix.</p>\n</li>\n</ol>\n<!-- TODO\n:marked\n### Learn more\nLearn more about basic Jasmine testing here\n[Resources TBD](guide/)\n-->\n<a id=\"tools-and-tech\"></a>\n<h3 id=\"tools-and-technologies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#tools-and-technologies\"><i class=\"material-icons\">link</i></a>Tools and technologies</h3>\n<p>You can write and run Angular tests with a variety of tools and technologies.\nThis guide describes specific choices that are known to work well.</p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  \n  <col width=\"80%\">\n  \n  </colgroup><tbody><tr>\n    <th>\n      Technology\n    </th>\n    <th>\n      Purpose\n    </th>\n  </tr>\n  <tr style=\"top\">\n    <td style=\"vertical-align: top\">\n      Jasmine\n    </td>\n    <td>\n<p>      The <a href=\"http://jasmine.github.io/2.4/introduction.html\">Jasmine test framework</a>\nprovides everything needed to write basic tests.\nIt ships with an HTML test runner that executes tests in the browser.</p>\n    </td>\n  </tr>\n  <tr style=\"top\">\n    <td style=\"vertical-align: top\">\n      Angular testing utilities\n    </td>\n    <td>\n<p>      Angular testing utilities create a test environment\nfor the Angular application code under test.\nUse them to condition and control parts of the application as they\ninteract <em>within</em> the Angular environment.</p>\n    </td>\n  </tr>\n  <tr style=\"top\">\n    <td style=\"vertical-align: top\">\n      Karma\n    </td>\n    <td>\n<p>      The <a href=\"https://karma-runner.github.io/1.0/index.html\">karma test runner</a>\nis ideal for writing and running unit tests while developing the application.\nIt can be an integral part of the project's development and continuous integration processes.\nThis guide describes how to set up and run tests with karma.</p>\n    </td>\n  </tr>\n  <tr style=\"top\">\n    <td style=\"vertical-align: top\">\n      Protractor\n    </td>\n    <td>\n<p>      Use protractor to write and run <em>end-to-end</em> (e2e) tests.\nEnd-to-end tests explore the application <em>as users experience it</em>.\nIn e2e testing, one process runs the real application\nand a second process runs protractor tests that simulate user behavior\nand assert that the application respond in the browser as expected.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"setup\"></a>\n<h3 id=\"setup\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#setup\"><i class=\"material-icons\">link</i></a>Setup</h3>\n<p>There are two fast paths to getting started with unit testing.</p>\n<ol>\n<li>\n<p>Start a new project following the instructions in <a href=\"guide/setup\" title=\"Setup\">Setup</a>.</p>\n</li>\n<li>\n<p>Start a new project with the\n<a href=\"https://github.com/angular/angular-cli/blob/master/README.md\" title=\"Angular CLI\">Angular CLI</a>.</p>\n</li>\n</ol>\n<p>Both approaches install npm packages, files, and scripts pre-configured for applications\nbuilt in their respective modalities.\nTheir artifacts and procedures differ slightly but their essentials are the same\nand there are no differences in the test code.</p>\n<p>In this guide, the application and its tests are based on the <a href=\"guide/setup\" title=\"Setup\">setup instructions</a>.\nFor a discussion of the unit testing setup files, <a href=\"guide/testing#setup-files\">see below</a>.</p>\n<a id=\"isolated-v-testing-utilities\"></a>\n<h3 id=\"isolated-unit-tests-vs-the-angular-testing-utilites\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#isolated-unit-tests-vs-the-angular-testing-utilites\"><i class=\"material-icons\">link</i></a>Isolated unit tests vs. the Angular testing utilites</h3>\n<p><a href=\"guide/testing#isolated-unit-tests\" title=\"Unit testing without the Angular testing utilities\">Isolated unit tests</a>\nexamine an instance of a class all by itself without any dependence on Angular or any injected values.\nThe tester creates a test instance of the class with <code>new</code>, supplying test doubles for the constructor parameters as needed, and\nthen probes the test instance API surface.</p>\n<p><em>You should write isolated unit tests for pipes and services.</em></p>\n<p>You can test components in isolation as well.\nHowever, isolated unit tests don't reveal how components interact with Angular.\nIn particular, they can't reveal how a component class interacts with its own template or with other components.</p>\n<p>Such tests require the <strong>Angular testing utilities</strong>.\nThe  Angular testing utilities include the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> class and several helper functions from <code>@angular/core/testing</code>.\nThey are the main focus of this guide and you'll learn about them\nwhen you write your <a href=\"guide/testing#simple-component-test\">first component test</a>.\nA comprehensive review of the Angular testing utilities appears <a href=\"guide/testing#atu-apis\">later in this guide</a>.</p>\n<p>But first you should write a dummy test to verify that your test environment is set up properly\nand to lock in a few basic testing skills.\n<a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"1st-karma-test\"></a>\n<h2 id=\"the-first-karma-test\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-first-karma-test\"><i class=\"material-icons\">link</i></a>The first karma test</h2>\n<p>Start with a simple test to make sure that the setup works properly.</p>\n<p>Create a new file called <code>1st.spec.ts</code> in the application root folder, <code>src/app/</code></p>\n<div class=\"alert is-important\">\n<p>Tests written in Jasmine are called <em>specs</em> .\n<strong>The filename extension must be <code>.spec.ts</code></strong>,\nthe convention adhered to by  <code>karma.conf.js</code> and other tooling.</p>\n</div>\n<p><strong>Put spec files somewhere within the <code>src/app/</code> folder.</strong>\nThe <code>karma.conf.js</code> tells karma to look for spec files there,\nfor reasons explained <a href=\"guide/testing#q-spec-file-location\">below</a>.</p>\n<p>Add the following code to <code>src/app/1st.spec.ts</code>.</p>\n<code-example path=\"testing/src/app/1st.spec.ts\" title=\"src/app/1st.spec.ts\" linenums=\"false\">\ndescribe('1st tests', () => {\n  it('true is true', () => expect(true).toBe(true));\n});\n\n\n</code-example>\n<a id=\"run-karma\"></a>\n<h3 id=\"run-with-karma\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#run-with-karma\"><i class=\"material-icons\">link</i></a>Run with karma</h3>\n<p>Compile and run it in karma from the command line using the following command:</p>\n<code-example format=\".\" language=\"bash\">\n  npm test\n</code-example>\n<p>The command compiles the application and test code and starts karma.\nBoth processes watch pertinent files, write messages to the console, and re-run when they detect changes.</p>\n<div class=\"l-sub-section\">\n<p>The documentation setup defines the <code>test</code> command in the <code>scripts</code> section of npm's <code>package.json</code>.\nThe Angular CLI has different commands to do the same thing. Adjust accordingly.</p>\n</div>\n<p>After a few moments, karma opens a browser and starts writing to the console.</p>\n<figure>\n  <img src=\"generated/images/guide/testing/karma-browser.png\" alt=\"Karma browser\" width=\"400\" height=\"142\">\n</figure>\n<p>Hide (don't close!) the browser and focus on the console output, which\nshould look something like this:</p>\n<code-example format=\".\" language=\"bash\">\n  > npm test\n  ...\n  [0] 1:37:03 PM - Compilation complete. Watching for file changes.\n  ...\n  [1] Chrome 51.0.2704: Executed 0 of 0 SUCCESS\n      Chrome 51.0.2704: Executed 1 of 1 SUCCESS\n  SUCCESS (0.005 secs / 0.005 secs)\n\n</code-example>\n<p>Both the compiler and karma continue to run. The compiler output is preceded by <code>[0]</code>;\nthe karma output by <code>[1]</code>.</p>\n<p>Change the expectation from <code>true</code> to <code>false</code>.</p>\n<p>The <em>compiler</em> watcher detects the change and recompiles.</p>\n<code-example format=\".\" language=\"bash\">\n  [0] 1:49:21 PM - File change detected. Starting incremental compilation...\n  [0] 1:49:25 PM - Compilation complete. Watching for file changes.\n\n</code-example>\n<p>The <em>karma</em> watcher detects the change to the compilation output and re-runs the test.</p>\n<code-example format=\".\" language=\"bash\">\n  [1] Chrome 51.0.2704 1st tests true is true FAILED\n  [1] Expected false to equal true.\n  [1] Chrome 51.0.2704: Executed 1 of 1 (1 FAILED) (0.005 secs / 0.005 secs)\n\n</code-example>\n<p>It fails of course.</p>\n<p>Restore the expectation from <code>false</code> back to <code>true</code>.\nBoth processes detect the change, re-run, and karma reports complete success.</p>\n<div class=\"alert is-helpful\">\n<p>The console log can be quite long. Keep your eye on the last line.\nWhen all is well, it reads <code>SUCCESS</code>.</p>\n</div>\n<a id=\"test-debugging\"></a>\n<h3 id=\"test-debugging\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-debugging\"><i class=\"material-icons\">link</i></a>Test debugging</h3>\n<p>Debug specs in the browser in the same way that you debug an application.</p>\n<ol>\n<li>Reveal the karma browser window (hidden earlier).</li>\n<li>Click the <strong>DEBUG</strong> button; it opens a new browser tab and re-runs the tests.</li>\n<li>Open the browser's “Developer Tools” (<code>Ctrl-Shift-I</code> on windows; <code>Command-Option-I</code> in OSX).</li>\n<li>Pick the \"sources\" section.</li>\n<li>Open the <code>1st.spec.ts</code> test file (Control/Command-P, then start typing the name of the file).</li>\n<li>Set a breakpoint in the test.</li>\n<li>Refresh the browser, and it stops at the breakpoint.</li>\n</ol>\n<figure>\n  <img src=\"generated/images/guide/testing/karma-1st-spec-debug.png\" alt=\"Karma debugging\" width=\"700\" height=\"150\">\n</figure>\n<a id=\"live-karma-example\"></a>\n<h3 id=\"try-the-live-example\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#try-the-live-example\"><i class=\"material-icons\">link</i></a>Try the live example</h3>\n<p>You can also try this test as a <live-example plnkr=\"1st-specs\" title=\"First spec\" embedded-style=\"\"></live-example> in plunker.\nAll of the tests in this guide are available as <a href=\"guide/testing#live-examples\" title=\"Live examples of these tests\">live examples</a>.\n<a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"simple-component-test\"></a>\n<h2 id=\"test-a-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-a-component\"><i class=\"material-icons\">link</i></a>Test a component</h2>\n<p>An Angular component is the first thing most developers want to test.\nThe <code>BannerComponent</code> in <code>src/app/banner-inline.component.ts</code> is the simplest component in this application and\na good place to start.\nIt presents the application title at the top of the screen within an <code>&#x3C;h1></code> tag.</p>\n<code-example path=\"testing/src/app/banner-inline.component.ts\" title=\"src/app/banner-inline.component.ts\" linenums=\"false\">\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-banner',\n  template: '&#x3C;h1>{{title}}&#x3C;/h1>'\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n\n\n</code-example>\n<p>This version of the <code>BannerComponent</code> has an inline template and an interpolation binding.\nThe component is probably too simple to be worth testing in real life but\nit's perfect for a first encounter with the Angular testing utilities.</p>\n<p>The corresponding <code>src/app/banner-inline.component.spec.ts</code> sits in the same folder as the component,\nfor reasons explained in the <a href=\"guide/testing#faq\">FAQ</a> answer to\n<a href=\"guide/testing#q-spec-file-location\">\"Why put specs next to the things they test?\"</a>.</p>\n<p>Start with ES6 import statements to get access to symbols referenced in the spec.</p>\n<code-example path=\"testing/src/app/banner-inline.component.spec.ts\" region=\"imports\" title=\"src/app/banner-inline.component.spec.ts (imports)\" linenums=\"false\">\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { By }              from '@angular/platform-browser';\nimport { DebugElement }    from '@angular/core';\n\nimport { BannerComponent } from './banner-inline.component';\n\n</code-example>\n<a id=\"configure-testing-module\"></a>\n<p>Here's the <code>describe</code> and the <code>beforeEach</code> that precedes the tests:</p>\n<code-example path=\"testing/src/app/banner-inline.component.spec.ts\" region=\"setup\" title=\"src/app/banner-inline.component.spec.ts (beforeEach)\" linenums=\"false\">\ndescribe('BannerComponent (inline template)', () => {\n\n  let comp:    BannerComponent;\n  let fixture: ComponentFixture&#x3C;BannerComponent>;\n  let de:      DebugElement;\n  let el:      HTMLElement;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [ BannerComponent ], // declare the test component\n    });\n\n    fixture = TestBed.createComponent(BannerComponent);\n\n    comp = fixture.componentInstance; // BannerComponent test instance\n\n    // query for the title &#x3C;h1> by CSS element selector\n    de = fixture.debugElement.query(By.css('h1'));\n    el = de.nativeElement;\n  });\n});\n\n</code-example>\n<a id=\"testbed\"></a>\n<h3 id=\"testbed\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#testbed\"><i class=\"material-icons\">link</i></a><em>TestBed</em></h3>\n<p><code><a href=\"api/core/testing/TestBed\">TestBed</a></code> is the first and most important of the  Angular testing utilities.\nIt creates an Angular testing module—an <code>@NgModule</code> class—that\nyou configure with the <code>configureTestingModule</code> method to produce the module environment for the class you want to test.\nIn effect, you detach the tested component from its own application module\nand re-attach it to a dynamically-constructed Angular test module\ntailored specifically for this battery of tests.</p>\n<p>The <code>configureTestingModule</code> method takes an <code>@NgModule</code>-like metadata object.\nThe metadata object can have most of the properties of a normal <a href=\"guide/ngmodule\">NgModule</a>.</p>\n<p><em>This metadata object</em> simply declares the component to test, <code>BannerComponent</code>.\nThe metadata lack <code>imports</code> because (a) the default testing module configuration already has what <code>BannerComponent</code> needs\nand (b) <code>BannerComponent</code> doesn't interact with any other components.</p>\n<p>Call <code>configureTestingModule</code> within a <code>beforeEach</code> so that\n<code><a href=\"api/core/testing/TestBed\">TestBed</a></code> can reset itself to a base state before each test runs.</p>\n<p>The base state includes a default testing module configuration consisting of the\ndeclarables (components, directives, and pipes) and providers (some of them mocked)\nthat almost everyone needs.</p>\n<div class=\"l-sub-section\">\n<p>The testing shims mentioned <a href=\"guide/testing#testbed-methods\">later</a> initialize the testing module configuration\nto something like the <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code> from <code>@angular/platform-browser</code>.</p>\n</div>\n<p>This default configuration is merely a <em>foundation</em> for testing an app.\nLater you'll call <code>TestBed.configureTestingModule</code> with more metadata that define additional\nimports, declarations, providers, and schemas to fit your application tests.\nOptional <code>override</code> methods can fine-tune aspects of the configuration.</p>\n<a id=\"create-component\"></a>\n<h3 id=\"createcomponent\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#createcomponent\"><i class=\"material-icons\">link</i></a><em>createComponent</em></h3>\n<p>After configuring <code><a href=\"api/core/testing/TestBed\">TestBed</a></code>, you tell it to create an instance of the <em>component-under-test</em>.\nIn this example, <code>TestBed.createComponent</code> creates an instance of <code>BannerComponent</code> and\nreturns a <a href=\"guide/testing#component-fixture\"><em>component test fixture</em></a>.</p>\n<div class=\"alert is-important\">\n<p>Do not re-configure <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> after calling <code>createComponent</code>.</p>\n</div>\n<p>The <code>createComponent</code> method closes the current <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> instance to further configuration.\nYou cannot call any more <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> configuration methods, not <code>configureTestingModule</code>\nnor any of the <code>override...</code> methods. If you try, <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> throws an error.</p>\n<a id=\"component-fixture\"></a>\n<h3 id=\"componentfixture-debugelement-and-querybycss\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#componentfixture-debugelement-and-querybycss\"><i class=\"material-icons\">link</i></a><em>ComponentFixture</em>, <em>DebugElement</em>, and <em>query(By.css)</em></h3>\n<p>The <code>createComponent</code> method returns a <strong><code><a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a></code></strong>, a handle on the test environment surrounding the created component.\nThe fixture provides access to the component instance itself and\nto the <strong><code><a href=\"api/core/DebugElement\">DebugElement</a></code></strong>, which is a handle on the component's DOM element.</p>\n<p>The <code>title</code> property value is interpolated into the DOM within <code>&#x3C;h1></code> tags.\nUse the fixture's <code><a href=\"api/core/DebugElement\">DebugElement</a></code> to <code><a href=\"api/animations/query\">query</a></code> for the <code>&#x3C;h1></code> element by CSS selector.</p>\n<p>The <strong><code><a href=\"api/animations/query\">query</a></code></strong> method takes a predicate function and searches the fixture's entire DOM tree for the\n<em>first</em> element that satisfies the predicate.\nThe result is a <em>different</em> <code><a href=\"api/core/DebugElement\">DebugElement</a></code>, one associated with the matching DOM element.</p>\n<div class=\"l-sub-section\">\n<p>The <code>queryAll</code> method returns an array of <em>all</em> <code>DebugElements</code> that satisfy the predicate.</p>\n<p>A <em>predicate</em> is a function that returns a boolean.\nA query predicate receives a <code><a href=\"api/core/DebugElement\">DebugElement</a></code> and returns <code>true</code> if the element meets the selection criteria.</p>\n</div>\n<p>The <strong><code><a href=\"api/platform-browser/By\">By</a></code></strong> class is an Angular testing utility that produces useful predicates.\nIts <code>By.css</code> static method produces a\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors\">standard CSS selector</a>\npredicate that filters the same way as a jQuery selector.</p>\n<p>Finally, the setup assigns the DOM element from the <code><a href=\"api/core/DebugElement\">DebugElement</a></code> <strong><code>nativeElement</code></strong> property to <code>el</code>.\nThe tests assert that <code>el</code> contains the expected title text.</p>\n<a id=\"the-tests\"></a>\n<h3 id=\"the-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-tests\"><i class=\"material-icons\">link</i></a>The tests</h3>\n<p>Jasmine runs the <code>beforeEach</code> function before each of these tests</p>\n<code-example path=\"testing/src/app/banner-inline.component.spec.ts\" region=\"tests\" title=\"src/app/banner-inline.component.spec.ts (tests)\" linenums=\"false\">\nit('should display original title', () => {\n  fixture.detectChanges();\n  expect(el.textContent).toContain(comp.title);\n});\n\nit('should display a different test title', () => {\n  comp.title = 'Test Title';\n  fixture.detectChanges();\n  expect(el.textContent).toContain('Test Title');\n});\n\n</code-example>\n<p>These tests ask the <code><a href=\"api/core/DebugElement\">DebugElement</a></code> for the native HTML element to satisfy their expectations.</p>\n<a id=\"detect-changes\"></a>\n<h3 id=\"detectchanges-angular-change-detection-within-a-test\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#detectchanges-angular-change-detection-within-a-test\"><i class=\"material-icons\">link</i></a><em>detectChanges</em>: Angular change detection within a test</h3>\n<p>Each test tells Angular when to perform change detection by calling <code>fixture.detectChanges()</code>.\nThe first test does so immediately, triggering data binding and propagation of the <code>title</code> property\nto the DOM element.</p>\n<p>The second test changes the component's <code>title</code> property <em>and only then</em> calls <code>fixture.detectChanges()</code>;\nthe new value appears in the DOM element.</p>\n<p>In production, change detection kicks in automatically\nwhen Angular creates a component or the user enters a keystroke or\nan asynchronous activity (e.g., AJAX) completes.</p>\n<p>The <code>TestBed.createComponent</code> does <em>not</em> trigger change detection.\nThe fixture does not automatically push the component's <code>title</code> property value into the data bound element,\na fact demonstrated in the following test:</p>\n<code-example path=\"testing/src/app/banner-inline.component.spec.ts\" region=\"test-w-o-detect-changes\" title=\"src/app/banner-inline.component.spec.ts (no detectChanges)\" linenums=\"false\">\nit('no title in the DOM until manually call `detectChanges`', () => {\n  expect(el.textContent).toEqual('');\n});\n\n</code-example>\n<p>This behavior (or lack of it) is intentional.\nIt gives the tester an opportunity to inspect or change the state of\nthe component <em>before Angular initiates data binding or calls lifecycle hooks</em>.</p>\n<a id=\"try-example\"></a>\n<h3 id=\"try-the-live-example-1\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#try-the-live-example-1\"><i class=\"material-icons\">link</i></a>Try the live example</h3>\n<p>Take a moment to explore this component spec as a <live-example plnkr=\"banner-inline-specs\" title=\"Spec for component with inline template\" embedded-style=\"\"></live-example> and\nlock in these fundamentals of component unit testing.</p>\n<a id=\"auto-detect-changes\"></a>\n<h3 id=\"automatic-change-detection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#automatic-change-detection\"><i class=\"material-icons\">link</i></a>Automatic change detection</h3>\n<p>The <code>BannerComponent</code> tests frequently call <code>detectChanges</code>.\nSome testers prefer that the Angular test environment run change detection automatically.</p>\n<p>That's possible by configuring the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> with the <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\">ComponentFixtureAutoDetect</a></code> provider.\nFirst import it from the testing utility library:</p>\n<code-example path=\"testing/src/app/banner.component.detect-changes.spec.ts\" region=\"import-ComponentFixtureAutoDetect\" title=\"src/app/banner.component.detect-changes.spec.ts (import)\" linenums=\"false\">\nimport { ComponentFixtureAutoDetect } from '@angular/core/testing';\n\n</code-example>\n<p>Then add it to the <code>providers</code> array of the testing module configuration:</p>\n<code-example path=\"testing/src/app/banner.component.detect-changes.spec.ts\" region=\"auto-detect\" title=\"src/app/banner.component.detect-changes.spec.ts (AutoDetect)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [ BannerComponent ],\n  providers: [\n    { provide: ComponentFixtureAutoDetect, useValue: true }\n  ]\n})\n\n</code-example>\n<p>Here are three tests that illustrate how automatic change detection works.</p>\n<code-example path=\"testing/src/app/banner.component.detect-changes.spec.ts\" region=\"auto-detect-tests\" title=\"src/app/banner.component.detect-changes.spec.ts (AutoDetect Tests)\" linenums=\"false\">\nit('should display original title', () => {\n  // Hooray! No `fixture.detectChanges()` needed\n  expect(el.textContent).toContain(comp.title);\n});\n\nit('should still see original title after comp.title change', () => {\n  const oldTitle = comp.title;\n  comp.title = 'Test Title';\n  // Displayed title is old because Angular didn't hear the change :(\n  expect(el.textContent).toContain(oldTitle);\n});\n\nit('should display updated title after detectChanges', () => {\n  comp.title = 'Test Title';\n  fixture.detectChanges(); // detect changes explicitly\n  expect(el.textContent).toContain(comp.title);\n});\n\n</code-example>\n<p>The first test shows the benefit of automatic change detection.</p>\n<p>The second and third test reveal an important limitation.\nThe Angular testing environment does <em>not</em> know that the test changed the component's <code>title</code>.\nThe <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\">ComponentFixtureAutoDetect</a></code> service responds to <em>asynchronous activities</em> such as promise resolution, timers, and DOM events.\nBut a direct, synchronous update of the component property is invisible.\nThe test must call <code>fixture.detectChanges()</code> manually to trigger another cycle of change detection.</p>\n<div class=\"alert is-helpful\">\n<p>Rather than wonder when the test fixture will or won't perform change detection,\nthe samples in this guide <em>always call</em> <code>detectChanges()</code> <em>explicitly</em>.\nThere is no harm in calling <code>detectChanges()</code> more often than is strictly necessary.</p>\n</div>\n<p><a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"component-with-external-template\"></a>\n<h2 id=\"test-a-component-with-an-external-template\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-a-component-with-an-external-template\"><i class=\"material-icons\">link</i></a>Test a component with an external template</h2>\n<p>The application's actual <code>BannerComponent</code> behaves the same as the version above but is implemented differently.\nIt has <em>external</em> template and css files, specified in <code>templateUrl</code> and <code>styleUrls</code> properties.</p>\n<code-example path=\"testing/src/app/banner.component.ts\" title=\"src/app/banner.component.ts\" linenums=\"false\">\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-banner',\n  templateUrl: './banner.component.html',\n  styleUrls:  ['./banner.component.css']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n\n\n</code-example>\n<p>That's a problem for the tests.\nThe <code>TestBed.createComponent</code> method is synchronous.\nBut the Angular template compiler must read the external files from the file system before it can create a component instance.\nThat's an asynchronous activity.\nThe previous setup for testing the inline component won't work for a component with an external template.</p>\n<div id=\"async-in-before-each\">\n</div>\n<h3 id=\"the-first-asynchronous-beforeeach\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-first-asynchronous-beforeeach\"><i class=\"material-icons\">link</i></a>The first asynchronous <em>beforeEach</em></h3>\n<p>The test setup for <code>BannerComponent</code> must give the Angular template compiler time to read the files.\nThe logic in the <code>beforeEach</code> of the previous spec is split into two <code>beforeEach</code> calls.\nThe first <code>beforeEach</code> handles asynchronous compilation.</p>\n<code-example path=\"testing/src/app/banner.component.spec.ts\" region=\"async-before-each\" title=\"src/app/banner.component.spec.ts (first beforeEach)\" linenums=\"false\">\n// async beforeEach\nbeforeEach(async(() => {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ], // declare the test component\n  })\n  .compileComponents();  // compile template and css\n}));\n\n</code-example>\n<p>Notice the <code><a href=\"api/core/testing/async\">async</a></code> function called as the argument to <code>beforeEach</code>.\nThe <code><a href=\"api/core/testing/async\">async</a></code> function is one of the Angular testing utilities and\nhas to be imported.</p>\n<code-example path=\"testing/src/app/banner.component.detect-changes.spec.ts\" region=\"import-async\" title=\"src/app/banner.component.detect-changes.spec.ts\" linenums=\"false\">\nimport { async } from '@angular/core/testing';\n\n</code-example>\n<p>It takes a parameterless function and <em>returns a function</em>\nwhich becomes the true argument to the  <code>beforeEach</code>.</p>\n<p>The body of the <code><a href=\"api/core/testing/async\">async</a></code> argument looks much like the body of a synchronous <code>beforeEach</code>.\nThere is nothing obviously asynchronous about it.\nFor example, it doesn't return a promise and\nthere is no <code>done</code> function to call as there would be in standard Jasmine asynchronous tests.\nInternally, <code><a href=\"api/core/testing/async\">async</a></code> arranges for the body of the <code>beforeEach</code> to run in a special <em>async test zone</em>\nthat hides the mechanics of asynchronous execution.</p>\n<p>All this is necessary in order to call the asynchronous <code>TestBed.compileComponents</code> method.</p>\n<a id=\"compile-components\"></a>\n<h3 id=\"compilecomponents\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#compilecomponents\"><i class=\"material-icons\">link</i></a><em>compileComponents</em></h3>\n<p>The <code>TestBed.configureTestingModule</code> method returns the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> class so you can chain\ncalls to other <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> static methods such as <code>compileComponents</code>.</p>\n<p>The <code>TestBed.compileComponents</code> method asynchronously compiles all the components configured in the testing module.\nIn this example, the <code>BannerComponent</code> is the only component to compile.\nWhen <code>compileComponents</code> completes, the external templates and css files have been \"inlined\"\nand <code>TestBed.createComponent</code> can create new instances of <code>BannerComponent</code> synchronously.</p>\n<div class=\"l-sub-section\">\n<p>WebPack developers need not call <code>compileComponents</code> because it inlines templates and css\nas part of the automated build process that precedes running the test.</p>\n</div>\n<p>In this example, <code>TestBed.compileComponents</code> only compiles the <code>BannerComponent</code>.\nTests later in the guide declare multiple components and\na few specs import entire application modules that hold yet more components.\nAny of these components might have external templates and css files.\n<code>TestBed.compileComponents</code> compiles all of the declared components asynchronously at one time.</p>\n<div class=\"alert is-important\">\n<p>Do not configure the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> after calling <code>compileComponents</code>.\nMake <code>compileComponents</code> the last step\nbefore calling <code>TestBed.createComponent</code> to instantiate the <em>component-under-test</em>.</p>\n</div>\n<p>Calling <code>compileComponents</code> closes the current <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> instance to further configuration.\nYou cannot call any more <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> configuration methods, not <code>configureTestingModule</code>\nnor any of the <code>override...</code> methods. The <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> throws an error if you try.</p>\n<a id=\"second-before-each\"></a>\n<h3 id=\"the-second-synchronous-beforeeach\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-second-synchronous-beforeeach\"><i class=\"material-icons\">link</i></a>The second synchronous <em>beforeEach</em></h3>\n<p>A <em>synchronous</em> <code>beforeEach</code> containing the remaining setup steps follows the asynchronous <code>beforeEach</code>.</p>\n<code-example path=\"testing/src/app/banner.component.spec.ts\" region=\"sync-before-each\" title=\"src/app/banner.component.spec.ts (second beforeEach)\" linenums=\"false\">\n// synchronous beforeEach\nbeforeEach(() => {\n  fixture = TestBed.createComponent(BannerComponent);\n\n  comp = fixture.componentInstance; // BannerComponent test instance\n\n  // query for the title &#x3C;h1> by CSS element selector\n  de = fixture.debugElement.query(By.css('h1'));\n  el = de.nativeElement;\n});\n\n</code-example>\n<p>These are the same steps as in the original <code>beforeEach</code>.\nThey include creating an instance of the <code>BannerComponent</code> and querying for the elements to inspect.</p>\n<p>You can count on the test runner to wait for the first asynchronous <code>beforeEach</code> to finish before calling the second.</p>\n<a id=\"waiting-compile-components\"></a>\n<h3 id=\"waiting-for-compilecomponents\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#waiting-for-compilecomponents\"><i class=\"material-icons\">link</i></a>Waiting for <em>compileComponents</em></h3>\n<p>The <code>compileComponents</code> method returns a promise so you can perform additional tasks <em>immediately after</em> it finishes.\nFor example, you could move the synchronous code in the second <code>beforeEach</code>\ninto a <code>compileComponents().then(...)</code> callback and write only one <code>beforeEach</code>.</p>\n<p>Most developers find that hard to read.\nThe two <code>beforeEach</code> calls are widely preferred.</p>\n<a id=\"live-external-template-example\"></a>\n<h3 id=\"try-the-live-example-2\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#try-the-live-example-2\"><i class=\"material-icons\">link</i></a>Try the live example</h3>\n<p>Take a moment to explore this component spec as a <live-example plnkr=\"banner-specs\" title=\"Spec for component with external template\" embedded-style=\"\"></live-example>.</p>\n<div class=\"l-sub-section\">\n<p>The <a href=\"guide/setup\">Quickstart seed</a> provides a similar test of its <code>AppComponent</code>\nas you can see in <em>this</em> <live-example name=\"setup\" plnkr=\"quickstart-specs\" title=\"QuickStart seed spec\" embedded-style=\"\"></live-example>.\nIt too calls <code>compileComponents</code> although it doesn't have to because the <code>AppComponent</code>'s template is inline.</p>\n<p>There's no harm in it and you might call <code>compileComponents</code> anyway\nin case you decide later to re-factor the template into a separate file.\nThe tests in this guide only call <code>compileComponents</code> when necessary.</p>\n</div>\n<p><a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"component-with-dependency\"></a>\n<h2 id=\"test-a-component-with-a-dependency\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-a-component-with-a-dependency\"><i class=\"material-icons\">link</i></a>Test a component with a dependency</h2>\n<p>Components often have service dependencies.</p>\n<p>The <code>WelcomeComponent</code> displays a welcome message to the logged in user.\nIt knows who the user is based on a property of the injected <code>UserService</code>:</p>\n<code-example path=\"testing/src/app/welcome.component.ts\" title=\"src/app/welcome.component.ts\" linenums=\"false\">\nimport { Component, OnInit } from '@angular/core';\nimport { UserService }       from './model';\n\n@Component({\n  selector: 'app-welcome',\n  template: '&#x3C;h3 class=\"welcome\" >&#x3C;i>{{welcome}}&#x3C;/i>&#x3C;/h3>'\n})\nexport class WelcomeComponent  implements OnInit {\n  welcome = '-- not initialized yet --';\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name :\n      'Please log in.';\n  }\n}\n\n\n</code-example>\n<p>The <code>WelcomeComponent</code> has decision logic that interacts with the service, logic that makes this component worth testing.\nHere's the testing module configuration for the spec file, <code>src/app/welcome.component.spec.ts</code>:</p>\n<code-example path=\"testing/src/app/welcome.component.spec.ts\" region=\"config-test-module\" title=\"src/app/welcome.component.spec.ts\" linenums=\"false\">\nTestBed.configureTestingModule({\n   declarations: [ WelcomeComponent ],\n// providers:    [ UserService ]  // NO! Don't provide the real service!\n                                  // Provide a test-double instead\n   providers:    [ {provide: UserService, useValue: userServiceStub } ]\n});\n\n</code-example>\n<p>This time, in addition to declaring the <em>component-under-test</em>,\nthe configuration adds a <code>UserService</code> provider to the <code>providers</code> list.\nBut not the real <code>UserService</code>.</p>\n<a id=\"service-test-doubles\"></a>\n<h3 id=\"provide-service-test-doubles\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#provide-service-test-doubles\"><i class=\"material-icons\">link</i></a>Provide service test doubles</h3>\n<p>A <em>component-under-test</em> doesn't have to be injected with real services.\nIn fact, it is usually better if they are test doubles (stubs, fakes, spies, or mocks).\nThe purpose of the spec is to test the component, not the service,\nand real services can be trouble.</p>\n<p>Injecting the real <code>UserService</code> could be a nightmare.\nThe real service might ask the user for login credentials and\nattempt to reach an authentication server.\nThese behaviors can be hard to intercept.\nIt is far easier and safer to create and register a test double in place of the real <code>UserService</code>.</p>\n<p>This particular test suite supplies a minimal <code>UserService</code> stub that satisfies the needs of the <code>WelcomeComponent</code>\nand its tests:</p>\n<code-example path=\"testing/src/app/welcome.component.spec.ts\" region=\"user-service-stub\" title=\"src/app/welcome.component.spec.ts\" linenums=\"false\">\nuserServiceStub = {\n  isLoggedIn: true,\n  user: { name: 'Test User'}\n};\n\n</code-example>\n<a id=\"get-injected-service\"></a>\n<h3 id=\"get-injected-services\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#get-injected-services\"><i class=\"material-icons\">link</i></a>Get injected services</h3>\n<p>The tests need access to the (stub) <code>UserService</code> injected into the <code>WelcomeComponent</code>.</p>\n<p>Angular has a hierarchical injection system.\nThere can be injectors at multiple levels, from the root injector created by the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code>\ndown through the component tree.</p>\n<p>The safest way to get the injected service, the way that <strong><em>always works</em></strong>,\nis to <strong>get it from the injector of the <em>component-under-test</em></strong>.\nThe component injector is a property of the fixture's <code><a href=\"api/core/DebugElement\">DebugElement</a></code>.</p>\n<code-example path=\"testing/src/app/welcome.component.spec.ts\" region=\"injected-service\" title=\"WelcomeComponent&#x27;s injector\" linenums=\"false\">\n// UserService actually injected into the component\nuserService = fixture.debugElement.injector.get(UserService);\n\n</code-example>\n<a id=\"testbed-get\"></a>\n<h3 id=\"testbedget\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#testbedget\"><i class=\"material-icons\">link</i></a><em>TestBed.get</em></h3>\n<p>You <em>may</em> also be able to get the service from the root injector via <code>TestBed.get</code>.\nThis is easier to remember and less verbose.\nBut it only works when Angular injects the component with the service instance in the test's root injector.\nFortunately, in this test suite, the <em>only</em> provider of <code>UserService</code> is the root testing module,\nso it is safe to call <code>TestBed.get</code> as follows:</p>\n<code-example path=\"testing/src/app/welcome.component.spec.ts\" region=\"inject-from-testbed\" title=\"TestBed injector\" linenums=\"false\">\n// UserService from the root injector\nuserService = TestBed.get(UserService);\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>The <a href=\"guide/testing#inject\"><code><a href=\"api/core/testing/inject\">inject</a></code></a>  utility function is another way to get one or more services from the test root injector.</p>\n<p>For a use case in which <code><a href=\"api/core/testing/inject\">inject</a></code> and <code>TestBed.get</code> do not work,\nsee the section <a href=\"guide/testing#component-override\"><em>Override a component's providers</em></a>, which\nexplains why you must get the service from the component's injector instead.</p>\n</div>\n<a id=\"service-from-injector\"></a>\n<h3 id=\"always-get-the-service-from-an-injector\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#always-get-the-service-from-an-injector\"><i class=\"material-icons\">link</i></a>Always get the service from an injector</h3>\n<p>Do <em>not</em> reference the <code>userServiceStub</code> object\nthat's provided to the testing module in the body of your test.\n<strong>It does not work!</strong>\nThe <code>userService</code> instance injected into the component is a completely <em>different</em> object,\na clone of the provided <code>userServiceStub</code>.</p>\n<code-example path=\"testing/src/app/welcome.component.spec.ts\" region=\"stub-not-injected\" title=\"src/app/welcome.component.spec.ts\" linenums=\"false\">\nit('stub object and injected UserService should not be the same', () => {\n  expect(userServiceStub === userService).toBe(false);\n\n  // Changing the stub object has no effect on the injected service\n  userServiceStub.isLoggedIn = false;\n  expect(userService.isLoggedIn).toBe(true);\n});\n\n</code-example>\n<a id=\"welcome-spec-setup\"></a>\n<h3 id=\"final-setup-and-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#final-setup-and-tests\"><i class=\"material-icons\">link</i></a>Final setup and tests</h3>\n<p>Here's the complete <code>beforeEach</code> using <code>TestBed.get</code>:</p>\n<code-example path=\"testing/src/app/welcome.component.spec.ts\" region=\"setup\" title=\"src/app/welcome.component.spec.ts\" linenums=\"false\">\nbeforeEach(() => {\n  // stub UserService for test purposes\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User'}\n  };\n\n  TestBed.configureTestingModule({\n     declarations: [ WelcomeComponent ],\n     providers:    [ {provide: UserService, useValue: userServiceStub } ]\n  });\n\n  fixture = TestBed.createComponent(WelcomeComponent);\n  comp    = fixture.componentInstance;\n\n  // UserService from the root injector\n  userService = TestBed.get(UserService);\n\n  //  get the \"welcome\" element by CSS selector (e.g., by class name)\n  de = fixture.debugElement.query(By.css('.welcome'));\n  el = de.nativeElement;\n});\n\n</code-example>\n<p>And here are some tests:</p>\n<code-example path=\"testing/src/app/welcome.component.spec.ts\" region=\"tests\" title=\"src/app/welcome.component.spec.ts\" linenums=\"false\">\nit('should welcome the user', () => {\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).toContain('Welcome', '\"Welcome ...\"');\n  expect(content).toContain('Test User', 'expected name');\n});\n\nit('should welcome \"Bubba\"', () => {\n  userService.user.name = 'Bubba'; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  expect(el.textContent).toContain('Bubba');\n});\n\nit('should request login if not logged in', () => {\n  userService.isLoggedIn = false; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).not.toContain('Welcome', 'not welcomed');\n  expect(content).toMatch(/log in/i, '\"log in\"');\n});\n\n</code-example>\n<p>The first is a sanity test; it confirms that the stubbed <code>UserService</code> is called and working.</p>\n<div class=\"l-sub-section\">\n<p>The second parameter to the Jasmine matcher (e.g., <code>'expected name'</code>) is an optional addendum.\nIf the expectation fails, Jasmine displays this addendum after the expectation failure message.\nIn a spec with multiple expectations, it can help clarify what went wrong and which expectation failed.</p>\n</div>\n<p>The remaining tests confirm the logic of the component when the service returns different values.\nThe second test validates the effect of changing the user name.\nThe third test checks that the component displays the proper message when there is no logged-in user.\n<a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"component-with-async-service\"></a>\n<h2 id=\"test-a-component-with-an-async-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-a-component-with-an-async-service\"><i class=\"material-icons\">link</i></a>Test a component with an async service</h2>\n<p>Many services return values asynchronously.\nMost data services make an HTTP request to a remote server and the response is necessarily asynchronous.</p>\n<p>The \"About\" view in this sample displays Mark Twain quotes.\nThe <code>TwainComponent</code> handles the display, delegating the server request to the <code>TwainService</code>.</p>\n<p>Both are in the <code>src/app/shared</code> folder because the author intends to display Twain quotes on other pages someday.\nHere is the <code>TwainComponent</code>.</p>\n<code-example path=\"testing/src/app/shared/twain.component.ts\" region=\"component\" title=\"src/app/shared/twain.component.ts\" linenums=\"false\">\n@Component({\n  selector: 'twain-quote',\n  template: '&#x3C;p class=\"twain\">&#x3C;i>{{quote}}&#x3C;/i>&#x3C;/p>'\n})\nexport class TwainComponent  implements OnInit {\n  intervalId: number;\n  quote = '...';\n  constructor(private twainService: TwainService) { }\n\n  ngOnInit(): void {\n    this.twainService.getQuote().then(quote => this.quote = quote);\n  }\n}\n\n</code-example>\n<p>The <code>TwainService</code> implementation is irrelevant for this particular test.\nIt is sufficient to see within <code>ngOnInit</code> that <code>twainService.getQuote</code> returns a promise, which means it is asynchronous.</p>\n<p>In general, tests should not make calls to remote servers.\nThey should emulate such calls. The setup in this <code>src/app/shared/twain.component.spec.ts</code> shows one way to do that:</p>\n<code-example path=\"testing/src/app/shared/twain.component.spec.ts\" region=\"setup\" title=\"src/app/shared/twain.component.spec.ts (setup)\" linenums=\"false\">\nbeforeEach(() => {\n  TestBed.configureTestingModule({\n     declarations: [ TwainComponent ],\n     providers:    [ TwainService ],\n  });\n\n  fixture = TestBed.createComponent(TwainComponent);\n  comp    = fixture.componentInstance;\n\n  // TwainService actually injected into the component\n  twainService = fixture.debugElement.injector.get(TwainService);\n\n  // Setup spy on the `getQuote` method\n  spy = spyOn(twainService, 'getQuote')\n        .and.returnValue(Promise.resolve(testQuote));\n\n  // Get the Twain quote element by CSS selector (e.g., by class name)\n  de = fixture.debugElement.query(By.css('.twain'));\n  el = de.nativeElement;\n});\n\n</code-example>\n<a id=\"service-spy\"></a>\n<h3 id=\"spying-on-the-real-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#spying-on-the-real-service\"><i class=\"material-icons\">link</i></a>Spying on the real service</h3>\n<p>This setup is similar to the <a href=\"guide/testing#welcome-spec-setup\"><code>welcome.component.spec</code> setup</a>.\nBut instead of creating a stubbed service object, it injects the <em>real</em> service (see the testing module <code>providers</code>) and\nreplaces the critical <code>getQuote</code> method with a Jasmine spy.</p>\n<code-example path=\"testing/src/app/shared/twain.component.spec.ts\" region=\"spy\" title=\"src/app/shared/twain.component.spec.ts\" linenums=\"false\">\nspy = spyOn(twainService, 'getQuote')\n      .and.returnValue(Promise.resolve(testQuote));\n\n</code-example>\n<p>The spy is designed such that any call to <code>getQuote</code> receives an immediately resolved promise with a test quote.\nThe spy bypasses the actual <code>getQuote</code> method and therefore does not contact the server.</p>\n<div class=\"l-sub-section\">\n<p>Faking a service instance and spying on the real service are <em>both</em> great options.\nPick the one that seems easiest for the current test suite.\nDon't be afraid to change your mind.</p>\n<p>Spying on the real service isn't always easy, especially when the real service has injected dependencies.\nYou can <em>stub and spy</em> at the same time, as shown in <a href=\"guide/testing#spy-stub\">an example below</a>.</p>\n</div>\n<p>Here are the tests with commentary to follow:</p>\n<code-example path=\"testing/src/app/shared/twain.component.spec.ts\" region=\"tests\" title=\"src/app/shared/twain.component.spec.ts (tests)\">\nit('should not show quote before OnInit', () => {\n  expect(el.textContent).toBe('', 'nothing displayed');\n  expect(spy.calls.any()).toBe(false, 'getQuote not yet called');\n});\n\nit('should still not show quote after component initialized', () => {\n  fixture.detectChanges();\n  // getQuote service is async => still has not returned with quote\n  expect(el.textContent).toBe('...', 'no quote yet');\n  expect(spy.calls.any()).toBe(true, 'getQuote called');\n});\n\nit('should show quote after getQuote promise (async)', async(() => {\n  fixture.detectChanges();\n\n  fixture.whenStable().then(() => { // wait for async getQuote\n    fixture.detectChanges();        // update view with quote\n    expect(el.textContent).toBe(testQuote);\n  });\n}));\n\nit('should show quote after getQuote promise (fakeAsync)', fakeAsync(() => {\n  fixture.detectChanges();\n  tick();                  // wait for async getQuote\n  fixture.detectChanges(); // update view with quote\n  expect(el.textContent).toBe(testQuote);\n}));\n\n</code-example>\n<a id=\"sync-tests\"></a>\n<h3 id=\"synchronous-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#synchronous-tests\"><i class=\"material-icons\">link</i></a>Synchronous tests</h3>\n<p>The first two tests are synchronous.\nThanks to the spy, they verify that <code>getQuote</code> is called <em>after</em>\nthe first change detection cycle during which Angular calls <code>ngOnInit</code>.</p>\n<p>Neither test can prove that a value from the service is displayed.\nThe quote itself has not arrived, despite the fact that the spy returns a resolved promise.</p>\n<p>This test must wait at least one full turn of the JavaScript engine before the\nvalue becomes available. The test must become <em>asynchronous</em>.</p>\n<a id=\"async\"></a>\n<h3 id=\"the-async-function-in-it\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-async-function-in-it\"><i class=\"material-icons\">link</i></a>The <em>async</em> function in <em>it</em></h3>\n<p>Notice the <code><a href=\"api/core/testing/async\">async</a></code> in the third test.</p>\n<code-example path=\"testing/src/app/shared/twain.component.spec.ts\" region=\"async-test\" title=\"src/app/shared/twain.component.spec.ts (async test)\" linenums=\"false\">\nit('should show quote after getQuote promise (async)', async(() => {\n  fixture.detectChanges();\n\n  fixture.whenStable().then(() => { // wait for async getQuote\n    fixture.detectChanges();        // update view with quote\n    expect(el.textContent).toBe(testQuote);\n  });\n}));\n\n</code-example>\n<p>The <code><a href=\"api/core/testing/async\">async</a></code> function is one of the Angular testing utilities.\nIt simplifies coding of asynchronous tests by arranging for the tester's code to run in a special <em>async test zone</em>\nas <a href=\"guide/testing#async-in-before-each\">discussed earlier</a> when it was called in a <code>beforeEach</code>.</p>\n<p>Although <code><a href=\"api/core/testing/async\">async</a></code> does a great job of hiding asynchronous boilerplate,\nsome functions called within a test (such as <code>fixture.whenStable</code>) continue to reveal their asynchronous behavior.</p>\n<div class=\"l-sub-section\">\n<p>The <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code> alternative, <a href=\"guide/testing#fake-async\">covered below</a>, removes this artifact and affords a more linear coding experience.</p>\n</div>\n<a id=\"when-stable\"></a>\n<h3 id=\"whenstable\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#whenstable\"><i class=\"material-icons\">link</i></a><em>whenStable</em></h3>\n<p>The test must wait for the <code>getQuote</code> promise to resolve in the next turn of the JavaScript engine.</p>\n<p>This test has no direct access to the promise returned by the call to <code>twainService.getQuote</code>\nbecause it is buried inside <code>TwainComponent.ngOnInit</code> and therefore inaccessible to a test that\nprobes only the component API surface.</p>\n<p>Fortunately, the <code>getQuote</code> promise is accessible to the <em>async test zone</em>,\nwhich intercepts all promises issued within the <em>async</em> method call <em>no matter where they occur</em>.</p>\n<p>The <code>ComponentFixture.whenStable</code> method returns its own promise, which\nresolves when the <code>getQuote</code> promise finishes.\nIn fact, the <em>whenStable</em> promise resolves when <em>all pending\nasynchronous activities within this test</em> complete—the definition of \"stable.\"</p>\n<p>Then the test resumes and kicks off another round of change detection (<code>fixture.detectChanges</code>),\nwhich tells Angular to update the DOM with the quote.\nThe <code>getQuote</code> helper method extracts the display element text and the expectation confirms that the text matches the test quote.</p>\n<a id=\"fakeAsync\"></a>\n<a id=\"fake-async\"></a>\n<h3 id=\"the-fakeasync-function\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-fakeasync-function\"><i class=\"material-icons\">link</i></a>The <em>fakeAsync</em> function</h3>\n<p>The fourth test verifies the same component behavior in a different way.</p>\n<code-example path=\"testing/src/app/shared/twain.component.spec.ts\" region=\"fake-async-test\" title=\"src/app/shared/twain.component.spec.ts (fakeAsync test)\" linenums=\"false\">\nit('should show quote after getQuote promise (fakeAsync)', fakeAsync(() => {\n  fixture.detectChanges();\n  tick();                  // wait for async getQuote\n  fixture.detectChanges(); // update view with quote\n  expect(el.textContent).toBe(testQuote);\n}));\n\n</code-example>\n<p>Notice that <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code> replaces <code><a href=\"api/core/testing/async\">async</a></code> as the <code>it</code> argument.\nThe <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code> function is another of the Angular testing utilities.</p>\n<p>Like <a href=\"guide/testing#async\">async</a>, it <em>takes</em> a parameterless function and <em>returns</em> a function\nthat becomes the argument to the  Jasmine <code>it</code> call.</p>\n<p>The <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code> function enables a linear coding style by running the test body in a special <em>fakeAsync test zone</em>.</p>\n<p>The principle advantage of <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code> over <code><a href=\"api/core/testing/async\">async</a></code> is that the test appears to be synchronous.\nThere is no <code>then(...)</code> to disrupt the visible flow of control.\nThe promise-returning <code>fixture.whenStable</code> is gone, replaced by <code>tick()</code>.</p>\n<div class=\"l-sub-section\">\n<p>There <em>are</em> limitations. For example, you cannot make an XHR call from within a <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code>.</p>\n</div>\n<a id=\"tick\"></a>\n<h3 id=\"the-tick-function\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-tick-function\"><i class=\"material-icons\">link</i></a>The <em>tick</em> function</h3>\n<p>The <code><a href=\"api/core/testing/tick\">tick</a></code> function is one of the Angular testing utilities and a companion to <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code>.\nYou can only call it within a <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code> body.</p>\n<p>Calling <code>tick()</code> simulates the passage of time until all pending asynchronous activities finish,\nincluding the resolution of the <code>getQuote</code> promise in this test case.</p>\n<p>It returns nothing. There is no promise to wait for.\nProceed with the same test code that appeared in the <code>whenStable.then()</code> callback.</p>\n<p>Even this simple example is easier to read than the third test.\nTo more fully appreciate the improvement, imagine a succession of asynchronous operations,\nchained in a long sequence of promise callbacks.</p>\n<a id=\"jasmine-done\"></a>\n<h3 id=\"jasminedone\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#jasminedone\"><i class=\"material-icons\">link</i></a><em>jasmine.done</em></h3>\n<p>While the <code><a href=\"api/core/testing/async\">async</a></code> and <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code> functions greatly\nsimplify Angular asynchronous testing,\nyou can still fall back to the traditional Jasmine asynchronous testing technique.</p>\n<p>You can still pass <code>it</code> a function that takes a\n<a href=\"http://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\"><code>done</code> callback</a>.\nNow you are responsible for chaining promises, handling errors, and calling <code>done</code> at the appropriate moment.</p>\n<p>Here is a <code>done</code> version of the previous two tests:</p>\n<code-example path=\"testing/src/app/shared/twain.component.spec.ts\" region=\"done-test\" title=\"src/app/shared/twain.component.spec.ts (done test)\" linenums=\"false\">\nit('should show quote after getQuote promise (done)', (done: any) => {\n  fixture.detectChanges();\n\n  // get the spy promise and wait for it to resolve\n  spy.calls.mostRecent().returnValue.then(() => {\n    fixture.detectChanges(); // update view with quote\n    expect(el.textContent).toBe(testQuote);\n    done();\n  });\n});\n\n</code-example>\n<p>Although there is no direct access to the <code>getQuote</code> promise inside <code>TwainComponent</code>,\nthe spy has direct access, which makes it possible to wait for <code>getQuote</code> to finish.</p>\n<p>Writing test functions with <code>done</code>, while more cumbersome than <code><a href=\"api/core/testing/async\">async</a></code>\nand <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code>, is a viable and occasionally necessary technique.\nFor example, you can't call <code><a href=\"api/core/testing/async\">async</a></code> or <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code> when testing\ncode that involves the <code>intervalTimer</code>, as is common when\ntesting async <code>Observable</code> methods.\n<a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"component-with-input-output\"></a>\n<h2 id=\"test-a-component-with-inputs-and-outputs\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-a-component-with-inputs-and-outputs\"><i class=\"material-icons\">link</i></a>Test a component with inputs and outputs</h2>\n<p>A component with inputs and outputs typically appears inside the view template of a host component.\nThe host uses a property binding to set the input property and an event binding to\nlisten to events raised by the output property.</p>\n<p>The testing goal is to verify that such bindings work as expected.\nThe tests should set input values and listen for output events.</p>\n<p>The <code>DashboardHeroComponent</code> is a tiny example of a component in this role.\nIt displays an individual hero provided by the <code>DashboardComponent</code>.\nClicking that hero tells the <code>DashboardComponent</code> that the user has selected the hero.</p>\n<p>The <code>DashboardHeroComponent</code> is embedded in the <code>DashboardComponent</code> template like this:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.html\" region=\"dashboard-hero\" title=\"src/app/dashboard/dashboard.component.html (excerpt)\" linenums=\"false\">\n&#x3C;dashboard-hero *ngFor=\"let hero of heroes\"  class=\"col-1-4\"\n  [hero]=hero  (selected)=\"gotoDetail($event)\" >\n&#x3C;/dashboard-hero>\n\n</code-example>\n<p>The <code>DashboardHeroComponent</code> appears in an <code>*ngFor</code> repeater, which sets each component's <code>hero</code> input property\nto the looping value and listens for the component's <code>selected</code> event.</p>\n<p>Here's the component's definition:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"component\" title=\"src/app/dashboard/dashboard-hero.component.ts (component)\" linenums=\"false\">\n@Component({\n  selector:    'dashboard-hero',\n  templateUrl: './dashboard-hero.component.html',\n  styleUrls: [ './dashboard-hero.component.css' ]\n})\nexport class DashboardHeroComponent {\n  @Input() hero: Hero;\n  @Output() selected = new EventEmitter&#x3C;Hero>();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n<p>While testing a component this simple has little intrinsic value, it's worth knowing how.\nYou can use one of these approaches:</p>\n<ul>\n<li>Test it as used by <code>DashboardComponent</code>.</li>\n<li>Test it as a stand-alone component.</li>\n<li>Test it as used by a substitute for <code>DashboardComponent</code>.</li>\n</ul>\n<p>A quick look at the <code>DashboardComponent</code> constructor discourages the first approach:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" title=\"src/app/dashboard/dashboard.component.ts (constructor)\" linenums=\"false\">\nconstructor(\n  private router: Router,\n  private heroService: HeroService) {\n}\n\n</code-example>\n<p>The <code>DashboardComponent</code> depends on the Angular router and the <code>HeroService</code>.\nYou'd probably have to replace them both with test doubles, which is a lot of work.\nThe router seems particularly challenging.</p>\n<div class=\"l-sub-section\">\n<p>The <a href=\"guide/testing#routed-component\">discussion below</a> covers testing components that require the router.</p>\n</div>\n<p>The immediate goal is to test the <code>DashboardHeroComponent</code>, not the <code>DashboardComponent</code>,\nso, try the second and third options.</p>\n<a id=\"dashboard-standalone\"></a>\n<h3 id=\"test-dashboardherocomponent-stand-alone\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-dashboardherocomponent-stand-alone\"><i class=\"material-icons\">link</i></a>Test <em>DashboardHeroComponent</em> stand-alone</h3>\n<p>Here's the spec file setup.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"setup\" title=\"src/app/dashboard/dashboard-hero.component.spec.ts (setup)\" linenums=\"false\">\n// async beforeEach\nbeforeEach( async(() => {\n  TestBed.configureTestingModule({\n    declarations: [ DashboardHeroComponent ],\n  })\n  .compileComponents(); // compile template and css\n}));\n\n// synchronous beforeEach\nbeforeEach(() => {\n  fixture = TestBed.createComponent(DashboardHeroComponent);\n  comp    = fixture.componentInstance;\n  heroEl  = fixture.debugElement.query(By.css('.hero')); // find hero element\n\n  // pretend that it was wired to something that supplied a hero\n  expectedHero = new Hero(42, 'Test Name');\n  comp.hero = expectedHero;\n  fixture.detectChanges(); // trigger initial data binding\n});\n\n</code-example>\n<p>The async <code>beforeEach</code> was discussed <a href=\"guide/testing#component-with-external-template\">above</a>.\nHaving compiled the components asynchronously with <code>compileComponents</code>, the rest of the setup\nproceeds <em>synchronously</em> in a <em>second</em> <code>beforeEach</code>, using the basic techniques described <a href=\"guide/testing#simple-component-test\">earlier</a>.</p>\n<p>Note how the setup code assigns a test hero (<code>expectedHero</code>) to the component's <code>hero</code> property, emulating\nthe way the <code>DashboardComponent</code> would set it via the property binding in its repeater.</p>\n<p>The first test follows:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"name-test\" title=\"src/app/dashboard/dashboard-hero.component.spec.ts (name test)\" linenums=\"false\">\nit('should display hero name', () => {\n  const expectedPipedName = expectedHero.name.toUpperCase();\n  expect(heroEl.nativeElement.textContent).toContain(expectedPipedName);\n});\n\n</code-example>\n<p>It verifies that the hero name is propagated to template with a binding.\nBecause the template passes the hero name through the Angular <code><a href=\"api/common/UpperCasePipe\">UpperCasePipe</a></code>,\nthe test must match the element value with the uppercased name:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.html\" title=\"src/app/dashboard/dashboard-hero.component.html\" linenums=\"false\">\n&#x3C;div (click)=\"click()\" class=\"hero\">\n  {{hero.name | uppercase}}\n&#x3C;/div>\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>This small test demonstrates how Angular tests can verify a component's visual\nrepresentation—something not possible with\n<a href=\"guide/testing#isolated-component-tests\">isolated unit tests</a>—at\nlow cost and without resorting to much slower and more complicated end-to-end tests.</p>\n</div>\n<p>The second test verifies click behavior. Clicking the hero should raise a <code>selected</code> event that the\nhost component (<code>DashboardComponent</code> presumably) can hear:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test\" title=\"src/app/dashboard/dashboard-hero.component.spec.ts (click test)\" linenums=\"false\">\nit('should raise selected event when clicked', () => {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) => selectedHero = hero);\n\n  heroEl.triggerEventHandler('click', null);\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p>The component exposes an <code><a href=\"api/core/EventEmitter\">EventEmitter</a></code> property. The test subscribes to it just as the host component would do.</p>\n<p>The <code>heroEl</code> is a <code><a href=\"api/core/DebugElement\">DebugElement</a></code> that represents the hero <code>&#x3C;div></code>.\nThe test calls <code>triggerEventHandler</code> with the \"click\" event name.\nThe \"click\" event binding responds by calling <code>DashboardHeroComponent.click()</code>.</p>\n<p>If the component behaves as expected, <code>click()</code> tells the component's <code>selected</code> property to emit the <code>hero</code> object,\nthe test detects that value through its subscription to <code>selected</code>, and the test should pass.</p>\n<a id=\"trigger-event-handler\"></a>\n<h3 id=\"triggereventhandler\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#triggereventhandler\"><i class=\"material-icons\">link</i></a><em>triggerEventHandler</em></h3>\n<p>The Angular <code>DebugElement.triggerEventHandler</code> can raise <em>any data-bound event</em> by its <em>event name</em>.\nThe second parameter is the event object passed to the handler.</p>\n<p>In this example, the test triggers a \"click\" event with a null event object.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"trigger-event-handler\" title=\"src/app/dashboard/dashboard-hero.component.spec.ts\" linenums=\"false\">\nheroEl.triggerEventHandler('click', null);\n\n</code-example>\n<p>The test assumes (correctly in this case) that the runtime\nevent handler—the component's <code>click()</code> method—doesn't\ncare about the event object.</p>\n<p>Other handlers are less forgiving. For example, the <code><a href=\"api/router/RouterLink\">RouterLink</a></code>\ndirective expects an object with a <code>button</code> property\nthat identifies which mouse button was pressed.\nThis directive throws an error if the event object doesn't do this correctly.</p>\n<a id=\"click-helper\"></a>\n<p>Clicking a button, an anchor, or an arbitrary HTML element is a common test task.</p>\n<p>Make that easy by encapsulating the <em>click-triggering</em> process in a helper such as the <code>click</code> function below:</p>\n<code-example path=\"testing/src/testing/index.ts\" region=\"click-event\" title=\"testing/index.ts (click helper)\" linenums=\"false\">\n/** Button events to pass to `DebugElement.triggerEventHandler` for RouterLink event handler */\nexport const ButtonClickEvents = {\n   left:  { button: 0 },\n   right: { button: 2 }\n};\n\n/** Simulate element click. Defaults to mouse left-button click event. */\nexport function click(el: DebugElement | HTMLElement, eventObj: any = ButtonClickEvents.left): void {\n  if (el instanceof HTMLElement) {\n    el.click();\n  } else {\n    el.triggerEventHandler('click', eventObj);\n  }\n}\n\n</code-example>\n<p>The first parameter is the <em>element-to-click</em>. If you wish, you can pass a\ncustom event object as the second parameter. The default is a (partial)\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\">left-button mouse event object</a>\naccepted by many handlers including the <code><a href=\"api/router/RouterLink\">RouterLink</a></code> directive.</p>\n<div class=\"callout is-critical\">\n<header>\n  click() is not an Angular testing utility\n</header>\n<p>The <code>click()</code> helper function is <strong>not</strong> one of the Angular testing utilities.\nIt's a function defined in <em>this guide's sample code</em>.\nAll of the sample tests use it.\nIf you like it, add it to your own collection of helpers.</p>\n</div>\n<p>Here's the previous test, rewritten using this click helper.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-2\" title=\"src/app/dashboard/dashboard-hero.component.spec.ts (click test revised)\" linenums=\"false\">\nit('should raise selected event when clicked', () => {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) => selectedHero = hero);\n\n  click(heroEl);   // triggerEventHandler helper\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<hr>\n<a id=\"component-inside-test-host\"></a>\n<h2 id=\"test-a-component-inside-a-test-host-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-a-component-inside-a-test-host-component\"><i class=\"material-icons\">link</i></a>Test a component inside a test host component</h2>\n<p>In the previous approach, the tests themselves played the role of the host <code>DashboardComponent</code>.\nBut does the <code>DashboardHeroComponent</code> work correctly when properly data-bound to a host component?</p>\n<p>Testing with the actual <code>DashboardComponent</code> host is doable but seems more trouble than its worth.\nIt's easier to emulate the <code>DashboardComponent</code> host with a <em>test host</em> like this one:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host\" title=\"src/app/dashboard/dashboard-hero.component.spec.ts (test host)\" linenums=\"false\">\n@Component({\n  template: `\n    &#x3C;dashboard-hero  [hero]=\"hero\"  (selected)=\"onSelected($event)\">&#x3C;/dashboard-hero>`\n})\nclass TestHostComponent {\n  hero = new Hero(42, 'Test Name');\n  selectedHero: Hero;\n  onSelected(hero: Hero) { this.selectedHero = hero; }\n}\n\n</code-example>\n<p>The test host binds to <code>DashboardHeroComponent</code> as the <code>DashboardComponent</code> would but without\nthe distraction of the <code><a href=\"api/router/Router\">Router</a></code>, the <code>HeroService</code>, or even the <code>*ngFor</code> repeater.</p>\n<p>The test host sets the component's <code>hero</code> input property with its test hero.\nIt binds the component's <code>selected</code> event with its <code>onSelected</code> handler,\nwhich records the emitted hero\nin its <code>selectedHero</code> property. Later, the tests check that property to verify that the\n<code>DashboardHeroComponent.selected</code> event emitted the right hero.</p>\n<p>The setup for the test-host tests is similar to the setup for the stand-alone tests:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-setup\" title=\"src/app/dashboard/dashboard-hero.component.spec.ts (test host setup)\" linenums=\"false\">\nbeforeEach( async(() => {\n  TestBed.configureTestingModule({\n    declarations: [ DashboardHeroComponent, TestHostComponent ], // declare both\n  }).compileComponents();\n}));\n\nbeforeEach(() => {\n  // create TestHostComponent instead of DashboardHeroComponent\n  fixture  = TestBed.createComponent(TestHostComponent);\n  testHost = fixture.componentInstance;\n  heroEl   = fixture.debugElement.query(By.css('.hero')); // find hero\n  fixture.detectChanges(); // trigger initial data binding\n});\n\n</code-example>\n<p>This testing module configuration shows two important differences:</p>\n<ol>\n<li>It <em>declares</em> both the <code>DashboardHeroComponent</code> and the <code>TestHostComponent</code>.</li>\n<li>It <em>creates</em> the <code>TestHostComponent</code> instead of the <code>DashboardHeroComponent</code>.</li>\n</ol>\n<p>The <code>createComponent</code> returns a <code>fixture</code> that holds an instance of <code>TestHostComponent</code> instead of an instance of <code>DashboardHeroComponent</code>.</p>\n<p>Creating the <code>TestHostComponent</code> has the side-effect of creating a <code>DashboardHeroComponent</code>\nbecause the latter appears within the template of the former.\nThe query for the hero element (<code>heroEl</code>) still finds it in the test DOM,\nalbeit at greater depth in the element tree than before.</p>\n<p>The tests themselves are almost identical to the stand-alone version:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-tests\" title=\"src/app/dashboard/dashboard-hero.component.spec.ts (test-host)\" linenums=\"false\">\nit('should display hero name', () => {\n  const expectedPipedName = testHost.hero.name.toUpperCase();\n  expect(heroEl.nativeElement.textContent).toContain(expectedPipedName);\n});\n\nit('should raise selected event when clicked', () => {\n  click(heroEl);\n  // selected hero should be the same data bound hero\n  expect(testHost.selectedHero).toBe(testHost.hero);\n});\n\n</code-example>\n<p>Only the selected event test differs. It confirms that the selected <code>DashboardHeroComponent</code> hero\nreally does find its way up through the event binding to the host component.\n<a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"routed-component\"></a>\n<h2 id=\"test-a-routed-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-a-routed-component\"><i class=\"material-icons\">link</i></a>Test a routed component</h2>\n<p>Testing the actual <code>DashboardComponent</code> seemed daunting because it injects the <code><a href=\"api/router/Router\">Router</a></code>.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" title=\"src/app/dashboard/dashboard.component.ts (constructor)\" linenums=\"false\">\nconstructor(\n  private router: Router,\n  private heroService: HeroService) {\n}\n\n</code-example>\n<p>It also injects the <code>HeroService</code>, but faking that is a <a href=\"guide/testing#component-with-async-service\">familiar story</a>.\nThe <code><a href=\"api/router/Router\">Router</a></code> has a complicated API and is entwined with other services and application preconditions.</p>\n<p>Fortunately, the <code>DashboardComponent</code> isn't doing much with the <code><a href=\"api/router/Router\">Router</a></code></p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"goto-detail\" title=\"src/app/dashboard/dashboard.component.ts (goToDetail)\" linenums=\"false\">\ngotoDetail(hero: Hero) {\n  let url = `/heroes/${hero.id}`;\n  this.router.navigateByUrl(url);\n}\n\n</code-example>\n<p>This is often the case.\nAs a rule you test the component, not the router,\nand care only if the component navigates with the right address under the given conditions.\nStubbing the router with a test implementation is an easy option. This should do the trick:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"router-stub\" title=\"src/app/dashboard/dashboard.component.spec.ts (Router Stub)\" linenums=\"false\">\nclass RouterStub {\n  navigateByUrl(url: string) { return url; }\n}\n\n</code-example>\n<p>Now set up the testing module with the test stubs for the <code><a href=\"api/router/Router\">Router</a></code> and <code>HeroService</code>, and\ncreate a test instance of the <code>DashboardComponent</code> for subsequent testing.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"compile-and-create-body\" title=\"src/app/dashboard/dashboard.component.spec.ts (compile and create)\" linenums=\"false\">\nbeforeEach( async(() => {\n  TestBed.configureTestingModule({\n    providers: [\n      { provide: HeroService, useClass: FakeHeroService },\n      { provide: Router,      useClass: RouterStub }\n    ]\n  })\n  .compileComponents().then(() => {\n    fixture = TestBed.createComponent(DashboardComponent);\n    comp = fixture.componentInstance;\n  });\n\n</code-example>\n<p>The following test clicks the displayed hero and confirms (with the help of a spy) that <code>Router.navigateByUrl</code> is called with the expected url.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"navigate-test\" title=\"src/app/dashboard/dashboard.component.spec.ts (navigate test)\" linenums=\"false\">\nit('should tell ROUTER to navigate when hero clicked',\n  inject([Router], (router: Router) => { // ...\n\n  const spy = spyOn(router, 'navigateByUrl');\n\n  heroClick(); // trigger click on first inner &#x3C;div class=\"hero\">\n\n  // args passed to router.navigateByUrl()\n  const navArgs = spy.calls.first().args[0];\n\n  // expecting to navigate to id of the component's first hero\n  const id = comp.heroes[0].id;\n  expect(navArgs).toBe('/heroes/' + id,\n    'should nav to HeroDetail for first hero');\n}));\n\n</code-example>\n<a id=\"inject\"></a>\n<h3 id=\"the-inject-function\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-inject-function\"><i class=\"material-icons\">link</i></a>The <em>inject</em> function</h3>\n<p>Notice the <code><a href=\"api/core/testing/inject\">inject</a></code> function in the second <code>it</code> argument.</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"inject\" title=\"src/app/dashboard/dashboard.component.spec.ts\" linenums=\"false\">\nit('should tell ROUTER to navigate when hero clicked',\n  inject([Router], (router: Router) => { // ...\n}));\n\n</code-example>\n<p>The <code><a href=\"api/core/testing/inject\">inject</a></code> function is one of the Angular testing utilities.\nIt injects services into the test function where you can alter, spy on, and manipulate them.</p>\n<p>The <code><a href=\"api/core/testing/inject\">inject</a></code> function has two parameters:</p>\n<ol>\n<li>An array of Angular dependency injection tokens.</li>\n<li>A test function whose parameters correspond exactly to each item in the injection token array.</li>\n</ol>\n<div class=\"callout is-important\">\n<header>\n  inject uses the TestBed Injector\n</header>\n<p>The <code><a href=\"api/core/testing/inject\">inject</a></code> function uses the current <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> injector and can only return services provided at that level.\nIt does not return services from component providers.</p>\n</div>\n<p>This example injects the <code><a href=\"api/router/Router\">Router</a></code> from the current <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> injector.\nThat's fine for this test because the <code><a href=\"api/router/Router\">Router</a></code> is, and must be, provided by the application root injector.</p>\n<p>If you need a service provided by the component's <em>own</em> injector,  call <code>fixture.debugElement.injector.get</code> instead:</p>\n<code-example path=\"testing/src/app/welcome.component.spec.ts\" region=\"injected-service\" title=\"Component&#x27;s injector\" linenums=\"false\">\n// UserService actually injected into the component\nuserService = fixture.debugElement.injector.get(UserService);\n\n</code-example>\n<div class=\"alert is-important\">\n<p>Use the component's own injector to get the service actually injected into the component.</p>\n</div>\n<p>The <code><a href=\"api/core/testing/inject\">inject</a></code> function closes the current <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> instance to further configuration.\nYou cannot call any more <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> configuration methods, not <code>configureTestingModule</code>\nnor any of the <code>override...</code> methods. The <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> throws an error if you try.</p>\n<div class=\"alert is-important\">\n<p>Do not configure the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> after calling <code><a href=\"api/core/testing/inject\">inject</a></code>.</p>\n</div>\n<a id=\"routed-component-w-param\"></a>\n<h3 id=\"test-a-routed-component-with-parameters\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-a-routed-component-with-parameters\"><i class=\"material-icons\">link</i></a>Test a routed component with parameters</h3>\n<p>Clicking a <em>Dashboard</em> hero triggers navigation to <code>heroes/:id</code>, where <code>:id</code>\nis a route parameter whose value is the <code>id</code> of the hero to edit.\nThat URL matches a route to the <code>HeroDetailComponent</code>.</p>\n<p>The router pushes the <code>:id</code> token value into the <code>ActivatedRoute.params</code> <em>Observable</em> property,\nAngular injects the <code><a href=\"api/router/ActivatedRoute\">ActivatedRoute</a></code> into the <code>HeroDetailComponent</code>,\nand the component extracts the <code>id</code> so it can fetch the corresponding hero via the <code>HeroDetailService</code>.\nHere's the <code>HeroDetailComponent</code> constructor:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ctor\" title=\"src/app/hero/hero-detail.component.ts (constructor)\" linenums=\"false\">\nconstructor(\n  private heroDetailService: HeroDetailService,\n  private route:  ActivatedRoute,\n  private router: Router) {\n}\n\n</code-example>\n<p><code>HeroDetailComponent</code>  subscribes to <code>ActivatedRoute.params</code> changes in its <code>ngOnInit</code> method.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ng-on-init\" title=\"src/app/hero/hero-detail.component.ts (ngOnInit)\" linenums=\"false\">\nngOnInit(): void {\n  // get hero when `id` param changes\n  this.route.paramMap.subscribe(p => this.getHero(p.has('id') &#x26;&#x26; p.get('id')));\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>The expression after <code>route.params</code> chains an <em>Observable</em> operator that <em>plucks</em> the <code>id</code> from the <code>params</code>\nand then chains a <code>forEach</code> operator to subscribe to <code>id</code>-changing events.\nThe <code>id</code> changes every time the user navigates to a different hero.</p>\n<p>The <code>forEach</code> passes the new <code>id</code> value to the component's <code>getHero</code> method (not shown)\nwhich fetches a hero and sets the component's <code>hero</code> property.\nIf the<code>id</code> parameter is missing, the <code>pluck</code> operator fails and the <code>catch</code> treats failure as a request to edit a new hero.</p>\n<p>The <a href=\"guide/router#route-parameters\">Router</a> guide covers <code>ActivatedRoute.params</code> in more detail.</p>\n</div>\n<p>A test can explore how the <code>HeroDetailComponent</code> responds to different <code>id</code> parameter values\nby manipulating the <code><a href=\"api/router/ActivatedRoute\">ActivatedRoute</a></code> injected into the component's constructor.</p>\n<p>By now you know how to stub the <code><a href=\"api/router/Router\">Router</a></code> and a data service.\nStubbing the <code><a href=\"api/router/ActivatedRoute\">ActivatedRoute</a></code> follows the same pattern except for a complication:\nthe <code>ActivatedRoute.params</code> is an <em>Observable</em>.</p>\n<a id=\"stub-observable\"></a>\n<h3 id=\"create-an-observable-test-double\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#create-an-observable-test-double\"><i class=\"material-icons\">link</i></a>Create an <em>Observable</em> test double</h3>\n<p>The <code>hero-detail.component.spec.ts</code> relies on an <code>ActivatedRouteStub</code> to set <code>ActivatedRoute.params</code> values for each test.\nThis is a cross-application, re-usable <em>test helper class</em>.\nConsider placing such helpers in a <code>testing</code> folder sibling to the <code>app</code> folder.\nThis sample keeps <code>ActivatedRouteStub</code> in <code>testing/router-stubs.ts</code>:</p>\n<code-example path=\"testing/src/testing/router-stubs.ts\" region=\"activated-route-stub\" title=\"testing/router-stubs.ts (ActivatedRouteStub)\" linenums=\"false\">\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { convertToParamMap, ParamMap } from '@angular/router';\n\n@Injectable()\nexport class ActivatedRouteStub {\n\n  // ActivatedRoute.paramMap is Observable\n  private subject = new BehaviorSubject(convertToParamMap(this.testParamMap));\n  paramMap = this.subject.asObservable();\n\n  // Test parameters\n  private _testParamMap: ParamMap;\n  get testParamMap() { return this._testParamMap; }\n  set testParamMap(params: {}) {\n    this._testParamMap = convertToParamMap(params);\n    this.subject.next(this._testParamMap);\n  }\n\n  // ActivatedRoute.snapshot.paramMap\n  get snapshot() {\n    return { paramMap: this.testParamMap };\n  }\n}\n\n</code-example>\n<p>Notable features of this stub are:</p>\n<ul>\n<li>\n<p>The stub implements only two of the <code><a href=\"api/router/ActivatedRoute\">ActivatedRoute</a></code> capabilities: <code>params</code> and <code>snapshot.params</code>.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/subjects/behaviorsubject.md\"><em>BehaviorSubject</em></a>\ndrives the stub's <code>params</code> <em>Observable</em> and returns the same value to every <code>params</code> subscriber until it's given a new value.</p>\n</li>\n<li>\n<p>The <code>HeroDetailComponent</code> chains its expressions to this stub <code>params</code> <em>Observable</em> which is now under the tester's control.</p>\n</li>\n<li>\n<p>Setting the <code>testParams</code> property causes the <code>subject</code> to push the assigned value into <code>params</code>.\nThat triggers the <code>HeroDetailComponent</code> <em>params</em> subscription, described above, in the same way that navigation does.</p>\n</li>\n<li>\n<p>Setting the <code>testParams</code> property also updates the stub's internal value for the <code>snapshot</code> property to return.</p>\n</li>\n</ul>\n<div class=\"l-sub-section\">\n<p>The <a href=\"guide/router#snapshot\" title=\"Router guide: snapshot\"><em>snapshot</em></a> is another popular way for components to consume route parameters.</p>\n</div>\n<div class=\"callout is-helpful\">\n<p>The router stubs in this guide are meant to inspire you. Create your own stubs to fit your testing needs.</p>\n</div>\n<a id=\"tests-w-observable-double\"></a>\n<h3 id=\"testing-with-the-observable-test-double\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#testing-with-the-observable-test-double\"><i class=\"material-icons\">link</i></a>Testing with the <em>Observable</em> test double</h3>\n<p>Here's a test demonstrating the component's behavior when the observed <code>id</code> refers to an existing hero:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-good-id\" title=\"src/app/hero/hero-detail.component.spec.ts (existing id)\" linenums=\"false\">\ndescribe('when navigate to existing hero', () => {\n  let expectedHero: Hero;\n\n  beforeEach( async(() => {\n    expectedHero = firstHero;\n    activatedRoute.testParamMap = { id: expectedHero.id };\n    createComponent();\n  }));\n\n  it('should display that hero\\'s name', () => {\n    expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n  });\n});\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>The <code>createComponent</code> method and <code>page</code> object are discussed <a href=\"guide/testing#page-object\">in the next section</a>.\nRely on your intuition for now.</p>\n</div>\n<p>When the <code>id</code> cannot be found, the component should re-route to the <code>HeroListComponent</code>.\nThe test suite setup provided the same <code>RouterStub</code> <a href=\"guide/testing#routed-component\">described above</a> which spies on the router without actually navigating.\nThis test supplies a \"bad\" id and expects the component to try to navigate.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-bad-id\" title=\"src/app/hero/hero-detail.component.spec.ts (bad id)\" linenums=\"false\">\ndescribe('when navigate to non-existent hero id', () => {\n  beforeEach( async(() => {\n    activatedRoute.testParamMap = { id: 99999 };\n    createComponent();\n  }));\n\n  it('should try to navigate back to hero list', () => {\n    expect(page.gotoSpy.calls.any()).toBe(true, 'comp.gotoList called');\n    expect(page.navSpy.calls.any()).toBe(true, 'router.navigate called');\n  });\n});\n\n</code-example>\n<p>While this app doesn't have a route to the <code>HeroDetailComponent</code> that omits the <code>id</code> parameter, it might add such a route someday.\nThe component should do something reasonable when there is no <code>id</code>.</p>\n<p>In this implementation, the component should create and display a new hero.\nNew heroes have <code>id=0</code> and a blank <code>name</code>. This test confirms that the component behaves as expected:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-no-id\" title=\"src/app/hero/hero-detail.component.spec.ts (no id)\" linenums=\"false\">\ndescribe('when navigate with no hero id', () => {\n  beforeEach( async( createComponent ));\n\n  it('should have hero.id === 0', () => {\n    expect(comp.hero.id).toBe(0);\n  });\n\n  it('should display empty hero name', () => {\n    expect(page.nameDisplay.textContent).toBe('');\n  });\n});\n\n</code-example>\n<div class=\"callout is-helpful\">\n<p>Inspect and download <em>all</em> of the guide's application test code with this <live-example plnkr=\"app-specs\" embedded-style=\"\">live example</live-example>.</p>\n</div>\n<p><a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"page-object\"></a>\n<h2 id=\"use-a-page-object-to-simplify-setup\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#use-a-page-object-to-simplify-setup\"><i class=\"material-icons\">link</i></a>Use a <em>page</em> object to simplify setup</h2>\n<p>The <code>HeroDetailComponent</code> is a simple view with a title, two hero fields, and two buttons.</p>\n<figure>\n  <img src=\"generated/images/guide/testing/hero-detail.component.png\" alt=\"HeroDetailComponent in action\" width=\"269\" height=\"170\">\n</figure>\n<p>But there's already plenty of template complexity.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.html\" title=\"src/app/hero/hero-detail.component.html\" linenums=\"false\">\n&#x3C;div *ngIf=\"hero\">\n  &#x3C;h2>&#x3C;span>{{hero.name | titlecase}}&#x3C;/span> Details&#x3C;/h2>\n  &#x3C;div>\n    &#x3C;label>id: &#x3C;/label>{{hero.id}}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label for=\"name\">name: &#x3C;/label>\n    &#x3C;input id=\"name\" [(ngModel)]=\"hero.name\" placeholder=\"name\" />\n  &#x3C;/div>\n  &#x3C;button (click)=\"save()\">Save&#x3C;/button>\n  &#x3C;button (click)=\"cancel()\">Cancel&#x3C;/button>\n&#x3C;/div>\n\n\n</code-example>\n<p>To fully exercise the component, the test needs a lot of setup:</p>\n<ul>\n<li>It must wait until a hero arrives before <code>*ngIf</code> allows any element in DOM.</li>\n<li>It needs references to the title <code>&#x3C;span></code> and the name <code>&#x3C;input></code> so it can inspect their values.</li>\n<li>It needs references to the two buttons so it can click them.</li>\n<li>It needs spies for some of the component and router methods.</li>\n</ul>\n<p>Even a small form such as this one can produce a mess of tortured conditional setup and CSS element selection.</p>\n<p>Tame the madness with a <code>Page</code> class that simplifies access to component properties and encapsulates the logic that sets them.\nHere's the <code>Page</code> class for the <code>hero-detail.component.spec.ts</code></p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"page\" title=\"src/app/hero/hero-detail.component.spec.ts (Page)\" linenums=\"false\">\nclass Page {\n  gotoSpy:      jasmine.Spy;\n  navSpy:       jasmine.Spy;\n\n  saveBtn:      DebugElement;\n  cancelBtn:    DebugElement;\n  nameDisplay:  HTMLElement;\n  nameInput:    HTMLInputElement;\n\n  constructor() {\n    const router = TestBed.get(Router); // get router from root injector\n    this.gotoSpy = spyOn(comp, 'gotoList').and.callThrough();\n    this.navSpy  = spyOn(router, 'navigate');\n  }\n\n  /** Add page elements after hero arrives */\n  addPageElements() {\n    if (comp.hero) {\n      // have a hero so these elements are now in the DOM\n      const buttons    = fixture.debugElement.queryAll(By.css('button'));\n      this.saveBtn     = buttons[0];\n      this.cancelBtn   = buttons[1];\n      this.nameDisplay = fixture.debugElement.query(By.css('span')).nativeElement;\n      this.nameInput   = fixture.debugElement.query(By.css('input')).nativeElement;\n    }\n  }\n}\n\n</code-example>\n<p>Now the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of <code>Page</code>.</p>\n<p>A <code>createComponent</code> method creates a <code>page</code> object and fills in the blanks once the <code>hero</code> arrives.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"create-component\" title=\"src/app/hero/hero-detail.component.spec.ts (createComponent)\" linenums=\"false\">\n/** Create the HeroDetailComponent, initialize it, set test variables  */\nfunction createComponent() {\n  fixture = TestBed.createComponent(HeroDetailComponent);\n  comp    = fixture.componentInstance;\n  page    = new Page();\n\n  // 1st change detection triggers ngOnInit which gets a hero\n  fixture.detectChanges();\n  return fixture.whenStable().then(() => {\n    // 2nd change detection displays the async-fetched hero\n    fixture.detectChanges();\n    page.addPageElements();\n  });\n}\n\n</code-example>\n<p>The <a href=\"guide/testing#tests-w-observable-double\">observable tests</a> in the previous section demonstrate how <code>createComponent</code> and <code>page</code>\nkeep the tests short and <em>on message</em>.\nThere are no distractions: no waiting for promises to resolve and no searching the DOM for element values to compare.</p>\n<p>Here are a few more <code>HeroDetailComponent</code> tests to drive the point home.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"selected-tests\" title=\"src/app/hero/hero-detail.component.spec.ts (selected tests)\" linenums=\"false\">\nit('should display that hero\\'s name', () => {\n  expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n});\n\nit('should navigate when click cancel', () => {\n  click(page.cancelBtn);\n  expect(page.navSpy.calls.any()).toBe(true, 'router.navigate called');\n});\n\nit('should save when click save but not navigate immediately', () => {\n  // Get service injected into component and spy on its`saveHero` method.\n  // It delegates to fake `HeroService.updateHero` which delivers a safe test result.\n  const hds = fixture.debugElement.injector.get(HeroDetailService);\n  const saveSpy = spyOn(hds, 'saveHero').and.callThrough();\n\n  click(page.saveBtn);\n  expect(saveSpy.calls.any()).toBe(true, 'HeroDetailService.save called');\n  expect(page.navSpy.calls.any()).toBe(false, 'router.navigate not called');\n});\n\nit('should navigate when click save and save resolves', fakeAsync(() => {\n  click(page.saveBtn);\n  tick(); // wait for async save to complete\n  expect(page.navSpy.calls.any()).toBe(true, 'router.navigate called');\n}));\n\nit('should convert hero name to Title Case', () => {\n  const inputName = 'quick BROWN  fox';\n  const titleCaseName = 'Quick Brown  Fox';\n\n  // simulate user entering new name into the input box\n  page.nameInput.value = inputName;\n\n  // dispatch a DOM event so that Angular learns of input value change.\n  page.nameInput.dispatchEvent(newEvent('input'));\n\n  // Tell Angular to update the output span through the title pipe\n  fixture.detectChanges();\n\n  expect(page.nameDisplay.textContent).toBe(titleCaseName);\n});\n\n</code-example>\n<p><a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"import-module\"></a>\n<h2 id=\"setup-with-module-imports\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#setup-with-module-imports\"><i class=\"material-icons\">link</i></a>Setup with module imports</h2>\n<p>Earlier component tests configured the testing module with a few <code>declarations</code> like this:</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"compile-components\" title=\"src/app/dashboard/dashboard-hero.component.spec.ts (config)\" linenums=\"false\">\n// async beforeEach\nbeforeEach( async(() => {\n  TestBed.configureTestingModule({\n    declarations: [ DashboardHeroComponent ],\n  })\n  .compileComponents(); // compile template and css\n}));\n\n</code-example>\n<p>The <code>DashboardComponent</code> is simple. It needs no help.\nBut more complex components often depend on other components, directives, pipes, and providers\nand these must be added to the testing module too.</p>\n<p>Fortunately, the <code>TestBed.configureTestingModule</code> parameter parallels\nthe metadata passed to the <code>@NgModule</code> decorator\nwhich means you can also specify <code>providers</code> and <code>imports</code>.</p>\n<p>The <code>HeroDetailComponent</code> requires a lot of help despite its small size and simple construction.\nIn addition to the support it receives from the default testing module <code><a href=\"api/common/CommonModule\">CommonModule</a></code>, it needs:</p>\n<ul>\n<li><code><a href=\"api/forms/NgModel\">NgModel</a></code> and friends in the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> to enable two-way data binding.</li>\n<li>The <code><a href=\"api/common/TitleCasePipe\">TitleCasePipe</a></code> from the <code>shared</code> folder.</li>\n<li>Router services (which these tests are stubbing).</li>\n<li>Hero data access services (also stubbed).</li>\n</ul>\n<p>One approach is to configure the testing module from the individual pieces as in this example:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-forms-module\" title=\"src/app/hero/hero-detail.component.spec.ts (FormsModule setup)\" linenums=\"false\">\nbeforeEach( async(() => {\n   TestBed.configureTestingModule({\n    imports:      [ FormsModule ],\n    declarations: [ HeroDetailComponent, TitleCasePipe ],\n    providers: [\n      { provide: ActivatedRoute, useValue: activatedRoute },\n      { provide: HeroService,    useClass: FakeHeroService },\n      { provide: Router,         useClass: RouterStub},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n<p>Because many app components need the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> and the <code><a href=\"api/common/TitleCasePipe\">TitleCasePipe</a></code>, the developer created\na <code>SharedModule</code> to combine these and other frequently requested parts.\nThe test configuration can use the <code>SharedModule</code> too as seen in this alternative setup:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-shared-module\" title=\"src/app/hero/hero-detail.component.spec.ts (SharedModule setup)\" linenums=\"false\">\nbeforeEach( async(() => {\n  TestBed.configureTestingModule({\n    imports:      [ SharedModule ],\n    declarations: [ HeroDetailComponent ],\n    providers: [\n      { provide: ActivatedRoute, useValue: activatedRoute },\n      { provide: HeroService,    useClass: FakeHeroService },\n      { provide: Router,         useClass: RouterStub},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n<p>It's a bit tighter and smaller, with fewer import statements (not shown).</p>\n<a id=\"feature-module-import\"></a>\n<h3 id=\"import-the-feature-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#import-the-feature-module\"><i class=\"material-icons\">link</i></a>Import the feature module</h3>\n<p>The <code>HeroDetailComponent</code> is part of the <code>HeroModule</code> <a href=\"guide/ngmodule#feature-modules\">Feature Module</a> that aggregates more of the interdependent pieces\nincluding the <code>SharedModule</code>.\nTry a test configuration that imports the <code>HeroModule</code> like this one:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-hero-module\" title=\"src/app/hero/hero-detail.component.spec.ts (HeroModule setup)\" linenums=\"false\">\nbeforeEach( async(() => {\n   TestBed.configureTestingModule({\n    imports:   [ HeroModule ],\n    providers: [\n      { provide: ActivatedRoute, useValue: activatedRoute },\n      { provide: HeroService,    useClass: FakeHeroService },\n      { provide: Router,         useClass: RouterStub},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n<p>That's <em>really</em> crisp. Only the <em>test doubles</em> in the <code>providers</code> remain. Even the <code>HeroDetailComponent</code> declaration is gone.</p>\n<div class=\"l-sub-section\">\n<p>In fact, if you try to declare it, Angular throws an error because\n<code>HeroDetailComponent</code> is declared in both the <code>HeroModule</code> and the <code>DynamicTestModule</code> (the testing module).</p>\n</div>\n<div class=\"alert is-helpful\">\n<p>Importing the component's feature module is often the easiest way to configure the tests,\nespecially when the feature module is small and mostly self-contained, as feature modules should be.</p>\n</div>\n<p><a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"component-override\"></a>\n<h2 id=\"override-a-components-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#override-a-components-providers\"><i class=\"material-icons\">link</i></a>Override a component's providers</h2>\n<p>The <code>HeroDetailComponent</code> provides its own <code>HeroDetailService</code>.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"prototype\" title=\"src/app/hero/hero-detail.component.ts (prototype)\" linenums=\"false\">\n@Component({\n  selector:    'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls:  ['./hero-detail.component.css' ],\n  providers:  [ HeroDetailService ]\n})\nexport class HeroDetailComponent implements OnInit {\n  constructor(\n    private heroDetailService: HeroDetailService,\n    private route:  ActivatedRoute,\n    private router: Router) {\n  }\n}\n\n</code-example>\n<p>It's not possible to stub the component's <code>HeroDetailService</code> in the <code>providers</code> of the <code>TestBed.configureTestingModule</code>.\nThose are providers for the <em>testing module</em>, not the component. They prepare the dependency injector at the <em>fixture level</em>.</p>\n<p>Angular creates the component with its <em>own</em> injector, which is a <em>child</em> of the fixture injector.\nIt registers the component's providers (the <code>HeroDetailService</code> in this case) with the child injector.\nA test cannot get to child injector services from the fixture injector.\nAnd <code>TestBed.configureTestingModule</code> can't configure them either.</p>\n<p>Angular has been creating new instances of the real <code>HeroDetailService</code> all along!</p>\n<div class=\"l-sub-section\">\n<p>These tests could fail or timeout if the <code>HeroDetailService</code> made its own XHR calls to a remote server.\nThere might not be a remote server to call.</p>\n<p>Fortunately, the <code>HeroDetailService</code> delegates responsibility for remote data access to an injected <code>HeroService</code>.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.service.ts\" region=\"prototype\" title=\"src/app/hero/hero-detail.service.ts (prototype)\" linenums=\"false\">\n@Injectable()\nexport class HeroDetailService {\n  constructor(private heroService: HeroService) {  }\n/* . . . */\n}\n\n</code-example>\n<p>The <a href=\"guide/testing#feature-module-import\">previous test configuration</a> replaces the real <code>HeroService</code> with a <code>FakeHeroService</code>\nthat intercepts server requests and fakes their responses.</p>\n</div>\n<p>What if you aren't so lucky. What if faking the <code>HeroService</code> is hard?\nWhat if <code>HeroDetailService</code> makes its own server requests?</p>\n<p>The <code>TestBed.overrideComponent</code> method can replace the component's <code>providers</code> with easy-to-manage <em>test doubles</em>\nas seen in the following setup variation:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-override\" title=\"src/app/hero/hero-detail.component.spec.ts (Override setup)\" linenums=\"false\">\nbeforeEach( async(() => {\n  TestBed.configureTestingModule({\n    imports:   [ HeroModule ],\n    providers: [\n      { provide: ActivatedRoute, useValue: activatedRoute },\n      { provide: Router,         useClass: RouterStub},\n    ]\n  })\n\n  // Override component's own provider\n  .overrideComponent(HeroDetailComponent, {\n    set: {\n      providers: [\n        { provide: HeroDetailService, useClass: HeroDetailServiceSpy }\n      ]\n    }\n  })\n\n  .compileComponents();\n}));\n\n</code-example>\n<p>Notice that <code>TestBed.configureTestingModule</code> no longer provides a (fake) <code>HeroService</code> because it's <a href=\"guide/testing#spy-stub\">not needed</a>.</p>\n<a id=\"override-component-method\"></a>\n<h3 id=\"the-overridecomponent-method\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-overridecomponent-method\"><i class=\"material-icons\">link</i></a>The <em>overrideComponent</em> method</h3>\n<p>Focus on the <code>overrideComponent</code> method.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-component-method\" title=\"src/app/hero/hero-detail.component.spec.ts (overrideComponent)\" linenums=\"false\">\n.overrideComponent(HeroDetailComponent, {\n  set: {\n    providers: [\n      { provide: HeroDetailService, useClass: HeroDetailServiceSpy }\n    ]\n  }\n})\n\n</code-example>\n<p>It takes two arguments: the component type to override (<code>HeroDetailComponent</code>) and an override metadata object.\nThe <a href=\"guide/testing#metadata-override-object\">overide metadata object</a> is a generic defined as follows:</p>\n<code-example format=\".\" language=\"javascript\">\n  type MetadataOverride<t> = {\n    add?: T;\n    remove?: T;\n    set?: T;\n  };\n</t></code-example>\n<p>A metadata override object can either add-and-remove elements in metadata properties or completely reset those properties.\nThis example resets the component's <code>providers</code> metadata.</p>\n<p>The type parameter, <code>T</code>,  is the kind of metadata you'd pass to the <code>@Component</code> decorator:</p>\n<code-example format=\".\" language=\"javascript\">\n  selector?: string;\n  template?: string;\n  templateUrl?: string;\n  providers?: any[];\n  ...\n\n</code-example>\n<a id=\"spy-stub\"></a>\n<h3 id=\"provide-a-spy-stub-herodetailservicespy\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#provide-a-spy-stub-herodetailservicespy\"><i class=\"material-icons\">link</i></a>Provide a <em>spy stub</em> (<em>HeroDetailServiceSpy</em>)</h3>\n<p>This example completely replaces the component's <code>providers</code> array with a new array containing a <code>HeroDetailServiceSpy</code>.</p>\n<p>The <code>HeroDetailServiceSpy</code> is a stubbed version of the real <code>HeroDetailService</code>\nthat fakes all necessary features of that service.\nIt neither injects nor delegates to the lower level <code>HeroService</code>\nso there's no need to provide a test double for that.</p>\n<p>The related <code>HeroDetailComponent</code> tests will assert that methods of the <code>HeroDetailService</code>\nwere called by spying on the service methods.\nAccordingly, the stub implements its methods as spies:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"hds-spy\" title=\"src/app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)\" linenums=\"false\">\nclass HeroDetailServiceSpy {\n  testHero = new Hero(42, 'Test Hero');\n\n  getHero = jasmine.createSpy('getHero').and.callFake(\n    () => Promise\n      .resolve(true)\n      .then(() => Object.assign({}, this.testHero))\n  );\n\n  saveHero = jasmine.createSpy('saveHero').and.callFake(\n    (hero: Hero) => Promise\n      .resolve(true)\n      .then(() => Object.assign(this.testHero, hero))\n  );\n}\n\n</code-example>\n<a id=\"override-tests\"></a>\n<h3 id=\"the-override-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-override-tests\"><i class=\"material-icons\">link</i></a>The override tests</h3>\n<p>Now the tests can control the component's hero directly by manipulating the spy-stub's <code>testHero</code>\nand confirm that service methods were called.</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-tests\" title=\"src/app/hero/hero-detail.component.spec.ts (override tests)\" linenums=\"false\">\nlet hdsSpy: HeroDetailServiceSpy;\n\nbeforeEach( async(() => {\n  createComponent();\n  // get the component's injected HeroDetailServiceSpy\n  hdsSpy = fixture.debugElement.injector.get(HeroDetailService) as any;\n}));\n\nit('should have called `getHero`', () => {\n  expect(hdsSpy.getHero.calls.count()).toBe(1, 'getHero called once');\n});\n\nit('should display stub hero\\'s name', () => {\n  expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);\n});\n\nit('should save stub hero change', fakeAsync(() => {\n  const origName = hdsSpy.testHero.name;\n  const newName = 'New Name';\n\n  page.nameInput.value = newName;\n  page.nameInput.dispatchEvent(newEvent('input')); // tell Angular\n\n  expect(comp.hero.name).toBe(newName, 'component hero has new name');\n  expect(hdsSpy.testHero.name).toBe(origName, 'service hero unchanged before save');\n\n  click(page.saveBtn);\n  expect(hdsSpy.saveHero.calls.count()).toBe(1, 'saveHero called once');\n\n  tick(); // wait for async save to complete\n  expect(hdsSpy.testHero.name).toBe(newName, 'service hero has new name after save');\n  expect(page.navSpy.calls.any()).toBe(true, 'router.navigate called');\n}));\n\n</code-example>\n<a id=\"more-overrides\"></a>\n<h3 id=\"more-overrides\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#more-overrides\"><i class=\"material-icons\">link</i></a>More overrides</h3>\n<p>The <code>TestBed.overrideComponent</code> method can be called multiple times for the same or different components.\nThe <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> offers similar <code>overrideDirective</code>, <code>overrideModule</code>, and <code>overridePipe</code> methods\nfor digging into and replacing parts of these other classes.</p>\n<p>Explore the options and combinations on your own.\n<a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"router-outlet-component\"></a>\n<h2 id=\"test-a-routeroutlet-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-a-routeroutlet-component\"><i class=\"material-icons\">link</i></a>Test a <em>RouterOutlet</em> component</h2>\n<p>The <code>AppComponent</code> displays routed components in a <code>&#x3C;router-outlet></code>.\nIt also displays a navigation bar with anchors and their <code><a href=\"api/router/RouterLink\">RouterLink</a></code> directives.</p>\n<a id=\"app-component-html\"></a>\n<code-example path=\"testing/src/app/app.component.html\" title=\"src/app/app.component.html\" linenums=\"false\">\n&#x3C;app-banner>&#x3C;/app-banner>\n&#x3C;app-welcome>&#x3C;/app-welcome>\n\n&#x3C;nav>\n  &#x3C;a routerLink=\"/dashboard\">Dashboard&#x3C;/a>\n  &#x3C;a routerLink=\"/heroes\">Heroes&#x3C;/a>\n  &#x3C;a routerLink=\"/about\">About&#x3C;/a>\n&#x3C;/nav>\n\n&#x3C;router-outlet>&#x3C;/router-outlet>\n\n\n</code-example>\n<p>The component class does nothing.</p>\n<code-example path=\"testing/src/app/app.component.ts\" title=\"src/app/app.component.ts\" linenums=\"false\">\nimport { Component } from '@angular/core';\n@Component({\n  selector: 'my-app',\n  templateUrl: './app.component.html'\n})\nexport class AppComponent { }\n\n\n</code-example>\n<p>Unit tests can confirm that the anchors are wired properly without engaging the router.\nSee why this is worth doing <a href=\"guide/testing#why-stubbed-routerlink-tests\">below</a>.</p>\n<a id=\"stub-component\"></a>\n<h3 id=\"stubbing-unneeded-components\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#stubbing-unneeded-components\"><i class=\"material-icons\">link</i></a>Stubbing unneeded components</h3>\n<p>The test setup should look familiar.</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"setup-stubs\" title=\"src/app/app.component.spec.ts (Stub Setup)\" linenums=\"false\">\nbeforeEach( async(() => {\n  TestBed.configureTestingModule({\n    declarations: [\n      AppComponent,\n      BannerComponent, WelcomeStubComponent,\n      RouterLinkStubDirective, RouterOutletStubComponent\n    ]\n  })\n\n  .compileComponents()\n  .then(() => {\n    fixture = TestBed.createComponent(AppComponent);\n    comp    = fixture.componentInstance;\n  });\n}));\n\n</code-example>\n<p>The <code>AppComponent</code> is the declared test subject.</p>\n<p>The setup extends the default testing module with one real component (<code>BannerComponent</code>) and several stubs.</p>\n<ul>\n<li>\n<p><code>BannerComponent</code> is simple and harmless to use as is.</p>\n</li>\n<li>\n<p>The real <code>WelcomeComponent</code> has an injected service. <code>WelcomeStubComponent</code> is a placeholder with no service to worry about.</p>\n</li>\n<li>\n<p>The real <code><a href=\"api/router/RouterOutlet\">RouterOutlet</a></code> is complex and errors easily.\nThe <code>RouterOutletStubComponent</code> (in <code>testing/router-stubs.ts</code>) is safely inert.</p>\n</li>\n</ul>\n<p>The component stubs are essential.\nWithout them, the Angular compiler doesn't recognize the <code>&#x3C;app-welcome></code> and <code>&#x3C;router-outlet></code> tags\nand throws an error.</p>\n<a id=\"router-link-stub\"></a>\n<h3 id=\"stubbing-the-routerlink\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#stubbing-the-routerlink\"><i class=\"material-icons\">link</i></a>Stubbing the <em>RouterLink</em></h3>\n<p>The <code>RouterLinkStubDirective</code> contributes substantively to the test:</p>\n<code-example path=\"testing/src/testing/router-stubs.ts\" region=\"router-link\" title=\"testing/router-stubs.ts (RouterLinkStubDirective)\" linenums=\"false\">\n@Directive({\n  selector: '[routerLink]',\n  host: {\n    '(click)': 'onClick()'\n  }\n})\nexport class RouterLinkStubDirective {\n  @Input('routerLink') linkParams: any;\n  navigatedTo: any = null;\n\n  onClick() {\n    this.navigatedTo = this.linkParams;\n  }\n}\n\n</code-example>\n<p>The <code>host</code> metadata property wires the click event of the host element (the <code>&#x3C;a></code>) to the directive's <code>onClick</code> method.\nThe URL bound to the <code>[routerLink]</code> attribute flows to the directive's <code>linkParams</code> property.\nClicking the anchor should trigger the <code>onClick</code> method which sets the telltale <code>navigatedTo</code> property.\nTests can inspect that property to confirm the expected <em>click-to-navigation</em> behavior.</p>\n<a id=\"by-directive\"></a>\n<a id=\"inject-directive\"></a>\n<h3 id=\"bydirective-and-injected-directives\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#bydirective-and-injected-directives\"><i class=\"material-icons\">link</i></a><em>By.directive</em> and injected directives</h3>\n<p>A little more setup triggers the initial data binding and gets references to the navigation links:</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"test-setup\" title=\"src/app/app.component.spec.ts (test setup)\" linenums=\"false\">\nbeforeEach(() => {\n  // trigger initial data binding\n  fixture.detectChanges();\n\n  // find DebugElements with an attached RouterLinkStubDirective\n  linkDes = fixture.debugElement\n    .queryAll(By.directive(RouterLinkStubDirective));\n\n  // get the attached link directive instances using the DebugElement injectors\n  links = linkDes\n    .map(de => de.injector.get(RouterLinkStubDirective) as RouterLinkStubDirective);\n});\n\n</code-example>\n<p>Two points of special interest:</p>\n<ol>\n<li>\n<p>You can locate elements <em>by directive</em>, using <code>By.directive</code>, not just by css selectors.</p>\n</li>\n<li>\n<p>You can use the component's dependency injector to get an attached directive because\nAngular always adds attached directives to the component's injector.</p>\n</li>\n</ol>\n<a id=\"app-component-tests\"></a>\n<p>Here are some tests that leverage this setup:</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"tests\" title=\"src/app/app.component.spec.ts (selected tests)\" linenums=\"false\">\nit('can get RouterLinks from template', () => {\n  expect(links.length).toBe(3, 'should have 3 links');\n  expect(links[0].linkParams).toBe('/dashboard', '1st link should go to Dashboard');\n  expect(links[1].linkParams).toBe('/heroes', '1st link should go to Heroes');\n});\n\nit('can click Heroes link in template', () => {\n  const heroesLinkDe = linkDes[1];\n  const heroesLink = links[1];\n\n  expect(heroesLink.navigatedTo).toBeNull('link should not have navigated yet');\n\n  heroesLinkDe.triggerEventHandler('click', null);\n  fixture.detectChanges();\n\n  expect(heroesLink.navigatedTo).toBe('/heroes');\n});\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>The \"click\" test <em>in this example</em> is worthless.\nIt works hard to appear useful when in fact it\ntests the <code>RouterLinkStubDirective</code> rather than the <em>component</em>.\nThis is a common failing of directive stubs.</p>\n<p>It has a legitimate purpose in this guide.\nIt demonstrates how to find a <code><a href=\"api/router/RouterLink\">RouterLink</a></code> element, click it, and inspect a result,\nwithout engaging the full router machinery.\nThis is a skill you may need to test a more sophisticated component, one that changes the display,\nre-calculates parameters, or re-arranges navigation options when the user clicks the link.</p>\n</div>\n<a id=\"why-stubbed-routerlink-tests\"></a>\n<h3 id=\"what-good-are-these-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#what-good-are-these-tests\"><i class=\"material-icons\">link</i></a>What good are these tests?</h3>\n<p>Stubbed <code><a href=\"api/router/RouterLink\">RouterLink</a></code> tests can confirm that a component with links and an outlet is setup properly,\nthat the component has the links it should have, and that they are all pointing in the expected direction.\nThese tests do not concern whether the app will succeed in navigating to the target component when the user clicks a link.</p>\n<p>Stubbing the RouterLink and RouterOutlet is the best option for such limited testing goals.\nRelying on the real router would make them brittle.\nThey could fail for reasons unrelated to the component.\nFor example, a navigation guard could prevent an unauthorized user from visiting the <code>HeroListComponent</code>.\nThat's not the fault of the <code>AppComponent</code> and no change to that component could cure the failed test.</p>\n<p>A <em>different</em> battery of tests can explore whether the application navigates as expected\nin the presence of conditions that influence guards such as whether the user is authenticated and authorized.</p>\n<div class=\"alert is-helpful\">\n<p>A future guide update will explain how to write such\ntests with the <code><a href=\"api/router/testing/RouterTestingModule\">RouterTestingModule</a></code>.</p>\n</div>\n<p><a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"shallow-component-test\"></a>\n<h2 id=\"shallow-component-tests-with-no_errors_schema\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#shallow-component-tests-with-no_errors_schema\"><i class=\"material-icons\">link</i></a>\"Shallow component tests\" with <em>NO_ERRORS_SCHEMA</em></h2>\n<p>The <a href=\"guide/testing#stub-component\">previous setup</a> declared the <code>BannerComponent</code> and stubbed two other components\nfor <em>no reason other than to avoid a compiler error</em>.</p>\n<p>Without them, the Angular compiler doesn't recognize the <code>&#x3C;app-banner></code>, <code>&#x3C;app-welcome></code> and <code>&#x3C;router-outlet></code> tags\nin the <a href=\"guide/testing#app-component-html\"><em>app.component.html</em></a> template and throws an error.</p>\n<p>Add <code><a href=\"api/core/NO_ERRORS_SCHEMA\">NO_ERRORS_SCHEMA</a></code> to the testing module's <code>schemas</code> metadata\nto tell the compiler to ignore unrecognized elements and attributes.\nYou no longer have to declare irrelevant components and directives.</p>\n<p>These tests are <strong><em>shallow</em></strong> because they only \"go deep\" into the components you want to test.</p>\n<p>Here is a setup, with <code>import</code> statements, that demonstrates the improved simplicity of <em>shallow</em> tests, relative to the stubbing setup.</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/app.component.spec.ts (NO_ERRORS_SCHEMA)\" path=\"testing/src/app/app.component.spec.ts\" region=\"setup-schemas\">\nimport { NO_ERRORS_SCHEMA }          from '@angular/core';\nimport { AppComponent }              from './app.component';\nimport { RouterOutletStubComponent } from '../testing';\n\nbeforeEach( async(() => {\n  TestBed.configureTestingModule({\n    declarations: [ AppComponent, RouterLinkStubDirective ],\n    schemas:      [ NO_ERRORS_SCHEMA ]\n  })\n\n  .compileComponents()\n  .then(() => {\n    fixture = TestBed.createComponent(AppComponent);\n    comp    = fixture.componentInstance;\n  });\n}));\n\n</code-pane>\n\n  <code-pane title=\"src/app/app.component.spec.ts (Stubs)\" path=\"testing/src/app/app.component.spec.ts\" region=\"setup-stubs-w-imports\">\nimport { Component }                 from '@angular/core';\nimport { AppComponent }              from './app.component';\nimport { BannerComponent }           from './banner.component';\nimport { RouterLinkStubDirective }   from '../testing';\nimport { RouterOutletStubComponent } from '../testing';\n\n@Component({selector: 'app-welcome', template: ''})\nclass WelcomeStubComponent {}\n\nbeforeEach( async(() => {\n  TestBed.configureTestingModule({\n    declarations: [\n      AppComponent,\n      BannerComponent, WelcomeStubComponent,\n      RouterLinkStubDirective, RouterOutletStubComponent\n    ]\n  })\n\n  .compileComponents()\n  .then(() => {\n    fixture = TestBed.createComponent(AppComponent);\n    comp    = fixture.componentInstance;\n  });\n}));\n\n</code-pane>\n\n</code-tabs>\n<p>The <em>only</em> declarations are the <em>component-under-test</em> (<code>AppComponent</code>) and the <code>RouterLinkStubDirective</code>\nthat contributes actively to the tests.\nThe <a href=\"guide/testing#app-component-tests\">tests in this example</a> are unchanged.</p>\n<div class=\"alert is-important\">\n<p><em>Shallow component tests</em> with <code><a href=\"api/core/NO_ERRORS_SCHEMA\">NO_ERRORS_SCHEMA</a></code> greatly simplify unit testing of complex templates.\nHowever, the compiler no longer alerts you to mistakes\nsuch as misspelled or misused components and directives.</p>\n</div>\n<p><a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"attribute-directive\"></a>\n<h2 id=\"test-an-attribute-directive\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-an-attribute-directive\"><i class=\"material-icons\">link</i></a>Test an attribute directive</h2>\n<p>An <em>attribute directive</em> modifies the behavior of an element, component or another directive.\nIts name reflects the way the directive is applied: as an attribute on a host element.</p>\n<p>The sample application's <code>HighlightDirective</code> sets the background color of an element\nbased on either a data bound color or a default color (lightgray).\nIt also sets a custom property of the element (<code>customProperty</code>) to <code>true</code>\nfor no reason other than to show that it can.</p>\n<code-example path=\"testing/src/app/shared/highlight.directive.ts\" title=\"src/app/shared/highlight.directive.ts\" linenums=\"false\">\nimport { Directive, ElementRef, Input, OnChanges } from '@angular/core';\n\n@Directive({ selector: '[highlight]' })\n/** Set backgroundColor for the attached element to highlight color\n *  and set the element's customProperty to true */\nexport class HighlightDirective implements OnChanges {\n\n  defaultColor =  'rgb(211, 211, 211)'; // lightgray\n\n  @Input('highlight') bgColor: string;\n\n  constructor(private el: ElementRef) {\n    el.nativeElement.style.customProperty = true;\n  }\n\n  ngOnChanges() {\n    this.el.nativeElement.style.backgroundColor = this.bgColor || this.defaultColor;\n  }\n}\n\n\n</code-example>\n<p>It's used throughout the application, perhaps most simply in the <code>AboutComponent</code>:</p>\n<code-example path=\"testing/src/app/about.component.ts\" title=\"src/app/about.component.ts\" linenums=\"false\">\nimport { Component } from '@angular/core';\n@Component({\n  template: `\n  &#x3C;h2 highlight=\"skyblue\">About&#x3C;/h2>\n  &#x3C;twain-quote>&#x3C;/twain-quote>\n  &#x3C;p>All about this sample&#x3C;/p>`\n})\nexport class AboutComponent { }\n\n\n</code-example>\n<p>Testing the specific use of the <code>HighlightDirective</code> within the <code>AboutComponent</code> requires only the\ntechniques explored above (in particular the <a href=\"guide/testing#shallow-component-test\">\"Shallow test\"</a> approach).</p>\n<code-example path=\"testing/src/app/about.component.spec.ts\" region=\"tests\" title=\"src/app/about.component.spec.ts\" linenums=\"false\">\nbeforeEach(() => {\n  fixture = TestBed.configureTestingModule({\n    declarations: [ AboutComponent, HighlightDirective],\n    schemas:      [ NO_ERRORS_SCHEMA ]\n  })\n  .createComponent(AboutComponent);\n  fixture.detectChanges(); // initial binding\n});\n\nit('should have skyblue &#x3C;h2>', () => {\n  const de = fixture.debugElement.query(By.css('h2'));\n  const bgColor = de.nativeElement.style.backgroundColor;\n  expect(bgColor).toBe('skyblue');\n});\n\n</code-example>\n<p>However, testing a single use case is unlikely to explore the full range of a directive's capabilities.\nFinding and testing all components that use the directive is tedious, brittle, and almost as unlikely to afford full coverage.</p>\n<p><a href=\"guide/testing#isolated-unit-tests\">Isolated unit tests</a> might be helpful,\nbut attribute directives like this one tend to manipulate the DOM.\nIsolated unit tests don't touch the DOM and, therefore,\ndo not inspire confidence in the directive's efficacy.</p>\n<p>A better solution is to create an artificial test component that demonstrates all ways to apply the directive.</p>\n<code-example path=\"testing/src/app/shared/highlight.directive.spec.ts\" region=\"test-component\" title=\"src/app/shared/highlight.directive.spec.ts (TestComponent)\" linenums=\"false\">\n@Component({\n  template: `\n  &#x3C;h2 highlight=\"yellow\">Something Yellow&#x3C;/h2>\n  &#x3C;h2 highlight>The Default (Gray)&#x3C;/h2>\n  &#x3C;h2>No Highlight&#x3C;/h2>\n  &#x3C;input #box [highlight]=\"box.value\" value=\"cyan\"/>`\n})\nclass TestComponent { }\n\n</code-example>\n<figure>\n  <img src=\"generated/images/guide/testing/highlight-directive-spec.png\" alt=\"HighlightDirective spec in action\" width=\"200\" height=\"159\">\n</figure>\n<div class=\"l-sub-section\">\n<p>The <code>&#x3C;input></code> case binds the <code>HighlightDirective</code> to the name of a color value in the input box.\nThe initial value is the word \"cyan\" which should be the background color of the input box.</p>\n</div>\n<p>Here are some tests of this component:</p>\n<code-example path=\"testing/src/app/shared/highlight.directive.spec.ts\" region=\"selected-tests\" title=\"src/app/shared/highlight.directive.spec.ts (selected tests)\">\nbeforeEach(() => {\n  fixture = TestBed.configureTestingModule({\n    declarations: [ HighlightDirective, TestComponent ]\n  })\n  .createComponent(TestComponent);\n\n  fixture.detectChanges(); // initial binding\n\n  // all elements with an attached HighlightDirective\n  des = fixture.debugElement.queryAll(By.directive(HighlightDirective));\n\n  // the h2 without the HighlightDirective\n  bareH2 = fixture.debugElement.query(By.css('h2:not([highlight])'));\n});\n\n// color tests\nit('should have three highlighted elements', () => {\n  expect(des.length).toBe(3);\n});\n\nit('should color 1st &#x3C;h2> background \"yellow\"', () => {\n  const bgColor = des[0].nativeElement.style.backgroundColor;\n  expect(bgColor).toBe('yellow');\n});\n\nit('should color 2nd &#x3C;h2> background w/ default color', () => {\n  const dir = des[1].injector.get(HighlightDirective) as HighlightDirective;\n  const bgColor = des[1].nativeElement.style.backgroundColor;\n  expect(bgColor).toBe(dir.defaultColor);\n});\n\nit('should bind &#x3C;input> background to value color', () => {\n  // easier to work with nativeElement\n  const input = des[2].nativeElement as HTMLInputElement;\n  expect(input.style.backgroundColor).toBe('cyan', 'initial backgroundColor');\n\n  // dispatch a DOM event so that Angular responds to the input value change.\n  input.value = 'green';\n  input.dispatchEvent(newEvent('input'));\n  fixture.detectChanges();\n\n  expect(input.style.backgroundColor).toBe('green', 'changed backgroundColor');\n});\n\n\nit('bare &#x3C;h2> should not have a customProperty', () => {\n  expect(bareH2.properties['customProperty']).toBeUndefined();\n});\n\n</code-example>\n<p>A few techniques are noteworthy:</p>\n<ul>\n<li>\n<p>The <code>By.directive</code> predicate is a great way to get the elements that have this directive <em>when their element types are unknown</em>.</p>\n</li>\n<li>\n<p>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:not\"><code>:not</code> pseudo-class</a>\nin <code>By.css('h2:not([highlight])')</code> helps find <code>&#x3C;h2></code> elements that <em>do not</em> have the directive.\n<code>By.css('*:not([highlight])')</code> finds <em>any</em> element that does not have the directive.</p>\n</li>\n<li>\n<p><code>DebugElement.styles</code> affords access to element styles even in the absence of a real browser, thanks to the <code><a href=\"api/core/DebugElement\">DebugElement</a></code> abstraction.\nBut feel free to exploit the <code>nativeElement</code> when that seems easier or more clear than the abstraction.</p>\n</li>\n<li>\n<p>Angular adds a directive to the injector of the element to which it is applied.\nThe test for the default color uses the injector of the second <code>&#x3C;h2></code> to get its <code>HighlightDirective</code> instance\nand its <code>defaultColor</code>.</p>\n</li>\n<li>\n<p><code>DebugElement.properties</code> affords access to the artificial custom property that is set by the directive.\n<a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n</li>\n</ul>\n<hr>\n<a id=\"isolated-unit-tests\"></a>\n<h2 id=\"isolated-unit-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#isolated-unit-tests\"><i class=\"material-icons\">link</i></a>Isolated Unit Tests</h2>\n<p>Testing applications with the help of the Angular testing utilities is the main focus of this guide.</p>\n<p>However, it's often more productive to explore the inner logic of application classes\nwith <em>isolated</em>  unit tests that don't depend upon Angular.\nSuch tests are often smaller and  easier to read, write, and maintain.</p>\n<p>They don't carry extra baggage:</p>\n<ul>\n<li>Import from the Angular test libraries.</li>\n<li>Configure a module.</li>\n<li>Prepare dependency injection <code>providers</code>.</li>\n<li>Call <code><a href=\"api/core/testing/inject\">inject</a></code> or <code><a href=\"api/core/testing/async\">async</a></code> or <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code>.</li>\n</ul>\n<p>They follow patterns familiar to test developers everywhere:</p>\n<ul>\n<li>Exhibit standard, Angular-agnostic testing techniques.</li>\n<li>Create instances directly with <code>new</code>.</li>\n<li>Substitute test doubles (stubs, spys, and mocks) for the real dependencies.</li>\n</ul>\n<div class=\"callout is-important\">\n<header>\n  Write both kinds of tests\n</header>\n<p>Good developers write both kinds of tests for the same application part, often in the same spec file.\nWrite simple <em>isolated</em> unit tests to validate the part in isolation.\nWrite <em>Angular</em> tests to validate the part as it interacts with Angular,\nupdates the DOM, and collaborates with the rest of the application.</p>\n</div>\n<a id=\"isolated-service-tests\"></a>\n<h3 id=\"services\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#services\"><i class=\"material-icons\">link</i></a>Services</h3>\n<p>Services are good candidates for isolated unit testing.\nHere are some synchronous and asynchronous unit tests of the <code>FancyService</code>\nwritten without assistance from Angular testing utilities.</p>\n<code-example path=\"testing/src/app/bag/bag.no-testbed.spec.ts\" region=\"FancyService\" title=\"src/app/bag/bag.no-testbed.spec.ts\">\n// Straight Jasmine - no imports from Angular test libraries\n\ndescribe('FancyService without the TestBed', () => {\n  let service: FancyService;\n\n  beforeEach(() => { service = new FancyService(); });\n\n  it('#getValue should return real value', () => {\n    expect(service.getValue()).toBe('real value');\n  });\n\n  it('#getAsyncValue should return async value', (done: DoneFn) => {\n    service.getAsyncValue().then(value => {\n      expect(value).toBe('async value');\n      done();\n    });\n  });\n\n  it('#getTimeoutValue should return timeout value',  (done: DoneFn) => {\n    service = new FancyService();\n    service.getTimeoutValue().then(value => {\n      expect(value).toBe('timeout value');\n      done();\n    });\n  });\n\n  it('#getObservableValue should return observable value', (done: DoneFn) => {\n    service.getObservableValue().subscribe(value => {\n      expect(value).toBe('observable value');\n      done();\n    });\n  });\n\n});\n\n</code-example>\n<p>A rough line count suggests that these isolated unit tests are about 25% smaller than equivalent Angular tests.\nThat's telling but not decisive.\nThe benefit comes from reduced setup and code complexity.</p>\n<p>Compare these equivalent tests of <code>FancyService.getTimeoutValue</code>.</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/bag/bag.no-testbed.spec.ts (Isolated)\" path=\"testing/src/app/bag/bag.no-testbed.spec.ts\" region=\"getTimeoutValue\">\nit('#getTimeoutValue should return timeout value',  (done: DoneFn) => {\n  service = new FancyService();\n  service.getTimeoutValue().then(value => {\n    expect(value).toBe('timeout value');\n    done();\n  });\n});\n\n</code-pane>\n\n  <code-pane title=\"src/app/bag/bag.spec.ts (with Angular testing utilities)\" path=\"testing/src/app/bag/bag.spec.ts\" region=\"getTimeoutValue\">\nbeforeEach(() => {\n  TestBed.configureTestingModule({ providers: [FancyService] });\n});\n\nit('test should wait for FancyService.getTimeoutValue',\n  async(inject([FancyService], (service: FancyService) => {\n\n  service.getTimeoutValue().then(\n    value => expect(value).toBe('timeout value')\n  );\n})));\n\n</code-pane>\n\n</code-tabs>\n<p>They have about the same line-count, but the Angular-dependent version\nhas more moving parts including a couple of utility functions (<code><a href=\"api/core/testing/async\">async</a></code> and <code><a href=\"api/core/testing/inject\">inject</a></code>).\nBoth approaches work and it's not much of an issue if you're using the\nAngular testing utilities nearby for other reasons.\nOn the other hand, why burden simple service tests with added complexity?</p>\n<p>Pick the approach that suits you.</p>\n<a id=\"services-with-dependencies\"></a>\n<h3 id=\"services-with-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#services-with-dependencies\"><i class=\"material-icons\">link</i></a>Services with dependencies</h3>\n<p>Services often depend on other services that Angular injects into the constructor.\nYou can test these services <em>without</em> the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code>.\nIn many cases, it's easier to create and <em>inject</em> dependencies by hand.</p>\n<p>The <code>DependentService</code> is a simple example:</p>\n<code-example path=\"testing/src/app/bag/bag.ts\" region=\"DependentService\" title=\"src/app/bag/bag.ts\" linenums=\"false\">\n@Injectable()\nexport class DependentService {\n  constructor(private dependentService: FancyService) { }\n  getValue() { return this.dependentService.getValue(); }\n}\n\n</code-example>\n<p>It delegates its only method, <code>getValue</code>, to the injected <code>FancyService</code>.</p>\n<p>Here are several ways to test it.</p>\n<code-example path=\"testing/src/app/bag/bag.no-testbed.spec.ts\" region=\"DependentService\" title=\"src/app/bag/bag.no-testbed.spec.ts\">\ndescribe('DependentService without the TestBed', () => {\n  let service: DependentService;\n\n  it('#getValue should return real value by way of the real FancyService', () => {\n    service = new DependentService(new FancyService());\n    expect(service.getValue()).toBe('real value');\n  });\n\n  it('#getValue should return faked value by way of a fakeService', () => {\n    service = new DependentService(new FakeFancyService());\n    expect(service.getValue()).toBe('faked value');\n  });\n\n  it('#getValue should return faked value from a fake object', () => {\n    const fake =  { getValue: () => 'fake value' };\n    service = new DependentService(fake as FancyService);\n    expect(service.getValue()).toBe('fake value');\n  });\n\n  it('#getValue should return stubbed value from a FancyService spy', () => {\n    const fancy = new FancyService();\n    const stubValue = 'stub value';\n    const spy = spyOn(fancy, 'getValue').and.returnValue(stubValue);\n    service = new DependentService(fancy);\n\n    expect(service.getValue()).toBe(stubValue, 'service returned stub value');\n    expect(spy.calls.count()).toBe(1, 'stubbed method was called once');\n    expect(spy.calls.mostRecent().returnValue).toBe(stubValue);\n  });\n});\n\n</code-example>\n<p>The first test creates a <code>FancyService</code> with <code>new</code> and passes it to the <code>DependentService</code> constructor.</p>\n<p>However, it's rarely that simple. The injected service can be difficult to create or control.\nYou can mock the dependency, use a dummy value, or stub the pertinent service method\nwith a substitute method that's easy to control.</p>\n<p>These <em>isolated</em> unit testing techniques are great for exploring the inner logic of a service or its\nsimple integration with a component class.\nUse the Angular testing utilities when writing tests that validate how a service interacts with components\n<em>within the Angular runtime environment</em>.</p>\n<a id=\"isolated-pipe-tests\"></a>\n<h3 id=\"pipes\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#pipes\"><i class=\"material-icons\">link</i></a>Pipes</h3>\n<p>Pipes are easy to test without the Angular testing utilities.</p>\n<p>A pipe class has one method, <code>transform</code>, that manipulates the input\nvalue into a transformed output value.\nThe <code>transform</code> implementation rarely interacts with the DOM.\nMost pipes have no dependence on Angular other than the <code>@Pipe</code>\nmetadata and an interface.</p>\n<p>Consider a <code><a href=\"api/common/TitleCasePipe\">TitleCasePipe</a></code> that capitalizes the first letter of each word.\nHere's a naive implementation with a regular expression.</p>\n<code-example path=\"testing/src/app/shared/title-case.pipe.ts\" title=\"src/app/shared/title-case.pipe.ts\" linenums=\"false\">\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({name: 'titlecase', pure: false})\n/** Transform to Title Case: uppercase the first letter of the words in a string.*/\nexport class TitleCasePipe implements PipeTransform {\n  transform(input: string): string {\n    return input.length === 0 ? '' :\n      input.replace(/\\w\\S*/g, (txt => txt[0].toUpperCase() + txt.substr(1).toLowerCase() ));\n  }\n}\n\n\n</code-example>\n<p>Anything that uses a regular expression is worth testing thoroughly.\nUse simple Jasmine to explore the expected cases and the edge cases.</p>\n<code-example path=\"testing/src/app/shared/title-case.pipe.spec.ts\" region=\"excerpt\" title=\"src/app/shared/title-case.pipe.spec.ts\">\ndescribe('TitleCasePipe', () => {\n  // This pipe is a pure, stateless function so no need for BeforeEach\n  let pipe = new TitleCasePipe();\n\n  it('transforms \"abc\" to \"Abc\"', () => {\n    expect(pipe.transform('abc')).toBe('Abc');\n  });\n\n  it('transforms \"abc def\" to \"Abc Def\"', () => {\n    expect(pipe.transform('abc def')).toBe('Abc Def');\n  });\n\n  // ... more tests ...\n});\n\n</code-example>\n<a id=\"write-tests\"></a>\n<h3 id=\"write-angular-tests-too\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#write-angular-tests-too\"><i class=\"material-icons\">link</i></a>Write Angular tests too</h3>\n<p>These are tests of the pipe <em>in isolation</em>.\nThey can't tell if the <code><a href=\"api/common/TitleCasePipe\">TitleCasePipe</a></code> is working properly as applied in the application components.</p>\n<p>Consider adding component tests such as this one:</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\" title=\"src/app/hero/hero-detail.component.spec.ts (pipe test)\">\nit('should convert hero name to Title Case', () => {\n  const inputName = 'quick BROWN  fox';\n  const titleCaseName = 'Quick Brown  Fox';\n\n  // simulate user entering new name into the input box\n  page.nameInput.value = inputName;\n\n  // dispatch a DOM event so that Angular learns of input value change.\n  page.nameInput.dispatchEvent(newEvent('input'));\n\n  // Tell Angular to update the output span through the title pipe\n  fixture.detectChanges();\n\n  expect(page.nameDisplay.textContent).toBe(titleCaseName);\n});\n\n</code-example>\n<a id=\"isolated-component-tests\"></a>\n<h3 id=\"components\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#components\"><i class=\"material-icons\">link</i></a>Components</h3>\n<p>Component tests typically examine how a component class interacts with its own template or with collaborating components.\nThe Angular testing utilities are specifically designed to facilitate such tests.</p>\n<p>Consider this <code>ButtonComp</code> component.</p>\n<code-example path=\"testing/src/app/bag/bag.ts\" region=\"ButtonComp\" title=\"src/app/bag/bag.ts (ButtonComp)\" linenums=\"false\">\n@Component({\n  selector: 'button-comp',\n  template: `\n    &#x3C;button (click)=\"clicked()\">Click me!&#x3C;/button>\n    &#x3C;span>{{message}}&#x3C;/span>`\n})\nexport class ButtonComponent {\n  isOn = false;\n  clicked() { this.isOn = !this.isOn; }\n  get message() { return `The light is ${this.isOn ? 'On' : 'Off'}`; }\n}\n\n</code-example>\n<p>The following Angular test demonstrates that clicking a button in the template leads\nto an update of the on-screen message.</p>\n<code-example path=\"testing/src/app/bag/bag.spec.ts\" region=\"ButtonComp\" title=\"src/app/bag/bag.spec.ts (ButtonComp)\" linenums=\"false\">\nit('should support clicking a button', () => {\n  const fixture = TestBed.createComponent(ButtonComponent);\n  const btn  = fixture.debugElement.query(By.css('button'));\n  const span = fixture.debugElement.query(By.css('span')).nativeElement;\n\n  fixture.detectChanges();\n  expect(span.textContent).toMatch(/is off/i, 'before click');\n\n  click(btn);\n  fixture.detectChanges();\n  expect(span.textContent).toMatch(/is on/i, 'after click');\n});\n\n</code-example>\n<p>The assertions verify that the data values flow from one HTML control (the <code>&#x3C;button></code>) to the component and\nfrom the component back to a <em>different</em> HTML control (the <code>&#x3C;span></code>).\nA passing test means the component and its template are wired correctly.</p>\n<p>Isolated unit tests can more rapidly probe a component at its API boundary,\nexploring many more conditions with less effort.</p>\n<p>Here are a set of unit tests that verify the component's outputs in the face of a variety of\ncomponent inputs.</p>\n<code-example path=\"testing/src/app/bag/bag.no-testbed.spec.ts\" region=\"ButtonComp\" title=\"src/app/bag/bag.no-testbed.spec.ts (ButtonComp)\" linenums=\"false\">\ndescribe('ButtonComp', () => {\n  let comp: ButtonComponent;\n  beforeEach(() => comp = new ButtonComponent());\n\n  it('#isOn should be false initially', () => {\n    expect(comp.isOn).toBe(false);\n  });\n\n  it('#clicked() should set #isOn to true', () => {\n    comp.clicked();\n    expect(comp.isOn).toBe(true);\n  });\n\n  it('#clicked() should set #message to \"is on\"', () => {\n    comp.clicked();\n    expect(comp.message).toMatch(/is on/i);\n  });\n\n  it('#clicked() should toggle #isOn', () => {\n    comp.clicked();\n    expect(comp.isOn).toBe(true);\n    comp.clicked();\n    expect(comp.isOn).toBe(false);\n  });\n});\n\n</code-example>\n<p>Isolated component tests offer a lot of test coverage with less code and almost no setup.\nThis is even more of an advantage with complex components, which\nmay require meticulous preparation with the Angular testing utilities.</p>\n<p>On the other hand, isolated unit tests can't confirm that the <code>ButtonComp</code> is\nproperly bound to its template or even data bound at all.\nUse Angular tests for that.\n<a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<hr>\n<a id=\"atu-apis\"></a>\n<h2 id=\"angular-testing-utility-apis\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#angular-testing-utility-apis\"><i class=\"material-icons\">link</i></a>Angular testing utility APIs</h2>\n<p>This section takes inventory of the most useful Angular testing features and summarizes what they do.</p>\n<p>The Angular testing utilities include the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code>, the <code><a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a></code>, and a handful of functions that control the test environment.\nThe <a href=\"guide/testing#testbed-api-summary\"><em>TestBed</em></a> and <a href=\"guide/testing#component-fixture-api-summary\"><em>ComponentFixture</em></a> classes are covered separately.</p>\n<p>Here's a summary of the stand-alone functions, in order of likely utility:</p>\n<table>\n  <tbody><tr>\n    <th>\n      Function\n    </th>\n    <th>\n      Description\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/async\">async</a></code>\n    </td>\n    <td>\n<p>      Runs the body of a test (<code>it</code>) or setup (<code>beforeEach</code>) function within a special <em>async test zone</em>.\nSee <a href=\"guide/testing#async\">discussion above</a>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code>\n    </td>\n    <td>\n<p>      Runs the body of a test (<code>it</code>) within a special <em>fakeAsync test zone</em>, enabling\na linear control flow coding style. See <a href=\"guide/testing#fake-async\">discussion above</a>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/tick\">tick</a></code>\n    </td>\n    <td>\n<p>      Simulates the passage of time and the completion of pending asynchronous activities\nby flushing both <em>timer</em> and <em>micro-task</em> queues within the <em>fakeAsync test zone</em>.</p>\n<div class=\"l-sub-section\">\n<p>      The curious, dedicated reader might enjoy this lengthy blog post,\n<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">\"<em>Tasks, microtasks, queues and schedules</em>\"</a>.</p>\n</div>\n<p>      Accepts an optional argument that moves the virtual clock forward\nby the specified number of milliseconds,\nclearing asynchronous activities scheduled within that timeframe.\nSee <a href=\"guide/testing#tick\">discussion above</a>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n       <code><a href=\"api/core/testing/inject\">inject</a></code>\n    </td>\n    <td>\n<p>      Injects one or more services from the current <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> injector into a test function.\nSee <a href=\"guide/testing#inject\">above</a>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/discardPeriodicTasks\">discardPeriodicTasks</a></code>\n    </td>\n    <td>\n<p>      When a <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code> test ends with pending timer event <em>tasks</em> (queued <code>setTimeOut</code> and <code>setInterval</code> callbacks),\nthe test fails with a clear error message.</p>\n<p>      In general, a test should end with no queued tasks.\nWhen pending timer tasks are expected, call <code><a href=\"api/core/testing/discardPeriodicTasks\">discardPeriodicTasks</a></code> to flush the <em>task</em> queue\nand avoid the error.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/flushMicrotasks\">flushMicrotasks</a></code>\n    </td>\n    <td>\n<p>      When a <code><a href=\"api/core/testing/fakeAsync\">fakeAsync</a></code> test ends with pending <em>micro-tasks</em> such as unresolved promises,\nthe test fails with a clear error message.</p>\n<p>      In general, a test should wait for micro-tasks to finish.\nWhen pending microtasks are expected, call <code><a href=\"api/core/testing/flushMicrotasks\">flushMicrotasks</a></code> to flush the  <em>micro-task</em> queue\nand avoid the error.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\">ComponentFixtureAutoDetect</a></code>\n    </td>\n    <td>\n<p>      A provider token for a service that turns on <a href=\"guide/testing#automatic-change-detection\">automatic change detection</a>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/getTestBed\">getTestBed</a></code>\n    </td>\n    <td>\n<p>      Gets the current instance of the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code>.\nUsually unnecessary because the static class methods of the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> class are typically sufficient.\nThe <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> instance exposes a few rarely used members that are not available as\nstatic methods.</p>\n    </td>\n  </tr>\n</tbody></table>\n<hr>\n<a id=\"testbed-class-summary\"></a>\n<h3 id=\"testbed-class-summary\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#testbed-class-summary\"><i class=\"material-icons\">link</i></a><em>TestBed</em> class summary</h3>\n<p>The <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> class is one of the principal Angular testing utilities.\nIts API is quite large and can be overwhelming until you've explored it,\na little at a time. Read the early part of this guide first\nto get the basics before trying to absorb the full API.</p>\n<p>The module definition passed to <code>configureTestingModule</code>\nis a subset of the <code>@NgModule</code> metadata properties.</p>\n<code-example format=\".\" language=\"javascript\">\n  type TestModuleMetadata = {\n    providers?: any[];\n    declarations?: any[];\n    imports?: any[];\n    schemas?: Array&#x3C;SchemaMetadata | any[]>;\n  };\n\n</code-example>\n<a id=\"metadata-override-object\"></a>\n<p>Each override method takes a <code>MetadataOverride&#x3C;T></code> where <code>T</code> is the kind of metadata\nappropriate to the method, that is, the parameter of an <code>@NgModule</code>,\n<code>@Component</code>, <code>@Directive</code>, or <code>@Pipe</code>.</p>\n<code-example format=\".\" language=\"javascript\">\n  type MetadataOverride<t> = {\n    add?: T;\n    remove?: T;\n    set?: T;\n  };\n\n</t></code-example>\n<a id=\"testbed-methods\"></a>\n<a id=\"testbed-api-summary\"></a>\n<p>The <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> API consists of static class methods that either update or reference a <em>global</em> instance of the<code><a href=\"api/core/testing/TestBed\">TestBed</a></code>.</p>\n<p>Internally, all static methods cover methods of the current runtime <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> instance,\nwhich is also returned by the <code>getTestBed()</code> function.</p>\n<p>Call <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> methods <em>within</em> a <code>beforeEach()</code> to ensure a fresh start before each individual test.</p>\n<p>Here are the most important static methods, in order of likely utility.</p>\n<table>\n  <tbody><tr>\n    <th>\n      Methods\n    </th>\n    <th>\n      Description\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>configureTestingModule</code>\n    </td>\n    <td>\n<p>      The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>)\nestablish the <a href=\"guide/testing\">initial test environment</a> and a default testing module.\nThe default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs.</p>\n<p>      Call <code>configureTestingModule</code> to refine the testing module configuration for a particular set of tests\nby adding and removing imports, declarations (of components, directives, and pipes), and providers.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>compileComponents</code>\n    </td>\n    <td>\n<p>      Compile the testing module asynchronously after you've finished configuring it.\nYou <strong>must</strong> call this method if <em>any</em> of the testing module components have a <code>templateUrl</code>\nor <code>styleUrls</code> because fetching component template and style files is necessarily asynchronous.\nSee <a href=\"guide/testing#compile-components\">above</a>.</p>\n<p>      After calling <code>compileComponents</code>, the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> configuration is frozen for the duration of the current spec.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>createComponent<t></t></code>\n    </td>\n    <td>\n<p>      Create an instance of a component of type <code>T</code> based on the current <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> configuration.\nAfter calling <code>compileComponent</code>, the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> configuration is frozen for the duration of the current spec.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overrideModule</code>\n    </td>\n    <td>\n<p>      Replace metadata for the given <code><a href=\"api/core/NgModule\">NgModule</a></code>. Recall that modules can import other modules.\nThe <code>overrideModule</code> method can reach deeply into the current testing module to\nmodify one of these inner modules.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overrideComponent</code>\n    </td>\n    <td>\n<p>      Replace metadata for the given component class, which could be nested deeply\nwithin an inner module.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overrideDirective</code>\n    </td>\n    <td>\n<p>      Replace metadata for the given directive class, which could be nested deeply\nwithin an inner module.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overridePipe</code>\n    </td>\n    <td>\n<p>      Replace metadata for the given pipe class, which could be nested deeply\nwithin an inner module.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"testbed-get\"></a>\n      <code>get</code>\n    </td>\n    <td>\n<p>      Retrieve a service from the current <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> injector.</p>\n<p>      The <code><a href=\"api/core/testing/inject\">inject</a></code> function is often adequate for this purpose.\nBut <code><a href=\"api/core/testing/inject\">inject</a></code> throws an error if it can't provide the service.</p>\n<p>      What if the service is optional?</p>\n<p>      The <code>TestBed.get</code> method takes an optional second parameter,\nthe object to return if Angular can't find the provider\n(<code>null</code> in this example):\n<code-example path=\"testing/src/app/bag/bag.spec.ts\" region=\"testbed-get\" title=\"src/app/bag/bag.spec.ts\" linenums=\"false\"></code-example></p>\n      \n<p>      After calling <code>get</code>, the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> configuration is frozen for the duration of the current spec.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"testbed-initTestEnvironment\"></a>\n      <code>initTestEnvironment</code>\n    </td>\n    <td>\n<p>      Initialize the testing environment for the entire test run.</p>\n<p>      The testing shims (<code>karma-test-shim</code>, <code>browser-test-shim</code>) call it for you\nso there is rarely a reason for you to call it yourself.</p>\n<p>      You may call this method <em>exactly once</em>. If you must change\nthis default in the middle of your test run, call <code>resetTestEnvironment</code> first.</p>\n<p>      Specify the Angular compiler factory, a <code><a href=\"api/core/PlatformRef\">PlatformRef</a></code>, and a default Angular testing module.\nAlternatives for non-browser platforms are available in the general form\n<code>@angular/platform-&#x3C;platform_name>/testing/&#x3C;platform_name></code>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>resetTestEnvironment</code>\n    </td>\n    <td>\n<p>      Reset the initial test environment, including the default testing module.</p>\n    </td>\n  </tr>\n</tbody></table>\n<p>A few of the <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> instance methods are not covered by static <code><a href=\"api/core/testing/TestBed\">TestBed</a></code> <em>class</em> methods.\nThese are rarely needed.</p>\n<a id=\"component-fixture-api-summary\"></a>\n<h3 id=\"the-componentfixture\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#the-componentfixture\"><i class=\"material-icons\">link</i></a>The <em>ComponentFixture</em></h3>\n<p>The <code>TestBed.createComponent&#x3C;T></code>\ncreates an instance of the component <code>T</code>\nand returns a strongly typed <code><a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a></code> for that component.</p>\n<p>The <code><a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a></code> properties and methods provide access to the component,\nits DOM representation, and aspects of its Angular environment.</p>\n<a id=\"component-fixture-properties\"></a>\n<h3 id=\"componentfixture-properties\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#componentfixture-properties\"><i class=\"material-icons\">link</i></a><em>ComponentFixture</em> properties</h3>\n<p>Here are the most important properties for testers, in order of likely utility.</p>\n<table>\n  <tbody><tr>\n    <th>\n      Properties\n    </th>\n    <th>\n      Description\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>componentInstance</code>\n    </td>\n    <td>\n<p>      The instance of the component class created by <code>TestBed.createComponent</code>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>debugElement</code>\n    </td>\n    <td>\n<p>      The <code><a href=\"api/core/DebugElement\">DebugElement</a></code> associated with the root element of the component.</p>\n<p>      The <code>debugElement</code> provides insight into the component and its DOM element during test and debugging.\nIt's a critical property for testers. The most interesting members are covered <a href=\"guide/testing#debug-element-details\">below</a>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>nativeElement</code>\n    </td>\n    <td>\n<p>      The native DOM element at the root of the component.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>changeDetectorRef</code>\n    </td>\n    <td>\n<p>      The <code><a href=\"api/core/ChangeDetectorRef\">ChangeDetectorRef</a></code> for the component.</p>\n<p>      The <code><a href=\"api/core/ChangeDetectorRef\">ChangeDetectorRef</a></code> is most valuable when testing a\ncomponent that has the <code>ChangeDetectionStrategy.OnPush</code> method\nor the component's change detection is under your programmatic control.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"component-fixture-methods\"></a>\n<h3 id=\"componentfixture-methods\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#componentfixture-methods\"><i class=\"material-icons\">link</i></a><em>ComponentFixture</em> methods</h3>\n<p>The <em>fixture</em> methods cause Angular to perform certain tasks on the component tree.\nCall these method to trigger Angular behavior in response to simulated user action.</p>\n<p>Here are the most useful methods for testers.</p>\n<table>\n  <tbody><tr>\n    <th>\n      Methods\n    </th>\n    <th>\n      Description\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>detectChanges</code>\n    </td>\n    <td>\n<p>      Trigger a change detection cycle for the component.</p>\n<p>      Call it to initialize the component (it calls <code>ngOnInit</code>) and after your\ntest code, change the component's data bound property values.\nAngular can't see that you've changed <code>personComponent.name</code> and won't update the <code>name</code>\nbinding until you call <code>detectChanges</code>.</p>\n<p>      Runs <code>checkNoChanges</code>afterwards to confirm that there are no circular updates unless\ncalled as <code>detectChanges(false)</code>;</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>autoDetectChanges</code>\n    </td>\n    <td>\n<p>      Set this to <code>true</code> when you want the fixture to detect changes automatically.</p>\n<p>      When autodetect is <code>true</code>, the test fixture calls <code>detectChanges</code> immediately\nafter creating the component. Then it listens for pertinent zone events\nand calls <code>detectChanges</code> accordingly.\nWhen your test code modifies component property values directly,\nyou probably still have to call <code>fixture.detectChanges</code> to trigger data binding updates.</p>\n<p>      The default is <code>false</code>. Testers who prefer fine control over test behavior\ntend to keep it <code>false</code>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>checkNoChanges</code>\n    </td>\n    <td>\n<p>      Do a change detection run to make sure there are no pending changes.\nThrows an exceptions if there are.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>isStable</code>\n    </td>\n    <td>\n<p>      If the fixture is currently <em>stable</em>, returns <code>true</code>.\nIf there are async tasks that have not completed, returns <code>false</code>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>whenStable</code>\n    </td>\n    <td>\n<p>      Returns a promise that resolves when the fixture is stable.</p>\n<p>      To resume testing after completion of asynchronous activity or\nasynchronous change detection, hook that promise.\nSee <a href=\"guide/testing#when-stable\">above</a>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>destroy</code>\n    </td>\n    <td>\n<p>      Trigger component destruction.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"debug-element-details\"></a>\n<h3 id=\"debugelement\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#debugelement\"><i class=\"material-icons\">link</i></a><em>DebugElement</em></h3>\n<p>The <code><a href=\"api/core/DebugElement\">DebugElement</a></code> provides crucial insights into the component's DOM representation.</p>\n<p>From the test root component's <code><a href=\"api/core/DebugElement\">DebugElement</a></code> returned by <code>fixture.debugElement</code>,\nyou can walk (and query) the fixture's entire element and component subtrees.</p>\n<p>Here are the most useful <code><a href=\"api/core/DebugElement\">DebugElement</a></code> members for testers, in approximate order of utility:</p>\n<table>\n  <tbody><tr>\n    <th>\n      Member\n    </th>\n    <th>\n      Description\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>nativeElement</code>\n    </td>\n    <td>\n<p>      The corresponding DOM element in the browser (null for WebWorkers).</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/animations/query\">query</a></code>\n    </td>\n    <td>\n<p>      Calling <code>query(predicate: Predicate&#x3C;DebugElement>)</code> returns the first <code><a href=\"api/core/DebugElement\">DebugElement</a></code>\nthat matches the <a href=\"guide/testing#query-predicate\">predicate</a> at any depth in the subtree.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>queryAll</code>\n    </td>\n    <td>\n<p>      Calling <code>queryAll(predicate: Predicate&#x3C;DebugElement>)</code> returns all <code>DebugElements</code>\nthat matches the <a href=\"guide/testing#query-predicate\">predicate</a> at any depth in subtree.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>injector</code>\n    </td>\n    <td>\n<p>      The host dependency injector.\nFor example, the root element's component instance injector.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>componentInstance</code>\n    </td>\n    <td>\n<p>      The element's own component instance, if it has one.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>context</code>\n    </td>\n    <td>\n<p>      An object that provides parent context for this element.\nOften an ancestor component instance that governs this element.</p>\n<p>      When an element is repeated within <code>*ngFor</code>, the context is an <code>NgForRow</code> whose <code>$implicit</code>\nproperty is the value of the row instance value.\nFor example, the <code>hero</code> in <code>*ngFor=\"let hero of heroes\"</code>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>children</code>\n    </td>\n    <td>\n<p>      The immediate <code><a href=\"api/core/DebugElement\">DebugElement</a></code> children. Walk the tree by descending through <code>children</code>.</p>\n<div class=\"l-sub-section\">\n<p>      <code><a href=\"api/core/DebugElement\">DebugElement</a></code> also has <code>childNodes</code>, a list of <code><a href=\"api/core/DebugNode\">DebugNode</a></code> objects.\n<code><a href=\"api/core/DebugElement\">DebugElement</a></code> derives from <code><a href=\"api/core/DebugNode\">DebugNode</a></code> objects and there are often\nmore nodes than elements. Testers can usually ignore plain nodes.</p>\n</div>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>parent</code>\n    </td>\n    <td>\n<p>      The <code><a href=\"api/core/DebugElement\">DebugElement</a></code> parent. Null if this is the root element.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>name</code>\n    </td>\n    <td>\n<p>      The element tag name, if it is an element.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>triggerEventHandler</code>\n    </td>\n    <td>\n<p>      Triggers the event by its name if there is a corresponding listener\nin the element's <code>listeners</code> collection.\nThe second parameter is the <em>event object</em> expected by the handler.\nSee <a href=\"guide/testing#trigger-event-handler\">above</a>.</p>\n<p>      If the event lacks a listener or there's some other problem,\nconsider calling <code>nativeElement.dispatchEvent(eventObject)</code>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>listeners</code>\n    </td>\n    <td>\n<p>      The callbacks attached to the component's <code>@Output</code> properties and/or the element's event properties.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>providerTokens</code>\n    </td>\n    <td>\n<p>      This component's injector lookup tokens.\nIncludes the component itself plus the tokens that the component lists in its <code>providers</code> metadata.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>source</code>\n    </td>\n    <td>\n<p>      Where to find this element in the source component template.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>references</code>\n    </td>\n    <td>\n<p>      Dictionary of objects associated with template local variables (e.g. <code>#foo</code>),\nkeyed by the local variable name.</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"query-predicate\"></a>\n<p>The <code>DebugElement.query(predicate)</code> and <code>DebugElement.queryAll(predicate)</code> methods take a\npredicate that filters the source element's subtree for matching <code><a href=\"api/core/DebugElement\">DebugElement</a></code>.</p>\n<p>The predicate is any method that takes a <code><a href=\"api/core/DebugElement\">DebugElement</a></code> and returns a <em>truthy</em> value.\nThe following example finds all <code>DebugElements</code> with a reference to a template local variable named \"content\":</p>\n<code-example path=\"testing/src/app/bag/bag.spec.ts\" region=\"custom-predicate\" title=\"src/app/bag/bag.spec.ts\" linenums=\"false\">\n// Filter for DebugElements with a #content reference\nconst contentRefs = el.queryAll( de => de.references['content']);\n\n</code-example>\n<p>The Angular <code><a href=\"api/platform-browser/By\">By</a></code> class has three static methods for common predicates:</p>\n<ul>\n<li><code>By.all</code> - return all elements.</li>\n<li><code>By.css(selector)</code> - return elements with matching CSS selectors.</li>\n<li><code>By.directive(directive)</code> - return elements that Angular matched to an instance of the directive class.</li>\n</ul>\n<code-example path=\"testing/src/app/hero/hero-list.component.spec.ts\" region=\"by\" title=\"src/app/hero/hero-list.component.spec.ts\" linenums=\"false\">\n// Can find DebugElement either by css selector or by directive\nconst h2        = fixture.debugElement.query(By.css('h2'));\nconst directive = fixture.debugElement.query(By.directive(HighlightDirective));\n\n</code-example>\n<p><a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<div class=\"l\">\n</div>\n<a id=\"setup-files\"></a>\n<h2 id=\"test-environment-setup-files\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#test-environment-setup-files\"><i class=\"material-icons\">link</i></a>Test environment setup files</h2>\n<p>Unit testing requires some configuration and bootstrapping that is captured in <em>setup files</em>.\nThe setup files for this guide are provided for you when you follow the <a href=\"guide/setup\">Setup</a> instructions.\nThe CLI delivers similar files with the same purpose.</p>\n<p>Here's a brief description of this guide's setup files:</p>\n<div class=\"l-sub-section\">\n<p>The deep details of these files and how to reconfigure them for your needs\nis a topic beyond the scope of this guide .</p>\n</div>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  \n  <col width=\"80%\">\n  \n  </colgroup><tbody><tr>\n    <th>\n      File\n    </th>\n    <th>\n      Description\n    </th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>karma.conf.js</code>\n    </td>\n    <td>\n<p>      The karma configuration file that specifies which plug-ins to use,\nwhich application and test files to load, which browser(s) to use,\nand how to report test results.</p>\n<p>      It loads three other setup files:\n<em> <code>systemjs.config.js</code>\n</em> <code>systemjs.config.extras.js</code>\n* <code>karma-test-shim.js</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>karma-test-shim.js</code>\n    </td>\n    <td>\n<p>      This shim prepares karma specifically for the Angular test environment\nand launches karma itself.\nIt loads the <code>systemjs.config.js</code> file as part of that process.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>systemjs.config.js</code>\n    </td>\n    <td>\n<p>      <a href=\"https://github.com/systemjs/systemjs/blob/master/README.md\">SystemJS</a>\nloads the application and test files.\nThis script tells SystemJS where to find those files and how to load them.\nIt's the same version of <code>systemjs.config.js</code> you installed during <a href=\"guide/testing#setup\">setup</a>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>systemjs.config.extras.js</code>\n    </td>\n    <td>\n<p>      An optional file that supplements the SystemJS configuration in <code>systemjs.config.js</code> with\nconfiguration for the specific needs of the application itself.</p>\n<p>      A stock <code>systemjs.config.js</code> can't anticipate those needs.\nYou fill the gaps here.</p>\n<p>      The sample version for this guide adds the <strong>model barrel</strong>\nto the SystemJs <code>packages</code> configuration.</p>\n    </td>\n  </tr>\n  <tr>\n    <td colspan=\"2\">\n      <code-example path=\"testing/src/systemjs.config.extras.js\" title=\"systemjs.config.extras.js\" linenums=\"false\">\n/** App specific SystemJS configuration */\nSystem.config({\n  packages: {\n    // barrels\n    'app/model': {main:'index.js', defaultExtension:'js'},\n    'app/model/testing': {main:'index.js', defaultExtension:'js'}\n  }\n});\n\n\n</code-example>\n    </td>\n  </tr>\n</tbody></table>\n<h3 id=\"npm-packages\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#npm-packages\"><i class=\"material-icons\">link</i></a>npm packages</h3>\n<p>The sample tests are written to run in Jasmine and karma.\nThe two \"fast path\" setups added the appropriate Jasmine and karma npm packages to the\n<code>devDependencies</code> section of the <code>package.json</code>.\nThey're installed when you run <code>npm install</code>.\n<a href=\"guide/testing#top\" class=\"to-top\">Back to top</a></p>\n<div class=\"l\">\n  <div id=\"faq\">\n  </div>\n<h2 id=\"faq-frequently-asked-questions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#faq-frequently-asked-questions\"><i class=\"material-icons\">link</i></a>FAQ: Frequently Asked Questions</h2>\n</div>\n<div id=\"q-spec-file-location\">\n</div>\n<h3 id=\"why-put-specs-next-to-the-things-they-test\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#why-put-specs-next-to-the-things-they-test\"><i class=\"material-icons\">link</i></a>Why put specs next to the things they test?</h3>\n<p>It's a good idea to put unit test spec files in the same folder\nas the application source code files that they test:</p>\n<ul>\n<li>Such tests are easy to find.</li>\n<li>You see at a glance if a part of your application lacks tests.</li>\n<li>Nearby tests can reveal how a part works in context.</li>\n<li>When you move the source (inevitable), you remember to move the test.</li>\n<li>When you rename the source file (inevitable), you remember to rename the test file.</li>\n</ul>\n<hr>\n<div id=\"q-specs-in-test-folder\">\n</div>\n<h3 id=\"when-would-i-put-specs-in-a-test-folder\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing#when-would-i-put-specs-in-a-test-folder\"><i class=\"material-icons\">link</i></a>When would I put specs in a test folder?</h3>\n<p>Application integration specs can test the interactions of multiple parts\nspread across folders and modules.\nThey don't really belong to any part in particular, so they don't have a\nnatural home next to any one file.</p>\n<p>It's often better to create an appropriate folder for them in the <code>tests</code> directory.</p>\n<p>Of course specs that test the test helpers belong in the <code>test</code> folder,\nnext to their corresponding helper files.</p>\n\n</div>"
}