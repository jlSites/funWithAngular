{
  "id": "guide/upgrade",
  "title": "Upgrading from AngularJS",
  "contents": "\n<div class=\"content\">\n<h1 id=\"upgrading-from-angularjs\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-from-angularjs\"><i class=\"material-icons\">link</i></a>Upgrading from AngularJS</h1>\n<p><em>Angular</em> is the name for the Angular of today and tomorrow.\n<em>AngularJS</em> is the name for all v1.x versions of Angular.</p>\n<p>AngularJS apps are great.\nAlways consider the business case before moving to Angular.\nAn important part of that case is the time and effort to get there.\nThis guide describes the built-in tools for efficiently migrating AngularJS projects over to the\nAngular platform, a piece at a time.</p>\n<p>Some applications will be easier to upgrade than others, and there are\nmany ways to make it easier for yourself. It is possible to\nprepare and align AngularJS applications with Angular even before beginning\nthe upgrade process. These preparation steps are all about making the code\nmore decoupled, more maintainable, and better aligned with modern development\ntools. That means in addition to making the upgrade easier,\nyou will also improve the existing AngularJS applications.</p>\n<p>One of the keys to a successful upgrade is to do it incrementally,\nby running the two frameworks side by side in the same application, and\nporting AngularJS components to Angular one by one. This makes it possible\nto upgrade even large and complex applications without disrupting other\nbusiness, because the work can be done collaboratively and spread over\na period of time. The <code>upgrade</code> module in Angular has been designed to\nmake incremental upgrading seamless.</p>\n<h2 id=\"preparation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#preparation\"><i class=\"material-icons\">link</i></a>Preparation</h2>\n<p>There are many ways to structure AngularJS applications. When you begin\nto upgrade these applications to Angular, some will turn out to be\nmuch more easy to work with than others. There are a few key techniques\nand patterns that you can apply to future proof apps even before you\nbegin the migration.</p>\n<a id=\"follow-the-angular-styleguide\"></a>\n<h3 id=\"follow-the-angularjs-style-guide\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#follow-the-angularjs-style-guide\"><i class=\"material-icons\">link</i></a>Follow the AngularJS Style Guide</h3>\n<p>The <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\">AngularJS Style Guide</a>\ncollects patterns and practices that have been proven to result in\ncleaner and more maintainable AngularJS applications. It contains a wealth\nof information about how to write and organize AngularJS code - and equally\nimportantly - how <strong>not</strong> to write and organize AngularJS code.</p>\n<p>Angular is a reimagined version of the best parts of AngularJS. In that\nsense, its goals are the same as the AngularJS Style Guide's: To preserve\nthe good parts of AngularJS, and to avoid the bad parts. There's a lot\nmore to Angular than just that of course, but this does mean that\n<em>following the style guide helps make your AngularJS app more closely\naligned with Angular</em>.</p>\n<p>There are a few rules in particular that will make it much easier to do\n<em>an incremental upgrade</em> using the Angular <code><a href=\"api/upgrade/static\">upgrade/static</a></code> module:</p>\n<ul>\n<li>\n<p>The <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\">Rule of 1</a>\nstates that there should be one component per file. This not only makes\ncomponents easy to navigate and find, but will also allow us to migrate\nthem between languages and frameworks one at a time. In this example application,\neach controller, component, service, and filter is in its own source file.</p>\n</li>\n<li>\n<p>The <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\">Folders-by-Feature Structure</a>\nand <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\">Modularity</a>\nrules define similar principles on a higher level of abstraction: Different parts of the\napplication should reside in different directories and NgModules.</p>\n</li>\n</ul>\n<p>When an application is laid out feature per feature in this way, it can also be\nmigrated one feature at a time. For applications that don't already look like\nthis, applying the rules in the AngularJS style guide is a highly recommended\npreparation step. And this is not just for the sake of the upgrade - it is just\nsolid advice in general!</p>\n<h3 id=\"using-a-module-loader\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-a-module-loader\"><i class=\"material-icons\">link</i></a>Using a Module Loader</h3>\n<p>When you break application code down into one component per file, you often end\nup with a project structure with a large number of relatively small files. This is\na much neater way to organize things than a small number of large files, but it\ndoesn't work that well if you have to load all those files to the HTML page with\n&#x3C;script> tags. Especially when you also have to maintain those tags in the correct\norder. That's why it's a good idea to start using a <em>module loader</em>.</p>\n<p>Using a module loader such as <a href=\"https://github.com/systemjs/systemjs\">SystemJS</a>,\n<a href=\"http://webpack.github.io/\">Webpack</a>, or <a href=\"http://browserify.org/\">Browserify</a>\nallows us to use the built-in module systems of TypeScript or ES2015.\nYou can use the <code>import</code> and <code>export</code> features that explicitly specify what code can\nand will be shared between different parts of the application. For ES5 applications\nyou can use CommonJS style <code>require</code> and <code>module.exports</code> features. In both cases,\nthe module loader will then take care of loading all the code the application needs\nin the correct order.</p>\n<p>When moving applications into production, module loaders also make it easier\nto package them all up into production bundles with batteries included.</p>\n<h3 id=\"migrating-to-typescript\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#migrating-to-typescript\"><i class=\"material-icons\">link</i></a>Migrating to TypeScript</h3>\n<p>If part of the Angular upgrade plan is to also take TypeScript into use, it makes\nsense to bring in the TypeScript compiler even before the upgrade itself begins.\nThis means there's one less thing to learn and think about during the actual upgrade.\nIt also means you can start using TypeScript features in your AngularJS code.</p>\n<p>Since TypeScript is a superset of ECMAScript 2015, which in turn is a superset\nof ECMAScript 5, \"switching\" to TypeScript doesn't necessarily require anything\nmore than installing the TypeScript compiler and renaming files from\n<code>*.js</code> to <code>*.ts</code>. But just doing that is not hugely useful or exciting, of course.\nAdditional steps like the following can give us much more bang for the buck:</p>\n<ul>\n<li>\n<p>For applications that use a module loader, TypeScript imports and exports\n(which are really ECMAScript 2015 imports and exports) can be used to organize\ncode into modules.</p>\n</li>\n<li>\n<p>Type annotations can be gradually added to existing functions and variables\nto pin down their types and get benefits like build-time error checking,\ngreat autocompletion support and inline documentation.</p>\n</li>\n<li>\n<p>JavaScript features new to ES2015, like arrow functions, <code>let</code>s and <code>const</code>s,\ndefault function parameters, and destructuring assignments can also be gradually\nadded to make the code more expressive.</p>\n</li>\n<li>\n<p>Services and controllers can be turned into <em>classes</em>. That way they'll be a step\ncloser to becoming Angular service and component classes, which will make\nlife easier after the upgrade.</p>\n</li>\n</ul>\n<h3 id=\"using-component-directives\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-component-directives\"><i class=\"material-icons\">link</i></a>Using Component Directives</h3>\n<p>In Angular, components are the main primitive from which user interfaces\nare built. You define the different portions of the UI as components and\ncompose them into a full user experience.</p>\n<p>You can also do this in AngularJS, using <em>component directives</em>. These are\ndirectives that define their own templates, controllers, and input/output bindings -\nthe same things that Angular components define. Applications built with\ncomponent directives are much easier to migrate to Angular than applications\nbuilt with lower-level features like <code>ng-controller</code>,  <code>ng-include</code>, and scope\ninheritance.</p>\n<p>To be Angular compatible, an AngularJS component directive should configure\nthese attributes:</p>\n<ul>\n<li><code>restrict: 'E'</code>. Components are usually used as elements.</li>\n<li><code>scope: {}</code> - an isolate scope. In Angular, components are always isolated\nfrom their surroundings, and you should do this in AngularJS too.</li>\n<li><code>bindToController: {}</code>. Component inputs and outputs should be bound\nto the controller instead of using the <code>$scope</code>.</li>\n<li><code>controller</code> and <code>controllerAs</code>. Components have their own controllers.</li>\n<li><code>template</code> or <code>templateUrl</code>. Components have their own templates.</li>\n</ul>\n<p>Component directives may also use the following attributes:</p>\n<ul>\n<li><code>transclude: true/{}</code>, if the component needs to transclude content from elsewhere.</li>\n<li><code>require</code>, if the component needs to communicate with some parent component's\ncontroller.</li>\n</ul>\n<p>Component directives <strong>should not</strong> use the following attributes:</p>\n<ul>\n<li><code>compile</code>. This will not be supported in Angular.</li>\n<li><code>replace: true</code>. Angular never replaces a component element with the\ncomponent template. This attribute is also deprecated in AngularJS.</li>\n<li><code>priority</code> and <code>terminal</code>. While AngularJS components may use these,\nthey are not used in Angular and it is better not to write code\nthat relies on them.</li>\n</ul>\n<p>An AngularJS component directive that is fully aligned with the Angular\narchitecture may look something like this:</p>\n<code-example path=\"upgrade-module/src/app/hero-detail.directive.ts\" title=\"hero-detail.directive.ts\">\nexport function heroDetailDirective() {\n  return {\n    restrict: 'E',\n    scope: {},\n    bindToController: {\n      hero: '=',\n      deleted: '&#x26;'\n    },\n    template: `\n      &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n      &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n      &#x3C;button ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n    `,\n    controller: function() {\n      this.onDelete = () => {\n        this.deleted({hero: this.hero});\n      };\n    },\n    controllerAs: '$ctrl'\n  };\n}\n\n\n</code-example>\n<p>AngularJS 1.5 introduces the <a href=\"https://docs.angularjs.org/api/ng/type/angular.Module#component\">component API</a>\nthat makes it easier to define component directives like these. It is a good idea to use\nthis API for component directives for several reasons:</p>\n<ul>\n<li>It requires less boilerplate code.</li>\n<li>It enforces the use of component best practices like <code>controllerAs</code>.</li>\n<li>It has good default values for directive attributes like <code>scope</code> and <code>restrict</code>.</li>\n</ul>\n<p>The component directive example from above looks like this when expressed\nusing the component API:</p>\n<code-example path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\" title=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&#x3C;',\n    deleted: '&#x26;'\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n    &#x3C;button ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n  `,\n  controller: function() {\n    this.onDelete = () => {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p>Controller lifecycle hook methods <code>$onInit()</code>, <code>$onDestroy()</code>, and <code>$onChanges()</code>\nare another convenient feature that AngularJS 1.5 introduces. They all have nearly\nexact <a href=\"guide/lifecycle-hooks\">equivalents in Angular</a>, so organizing component lifecycle\nlogic around them will ease the eventual Angular upgrade process.</p>\n<h2 id=\"upgrading-with-ngupgrade\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a>Upgrading with ngUpgrade</h2>\n<p>The ngUpgrade library in Angular is a very useful tool for upgrading\nanything but the smallest of applications. With it you can mix and match\nAngularJS and Angular components in the same application and have them interoperate\nseamlessly. That means you don't have to do the upgrade work all at once,\nsince there's a natural coexistence between the two frameworks during the\ntransition period.</p>\n<h3 id=\"how-ngupgrade-works\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a>How ngUpgrade Works</h3>\n<p>The primary tool provided by ngUpgrade is called the <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code>.\nThis is a module that contains utilities for bootstrapping and managing hybrid\napplications that support both Angular and AngularJS code.</p>\n<p>When you use ngUpgrade, what you're really doing is <em>running both AngularJS and\nAngular at the same time</em>. All Angular code is running in the Angular\nframework, and AngularJS code in the AngularJS framework. Both of these are the\nactual, fully featured versions of the frameworks. There is no emulation going on,\nso you can expect to have all the features and natural behavior of both frameworks.</p>\n<p>What happens on top of this is that components and services managed by one\nframework can interoperate with those from the other framework. This happens\nin three main areas: Dependency injection, the DOM, and change detection.</p>\n<h4 id=\"dependency-injection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#dependency-injection\"><i class=\"material-icons\">link</i></a>Dependency Injection</h4>\n<p>Dependency injection is front and center in both AngularJS and\nAngular, but there are some key differences between the two\nframeworks in how it actually works.</p>\n<table>\n  <tbody><tr>\n    <th>\n      AngularJS\n    </th>\n    <th>\n      Angular\n    </th>\n  </tr>\n  <tr>\n    <td>\n      Dependency injection tokens are always strings\n    </td>\n    <td>\n<p>      Tokens <a href=\"guide/dependency-injection\">can have different types</a>.\nThey are often classes. They may also be strings.</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p>      There is exactly one injector. Even in multi-module applications,\neverything is poured into one big namespace.</p>\n    </td>\n    <td>\n<p>      There is a <a href=\"guide/hierarchical-dependency-injection\">tree hierarchy of injectors</a>,\nwith a root injector and an additional injector for each component.</p>\n    </td>\n  </tr>\n</tbody></table>\n<p>Even accounting for these differences you can still have dependency injection\ninteroperability. The <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> resolves the differences and makes\neverything work seamlessly:</p>\n<ul>\n<li>\n<p>You can make AngularJS services available for injection to Angular code\nby <em>upgrading</em> them. The same singleton instance of each service is shared\nbetween the frameworks. In Angular these services will always be in the\n<em>root injector</em> and available to all components.</p>\n</li>\n<li>\n<p>You can also make Angular services available for injection to AngularJS code\nby <em>downgrading</em> them. Only services from the Angular root injector can\nbe downgraded. Again, the same singleton instances are shared between the frameworks.\nWhen you register a downgraded service, you must explicitly specify a <em>string token</em> that you want to\nuse in AngularJS.</p>\n</li>\n</ul>\n<figure>\n  <img src=\"generated/images/guide/upgrade/injectors.png\" alt=\"The two injectors in a hybrid application\" width=\"700\" height=\"262\">\n</figure>\n<h4 id=\"components-and-the-dom\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#components-and-the-dom\"><i class=\"material-icons\">link</i></a>Components and the DOM</h4>\n<p>In the DOM of a hybrid ngUpgrade application are components and\ndirectives from both AngularJS and Angular. These components\ncommunicate with each other by using the input and output bindings\nof their respective frameworks, which ngUpgrade bridges together. They may also\ncommunicate through shared injected dependencies, as described above.</p>\n<p>The key thing to understand about a hybrid application is that every element in the DOM is owned by exactly one of the two frameworks.\nThe other framework ignores it. If an element is\nowned by AngularJS, Angular treats it as if it didn't exist,\nand vice versa.</p>\n<p>So normally a hybrid application begins life as an AngularJS application,\nand it is AngularJS that processes the root template, e.g. the index.html.\nAngular then steps into the picture when an Angular component is used somewhere\nin an AngularJS template. That component's template will then be managed\nby Angular, and it may contain any number of Angular components and\ndirectives.</p>\n<p>Beyond that, you may interleave the two frameworks.\nYou always cross the boundary between the two frameworks by one of two\nways:</p>\n<ol>\n<li>\n<p>By using a component from the other framework: An AngularJS template\nusing an Angular component, or an Angular template using an\nAngularJS component.</p>\n</li>\n<li>\n<p>By transcluding or projecting content from the other framework. ngUpgrade\nbridges the related concepts of AngularJS transclusion and Angular content\nprojection together.</p>\n</li>\n</ol>\n<figure>\n  <img src=\"generated/images/guide/upgrade/dom.png\" alt=\"DOM element ownership in a hybrid application\" width=\"500\" height=\"294\">\n</figure>\n<p>Whenever you use a component that belongs to the other framework, a\nswitch between framework boundaries occurs. However, that switch only\nhappens to the elements in the template of that component. Consider a situation\nwhere you use an Angular component from AngularJS like this:</p>\n<code-example language=\"html\" escape=\"html\">\n  &#x3C;a-component>&#x3C;/a-component>\n</code-example>\n<p>The DOM element <code>&#x3C;a-component></code> will remain to be an AngularJS managed\nelement, because it's defined in an AngularJS template. That also\nmeans you can apply additional AngularJS directives to it, but <em>not</em>\nAngular directives. It is only in the template of the <code>&#x3C;a-component></code>\nwhere Angular steps in. This same rule also applies when you\nuse AngularJS component directives from Angular.</p>\n<h4 id=\"change-detection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#change-detection\"><i class=\"material-icons\">link</i></a>Change Detection</h4>\n<p>The <code>scope.$apply()</code> is how AngularJS detects changes and updates data bindings.\nAfter every event that occurs, <code>scope.$apply()</code> gets called. This is done either\nautomatically by the framework, or manually by you.</p>\n<p>In Angular things are different. While change detection still\noccurs after every event, no one needs to call <code>scope.$apply()</code> for\nthat to happen. This is because all Angular code runs inside something\ncalled the <a href=\"api/core/NgZone\">Angular zone</a>. Angular always\nknows when the code finishes, so it also knows when it should kick off\nchange detection. The code itself doesn't have to call <code>scope.$apply()</code>\nor anything like it.</p>\n<p>In the case of hybrid applications, the <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> bridges the\nAngularJS and Angular approaches. Here's what happens:</p>\n<ul>\n<li>\n<p>Everything that happens in the application runs inside the Angular zone.\nThis is true whether the event originated in AngularJS or Angular code.\nThe zone triggers Angular change detection after every event.</p>\n</li>\n<li>\n<p>The <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> will invoke the AngularJS <code>$rootScope.$apply()</code> after\nevery turn of the Angular zone. This also triggers AngularJS change\ndetection after every event.</p>\n</li>\n</ul>\n<figure>\n  <img src=\"generated/images/guide/upgrade/change_detection.png\" alt=\"Change detection in a hybrid application\" width=\"600\" height=\"163\">\n</figure>\n<p>In practice, you do not need to call <code>$apply()</code>,\nregardless of whether it is in AngularJS on Angular. The\n<code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> does it for us. You <em>can</em> still call <code>$apply()</code> so there\nis no need to remove such calls from existing code. Those calls just trigger\nadditional AngularJS change detection checks in a hybrid application.</p>\n<p>When you downgrade an Angular component and then use it from AngularJS,\nthe component's inputs will be watched using AngularJS change detection.\nWhen those inputs change, the corresponding properties in the component\nare set. You can also hook into the changes by implementing the\n<a href=\"api/core/OnChanges\">OnChanges</a> interface in the component,\njust like you could if it hadn't been downgraded.</p>\n<p>Correspondingly, when you upgrade an AngularJS component and use it from Angular,\nall the bindings defined for the component directive's <code>scope</code> (or <code>bindToController</code>)\nwill be hooked into Angular change detection. They will be treated\nas regular Angular inputs. Their values will be written to the upgraded component's\nscope (or controller) when they change.</p>\n<h3 id=\"using-upgrademodule-with-angular-ngmodules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-upgrademodule-with-angular-ngmodules\"><i class=\"material-icons\">link</i></a>Using UpgradeModule with Angular <em>NgModules</em></h3>\n<p>Both AngularJS and Angular have their own concept of modules\nto help organize an application into cohesive blocks of functionality.</p>\n<p>Their details are quite different in architecture and implementation.\nIn AngularJS, you add Angular assets to the <code>angular.module</code> property.\nIn Angular, you create one or more classes adorned with an <code><a href=\"api/core/NgModule\">NgModule</a></code> decorator\nthat describes Angular assets in metadata. The differences blossom from there.</p>\n<p>In a hybrid application you run both versions of Angular at the same time.\nThat means that you need at least one module each from both AngularJS and Angular.\nYou will import <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> inside the NgModule, and then use it for\nbootstrapping the AngularJS module.</p>\n<div class=\"l-sub-section\">\n<p>Read more about <a href=\"guide/ngmodule\">NgModules</a>.</p>\n</div>\n<h3 id=\"bootstrapping-hybrid-applications\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-hybrid-applications\"><i class=\"material-icons\">link</i></a>Bootstrapping hybrid applications</h3>\n<p>To bootstrap a hybrid application, you must bootstrap each of the Angular and\nAngularJS parts of the application. You must bootstrap the Angular bits first and\nthen ask the <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> to bootstrap the AngularJS bits next.</p>\n<p>In an AngularJS application you have a root AngularJS module, which will also\nbe used to bootstrap the AngularJS application.</p>\n<code-example path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"ng1module\" title=\"app.module.ts\">\nangular.module('heroApp', [])\n  .controller('MainCtrl', function() {\n    this.message = 'Hello world';\n  });\n\n</code-example>\n<p>Pure AngularJS applications can be automatically bootstrapped by using an <code>ng-app</code>\ndirective somewhere on the HTML page. But for hybrid applications, you manually bootstrap via the\n<code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code>. Therefore, it is a good preliminary step to switch AngularJS applications to use the\nmanual JavaScript <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\"><code>angular.bootstrap</code></a>\nmethod even before switching them to hybrid mode.</p>\n<p>Say you have an <code>ng-app</code> driven bootstrap such as this one:</p>\n<code-example path=\"upgrade-module/src/index-ng-app.html\">\n&#x3C;!DOCTYPE HTML>\n&#x3C;html>\n  &#x3C;head>\n    &#x3C;base href=\"/\">\n    &#x3C;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js\">&#x3C;/script>\n    &#x3C;script src=\"app/ajs-ng-app/app.module.js\">&#x3C;/script>\n  &#x3C;/head>\n\n  &#x3C;body ng-app=\"heroApp\" ng-strict-di>\n    &#x3C;div id=\"message\" ng-controller=\"MainCtrl as mainCtrl\">\n      {{ mainCtrl.message }}\n    &#x3C;/div>\n  &#x3C;/body>\n&#x3C;/html>\n\n\n</code-example>\n<p>You can remove the <code>ng-app</code> and <code>ng-strict-di</code> directives from the HTML\nand instead switch to calling <code>angular.bootstrap</code> from JavaScript, which\nwill result in the same thing:</p>\n<code-example path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"bootstrap\" title=\"app.module.ts\">\nangular.bootstrap(document.body, ['heroApp'], { strictDi: true });\n\n</code-example>\n<p>To begin converting your AngularJS application to a hybrid, you need to load the Angular framework.\nYou can see how this can be done with SystemJS by following the instructions in <a href=\"guide/setup\">Setup</a>,\nselectively copying code from the <a href=\"https://github.com/angular/quickstart\">QuickStart github repository</a>.</p>\n<p>You also need to install the <code>@angular/upgrade</code> package via <code>npm install @angular/upgrade --save</code>\nand add a mapping for the <code>@angular/upgrade/static</code> package:</p>\n<code-example path=\"upgrade-module/src/systemjs.config.1.js\" region=\"upgrade-static-umd\" title=\"systemjs.config.js (map)\">\n'@angular/upgrade/static': 'npm:@angular/upgrade/bundles/upgrade-static.umd.js',\n\n</code-example>\n<p>Next, create an <code>app.module.ts</code> file and add the following <code><a href=\"api/core/NgModule\">NgModule</a></code> class:</p>\n<code-example path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"ngmodule\" title=\"app.module.ts\">\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { UpgradeModule } from '@angular/upgrade/static';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p>This bare minimum <code><a href=\"api/core/NgModule\">NgModule</a></code> imports <code><a href=\"api/platform-browser/BrowserModule\">BrowserModule</a></code>, the module every Angular browser-based app must have.\nIt also imports <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> from <code>@angular/upgrade/static</code>, which exports providers that will be used\nfor upgrading and downgrading services and components.</p>\n<p>In the constructor of the <code>AppModule</code>, use dependency injection to get a hold of the <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> instance,\nand use it to bootstrap the AngularJS app in the <code>AppModule.ngDoBootstrap</code> method.\nThe <code>upgrade.bootstrap</code> method takes the exact same arguments as <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\">angular.bootstrap</a>:</p>\n<div class=\"l-sub-section\">\n<p>Note that you do not add a <code>bootstrap</code> declaration to the <code>@NgModule</code> decorator, since\nAngularJS will own the root template of the application.</p>\n</div>\n<p>Now you can bootstrap <code>AppModule</code> using the <code>platformBrowserDynamic.bootstrapModule</code> method.</p>\n<code-example path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"bootstrap\" title=\"app.module.ts&#x27;\">\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n</code-example>\n<p>Congratulations! You're running a hybrid application! The\nexisting AngularJS code works as before <em>and</em> you're ready to start adding Angular code.</p>\n<h3 id=\"using-angular-components-from-angularjs-code\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angular-components-from-angularjs-code\"><i class=\"material-icons\">link</i></a>Using Angular Components from AngularJS Code</h3>\n<img src=\"generated/images/guide/upgrade/ajs-to-a.png\" alt=\"Using an Angular component from AngularJS code\" class=\"left\" width=\"250\" height=\"44\">\n<p>Once you're running a hybrid app, you can start the gradual process of upgrading\ncode. One of the more common patterns for doing that is to use an Angular component\nin an AngularJS context. This could be a completely new component or one that was\npreviously AngularJS but has been rewritten for Angular.</p>\n<p>Say you have a simple Angular component that shows information about a hero:</p>\n<code-example path=\"upgrade-module/src/app/downgrade-static/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>Windstorm details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>1&#x3C;/div>\n  `\n})\nexport class HeroDetailComponent { }\n\n\n</code-example>\n<p>If you want to use this component from AngularJS, you need to <em>downgrade</em> it\nusing the <code>downgradeComponent()</code> method. The result is an AngularJS\n<em>directive</em>, which you can then register in the AngularJS module:</p>\n<code-example path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"downgradecomponent\" title=\"app.module.ts\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n/* . . . */\n\nimport { downgradeComponent } from '@angular/upgrade/static';\n\nangular.module('heroApp', [])\n  .directive(\n    'heroDetail',\n    downgradeComponent({ component: HeroDetailComponent }) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<p>Because <code>HeroDetailComponent</code> is an Angular component, you must also add it to the\n<code>declarations</code> in the <code>AppModule</code>.</p>\n<p>And because this component is being used from the AngularJS module, and is an entry point into\nthe Angular application, you must add it to the <code>entryComponents</code> for the\nNgModule.</p>\n<code-example path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"ngmodule\" title=\"app.module.ts\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  declarations: [\n    HeroDetailComponent\n  ],\n  entryComponents: [\n    HeroDetailComponent\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>All Angular components, directives and pipes must be declared in an NgModule.</p>\n</div>\n<p>The net result is an AngularJS directive called <code>heroDetail</code>, that you can\nuse like any other directive in AngularJS templates.</p>\n<code-example path=\"upgrade-module/src/index-downgrade-static.html\" region=\"usecomponent\">\n&#x3C;hero-detail>&#x3C;/hero-detail>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>Note that this AngularJS is an element directive (<code>restrict: 'E'</code>) called <code>heroDetail</code>.\nAn AngularJS element directive is matched based on its <em>name</em>.\n<em>The <code>selector</code> metadata of the downgraded Angular component is ignored.</em></p>\n</div>\n<p>Most components are not quite this simple, of course. Many of them\nhave <em>inputs and outputs</em> that connect them to the outside world. An\nAngular hero detail component with inputs and outputs might look\nlike this:</p>\n<code-example path=\"upgrade-module/src/app/downgrade-io/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nimport { Component, EventEmitter, Input, Output } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{hero.id}}&#x3C;/div>\n    &#x3C;button (click)=\"onDelete()\">Delete&#x3C;/button>\n  `\n})\nexport class HeroDetailComponent {\n  @Input() hero: Hero;\n  @Output() deleted = new EventEmitter&#x3C;Hero>();\n  onDelete() {\n    this.deleted.emit(this.hero);\n  }\n}\n\n\n</code-example>\n<p>These inputs and outputs can be supplied from the AngularJS template, and the\n<code>downgradeComponent()</code> method takes care of wiring them up:</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"usecomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"mainCtrl.hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\">\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<p>Note that even though you are in an AngularJS template, <strong>you're using Angular\nattribute syntax to bind the inputs and outputs</strong>. This is a requirement for downgraded\ncomponents. The expressions themselves are still regular AngularJS expressions.</p>\n<div class=\"callout is-important\">\n<header>\n  Use kebab-case for downgraded component attributes\n</header>\n<p>There's one notable exception to the rule of using Angular attribute syntax\nfor downgraded components. It has to do with input or output names that consist\nof multiple words. In Angular, you would bind these attributes using camelCase:</p>\n<code-example format=\"\">\n  [myHero]=\"hero\"\n</code-example>\n<p>But when using them from AngularJS templates, you must use kebab-case:</p>\n<code-example format=\"\">\n  [my-hero]=\"hero\"\n</code-example>\n</div>\n<p>The <code>$event</code> variable can be used in outputs to gain access to the\nobject that was emitted. In this case it will be the <code>Hero</code> object, because\nthat is what was passed to <code>this.deleted.emit()</code>.</p>\n<p>Since this is an AngularJS template, you can still use other AngularJS\ndirectives on the element, even though it has Angular binding attributes on it.\nFor example, you can easily make multiple copies of the component using <code>ng-repeat</code>:</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"userepeatedcomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"\n               ng-repeat=\"hero in mainCtrl.heroes\">\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<h3 id=\"using-angularjs-component-directives-from-angular-code\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\"><i class=\"material-icons\">link</i></a>Using AngularJS Component Directives from Angular Code</h3>\n<img src=\"generated/images/guide/upgrade/a-to-ajs.png\" alt=\"Using an AngularJS component from Angular code\" class=\"left\" width=\"250\" height=\"44\">\n<p>So, you can write an Angular component and then use it from AngularJS\ncode. This is useful when you start to migrate from lower-level\ncomponents and work your way up. But in some cases it is more convenient\nto do things in the opposite order: To start with higher-level components\nand work your way down. This too can be done using the <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code>.\nYou can <em>upgrade</em> AngularJS component directives and then use them from\nAngular.</p>\n<p>Not all kinds of AngularJS directives can be upgraded. The directive\nreally has to be a <em>component directive</em>, with the characteristics\n<a href=\"guide/upgrade#using-component-directives\">described in the preparation guide above</a>.\nThe safest bet for ensuring compatibility is using the\n<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\">component API</a>\nintroduced in AngularJS 1.5.</p>\n<p>A simple example of an upgradable component is one that just has a template\nand a controller:</p>\n<code-example path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail\" title=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  template: `\n    &#x3C;h2>Windstorm details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>1&#x3C;/div>\n  `,\n  controller: function() {\n  }\n};\n\n</code-example>\n<p>You can <em>upgrade</em> this component to Angular using the <code><a href=\"api/upgrade/static/UpgradeComponent\">UpgradeComponent</a></code> class.\nBy creating a new Angular <strong>directive</strong> that extends <code><a href=\"api/upgrade/static/UpgradeComponent\">UpgradeComponent</a></code> and doing a <code>super</code> call\ninside it's constructor, you have a fully upgraded AngularJS component to be used inside Angular.\nAll that is left is to add it to <code>AppModule</code>'s <code>declarations</code> array.</p>\n<code-example path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail-upgrade\" title=\"hero-detail.component.ts\">\nimport { Directive, ElementRef, Injector, SimpleChanges } from '@angular/core';\nimport { UpgradeComponent } from '@angular/upgrade/static';\n\n@Directive({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends UpgradeComponent {\n  constructor(elementRef: ElementRef, injector: Injector) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example path=\"upgrade-module/src/app/upgrade-static/app.module.ts\" region=\"hero-detail-upgrade\" title=\"app.module.ts\">\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  declarations: [\n    HeroDetailDirective,\n/* . . . */\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>Upgraded components are Angular <strong>directives</strong>, instead of <strong>components</strong>, because Angular\nis unaware that AngularJS will create elements under it. As far as Angular knows, the upgraded\ncomponent is just a directive - a tag - and Angular doesn't have to concern itself with\nit's children.</p>\n</div>\n<p>An upgraded component may also have inputs and outputs, as defined by\nthe scope/controller bindings of the original AngularJS component\ndirective. When you use the component from an Angular template,\nprovide the inputs and outputs using <strong>Angular template syntax</strong>,\nobserving the following rules:</p>\n<table>\n  <tbody><tr>\n    <th>\n    </th>\n    <th>\n      Binding definition\n    </th>\n    <th>\n      Template syntax\n    </th>\n  </tr>\n  <tr>\n    <th>\n      Attribute binding\n    </th>\n    <td>\n<p>      <code>myAttribute: '@myAttribute'</code></p>\n    </td>\n    <td>\n<p>      <code>&#x3C;my-component myAttribute=\"value\"></code></p>\n    </td>\n  </tr>\n  <tr>\n    <th>\n      Expression binding\n    </th>\n    <td>\n<p>      <code>myOutput: '&#x26;myOutput'</code></p>\n    </td>\n    <td>\n<p>      <code>&#x3C;my-component (myOutput)=\"action()\"></code></p>\n    </td>\n  </tr>\n  <tr>\n    <th>\n      One-way binding\n    </th>\n    <td>\n<p>      <code>myValue: '&#x3C;myValue'</code></p>\n    </td>\n    <td>\n<p>      <code>&#x3C;my-component [myValue]=\"anExpression\"></code></p>\n    </td>\n  </tr>\n  <tr>\n    <th>\n      Two-way binding\n    </th>\n    <td>\n<p>      <code>myValue: '=myValue'</code></p>\n    </td>\n    <td>\n<p>      As a two-way binding: <code>&#x3C;my-component [(myValue)]=\"anExpression\"></code>.\nSince most AngularJS two-way bindings actually only need a one-way binding\nin practice, <code>&#x3C;my-component [myValue]=\"anExpression\"></code> is often enough.</p>\n    </td>\n  </tr>\n</tbody></table>\n<p>For example, imagine a hero detail AngularJS component directive\nwith one input and one output:</p>\n<code-example path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\" title=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&#x3C;',\n    deleted: '&#x26;'\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n    &#x3C;button ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n  `,\n  controller: function() {\n    this.onDelete = () => {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p>You can upgrade this component to Angular, annotate inputs and outputs in the upgrade directive,\nand then provide the input and output using Angular template syntax:</p>\n<code-example path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io-upgrade\" title=\"hero-detail.component.ts\">\nimport { Directive, ElementRef, Injector, Input, Output, EventEmitter } from '@angular/core';\nimport { UpgradeComponent } from '@angular/upgrade/static';\nimport { Hero } from '../hero';\n\n@Directive({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends UpgradeComponent {\n  @Input() hero: Hero;\n  @Output() deleted: EventEmitter&#x3C;Hero>;\n\n  constructor(elementRef: ElementRef, injector: Injector) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example path=\"upgrade-module/src/app/upgrade-io/container.component.ts\" title=\"container.component.ts\">\nimport { Component } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'my-container',\n  template: `\n    &#x3C;h1>Tour of Heroes&#x3C;/h1>\n    &#x3C;hero-detail [hero]=\"hero\"\n                 (deleted)=\"heroDeleted($event)\">\n    &#x3C;/hero-detail>\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm');\n  heroDeleted(hero: Hero) {\n    hero.name = 'Ex-' + hero.name;\n  }\n}\n\n\n</code-example>\n<h3 id=\"projecting-angularjs-content-into-angular-components\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\"><i class=\"material-icons\">link</i></a>Projecting AngularJS Content into Angular Components</h3>\n<img src=\"generated/images/guide/upgrade/ajs-to-a-with-projection.png\" alt=\"Projecting AngularJS content into Angular\" class=\"left\" width=\"250\" height=\"48\">\n<p>When you are using a downgraded Angular component from an AngularJS\ntemplate, the need may arise to <em>transclude</em> some content into it. This\nis also possible. While there is no such thing as transclusion in Angular,\nthere is a very similar concept called <em>content projection</em>. The <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code>\nis able to make these two features interoperate.</p>\n<p>Angular components that support content projection make use of an <code>&#x3C;ng-content></code>\ntag within them. Here's an example of such a component:</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-projection/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nimport { Component, Input } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.name}}&#x3C;/h2>\n    &#x3C;div>\n      &#x3C;ng-content>&#x3C;/ng-content>\n    &#x3C;/div>\n  `\n})\nexport class HeroDetailComponent {\n  @Input() hero: Hero;\n}\n\n\n</code-example>\n<p>When using the component from AngularJS, you can supply contents for it. Just\nlike they would be transcluded in AngularJS, they get projected to the location\nof the <code>&#x3C;ng-content></code> tag in Angular:</p>\n<code-example path=\"upgrade-module/src/index-ajs-to-a-projection.html\" region=\"usecomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"mainCtrl.hero\">\n    &#x3C;!-- Everything here will get projected -->\n    &#x3C;p>{{mainCtrl.hero.description}}&#x3C;/p>\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>When AngularJS content gets projected inside an Angular component, it still\nremains in \"AngularJS land\" and is managed by the AngularJS framework.</p>\n</div>\n<h3 id=\"transcluding-angular-content-into-angularjs-component-directives\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\"><i class=\"material-icons\">link</i></a>Transcluding Angular Content into AngularJS Component Directives</h3>\n<img src=\"generated/images/guide/upgrade/a-to-ajs-with-transclusion.png\" alt=\"Projecting Angular content into AngularJS\" class=\"left\" width=\"250\" height=\"48\">\n<p>Just as you can project AngularJS content into Angular components,\nyou can <em>transclude</em> Angular content into AngularJS components, whenever\nyou are using upgraded versions from them.</p>\n<p>When an AngularJS component directive supports transclusion, it may use\nthe <code>ng-transclude</code> directive in its template to mark the transclusion\npoint:</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-transclusion/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '='\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}}&#x3C;/h2>\n    &#x3C;div>\n      &#x3C;ng-transclude>&#x3C;/ng-transclude>\n    &#x3C;/div>\n  `,\n  transclude: true\n};\n\n</code-example>\n<p>If you upgrade this component and use it from Angular, you can populate\nthe component tag with contents that will then get transcluded:</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-transclusion/container.component.ts\" title=\"container.component.ts\">\nimport { Component } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'my-container',\n  template: `\n    &#x3C;hero-detail [hero]=\"hero\">\n      &#x3C;!-- Everything here will get transcluded -->\n      &#x3C;p>{{hero.description}}&#x3C;/p>\n    &#x3C;/hero-detail>\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm', 'Specific powers of controlling winds');\n}\n\n\n</code-example>\n<h3 id=\"making-angularjs-dependencies-injectable-to-angular\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\"><i class=\"material-icons\">link</i></a>Making AngularJS Dependencies Injectable to Angular</h3>\n<p>When running a hybrid app, you may encounter situations where you need to inject\nsome AngularJS dependencies into your Angular code.\nMaybe you have some business logic still in AngularJS services.\nMaybe you want access to AngularJS's built-in services like <code>$location</code> or <code>$timeout</code>.</p>\n<p>In these situations, it is possible to <em>upgrade</em> an AngularJS provider to\nAngular. This makes it possible to then inject it somewhere in Angular\ncode. For example, you might have a service called <code>HeroesService</code> in AngularJS:</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/heroes.service.ts\" title=\"heroes.service.ts\">\nimport { Hero } from '../hero';\n\nexport class HeroesService {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p>You can upgrade the service using a Angular <a href=\"guide/dependency-injection#factory-providers\">factory provider</a>\nthat requests the service from the AngularJS <code>$injector</code>.</p>\n<p>Many developers prefer to declare the factory provider in a separate <code>ajs-upgraded-providers.ts</code> file\nso that they are all together, making it easier to reference them, create new ones and\ndelete them once the upgrade is over.</p>\n<p>It's also recommended to export the <code>heroesServiceFactory</code> function so that Ahead-of-Time\ncompilation can pick it up.</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/ajs-upgraded-providers.ts\" title=\"ajs-upgraded-providers.ts\">\nimport { HeroesService } from './heroes.service';\n\nexport function heroesServiceFactory(i: any) {\n  return i.get('heroes');\n}\n\nexport const heroesServiceProvider = {\n  provide: HeroesService,\n  useFactory: heroesServiceFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/app.module.ts\" region=\"register\" title=\"app.module.ts\">\nimport { heroesServiceProvider } from './ajs-upgraded-providers';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  providers: [\n    heroesServiceProvider\n  ],\n/* . . . */\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p>You can then inject it in Angular using it's class as a type annotation:</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nimport { Component } from '@angular/core';\nimport { HeroesService } from './heroes.service';\nimport { Hero } from '../hero';\n\n@Component({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.id}}: {{hero.name}}&#x3C;/h2>\n  `\n})\nexport class HeroDetailComponent {\n  hero: Hero;\n  constructor(heroes: HeroesService) {\n    this.hero = heroes.get()[0];\n  }\n}\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>In this example you upgraded a service class.\nYou can use a TypeScript type annotation when you inject it. While it doesn't\naffect how the dependency is handled, it enables the benefits of static type\nchecking. This is not required though, and any AngularJS service, factory, or\nprovider can be upgraded.</p>\n</div>\n<h3 id=\"making-angular-dependencies-injectable-to-angularjs\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\"><i class=\"material-icons\">link</i></a>Making Angular Dependencies Injectable to AngularJS</h3>\n<p>In addition to upgrading AngularJS dependencies, you can also <em>downgrade</em>\nAngular dependencies, so that you can use them from AngularJS. This can be\nuseful when you start migrating services to Angular or creating new services\nin Angular while retaining components written in AngularJS.</p>\n<p>For example, you might have an Angular service called <code>Heroes</code>:</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/heroes.ts\" title=\"heroes.ts\">\nimport { Injectable } from '@angular/core';\nimport { Hero } from '../hero';\n\n@Injectable()\nexport class Heroes {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p>Again, as with Angular components, register the provider with the <code><a href=\"api/core/NgModule\">NgModule</a></code> by adding it to the module's <code>providers</code> list.</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"ngmodule\" title=\"app.module.ts\">\nimport { Heroes } from './heroes';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule\n  ],\n  providers: [ Heroes ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p>Now wrap the Angular <code>Heroes</code> in an <em>AngularJS factory function</em> using <code>downgradeInjectable()</code>\nand plug the factory into an AngularJS module.\nThe name of the AngularJS dependency is up to you:</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"register\" title=\"app.module.ts\">\nimport { Heroes } from './heroes';\n/* . . . */\nimport { downgradeInjectable } from '@angular/upgrade/static';\n\nangular.module('heroApp', [])\n  .factory('heroes', downgradeInjectable(Heroes))\n  .component('heroDetail', heroDetailComponent);\n\n</code-example>\n<p>After this, the service is injectable anywhere in AngularJS code:</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nexport const heroDetailComponent = {\n  template: `\n    &#x3C;h2>{{$ctrl.hero.id}}: {{$ctrl.hero.name}}&#x3C;/h2>\n  `,\n  controller: ['heroes', function(heroes: Heroes) {\n    this.hero = heroes.get()[0];\n  }]\n};\n\n\n</code-example>\n<h2 id=\"using-ahead-of-time-compilation-with-hybrid-apps\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-ahead-of-time-compilation-with-hybrid-apps\"><i class=\"material-icons\">link</i></a>Using Ahead-of-time compilation with hybrid apps</h2>\n<p>You can take advantage of Ahead-of-time (AOT) compilation on hybrid apps just like on any other\nAngular application.\nThe setup for an hybrid app is mostly the same as described in\n<a href=\"guide/aot-compiler\">the Ahead-of-time Compilation chapter</a>\nsave for differences in <code>index.html</code> and <code>main-aot.ts</code></p>\n<p>The <code>index.html</code> will likely have script tags loading AngularJS files, so the <code>index.html</code>\nfor AOT must also load those files.\nAn easy way to copy them is by adding each to the <code>copy-dist-files.js</code> file.</p>\n<p>You'll need to use the generated <code>AppModuleFactory</code>, instead of the original <code>AppModule</code> to\nbootstrap the hybrid app:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\" title=\"app/main-aot.ts\">\nimport { platformBrowser } from '@angular/platform-browser';\n\nimport { AppModuleNgFactory } from '../aot/app/app.module.ngfactory';\n\nplatformBrowser().bootstrapModuleFactory(AppModuleNgFactory);\n\n\n</code-example>\n<p>And that's all you need do to get the full benefit of AOT for Angular apps!</p>\n<h2 id=\"phonecat-upgrade-tutorial\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phonecat-upgrade-tutorial\"><i class=\"material-icons\">link</i></a>PhoneCat Upgrade Tutorial</h2>\n<p>In this section, you'll learn to prepare and upgrade an application with <code>ngUpgrade</code>.\nThe example app is <a href=\"https://github.com/angular/angular-phonecat\">Angular PhoneCat</a>\nfrom <a href=\"https://docs.angularjs.org/tutorial\">the original AngularJS tutorial</a>,\nwhich is where many of us began our Angular adventures. Now you'll see how to\nbring that application to the brave new world of Angular.</p>\n<p>During the process you'll learn how to apply the steps outlined in the\n<a href=\"guide/upgrade#preparation\">preparation guide</a>. You'll align the application\nwith Angular and also start writing in TypeScript.</p>\n<p>To follow along with the tutorial, clone the\n<a href=\"https://github.com/angular/angular-phonecat\">angular-phonecat</a> repository\nand apply the steps as you go.</p>\n<p>In terms of project structure, this is where the work begins:</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-phonecat\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      bower.json\n    </div>\n    <div class=\"file\">\n      karma.conf.js\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n    <div class=\"file\">\n      app\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        core\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          checkmark\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            checkmark.filter.js\n          </div>\n          <div class=\"file\">\n            checkmark.filter.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          phone\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            phone.module.js\n          </div>\n          <div class=\"file\">\n            phone.service.js\n          </div>\n          <div class=\"file\">\n            phone.service.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          core.module.js\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-detail\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-detail.component.js\n        </div>\n        <div class=\"file\">\n          phone-detail.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-detail.module.js\n        </div>\n        <div class=\"file\">\n          phone-detail.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-list\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-list.component.js\n        </div>\n        <div class=\"file\">\n          phone-list.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-list.module.js\n        </div>\n        <div class=\"file\">\n          phone-list.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        img\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           ...\n        </div>\n      </div>\n      <div class=\"file\">\n        phones\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           ...\n        </div>\n      </div>\n      <div class=\"file\">\n        app.animations.js\n      </div>\n      <div class=\"file\">\n        app.config.js\n      </div>\n      <div class=\"file\">\n        app.css\n      </div>\n      <div class=\"file\">\n        app.module.js\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n    </div>\n    <div class=\"file\">\n      e2e-tests\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        protractor-conf.js\n      </div>\n      <div class=\"file\">\n        scenarios.js\n      </div>\n    </div>\n  </div>\n</div>\n<p>This is actually a pretty good starting point. The code uses the AngularJS 1.5\ncomponent API and the organization follows the\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\">AngularJS Style Guide</a>,\nwhich is an important <a href=\"guide/upgrade#follow-the-angular-styleguide\">preparation step</a> before\na successful upgrade.</p>\n<ul>\n<li>\n<p>Each component, service, and filter is in its own source file, as per the\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\">Rule of 1</a>.</p>\n</li>\n<li>\n<p>The <code>core</code>, <code>phone-detail</code>, and <code>phone-list</code> modules are each in their\nown subdirectory. Those subdirectories contain the JavaScript code as well as\nthe HTML templates that go with each particular feature. This is in line with the\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\">Folders-by-Feature Structure</a>\nand <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\">Modularity</a>\nrules.</p>\n</li>\n<li>\n<p>Unit tests are located side-by-side with application code where they are easily\nfound, as described in the rules for\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\">Organizing Tests</a>.</p>\n</li>\n</ul>\n<h3 id=\"switching-to-typescript\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#switching-to-typescript\"><i class=\"material-icons\">link</i></a>Switching to TypeScript</h3>\n<p>Since you're going to be writing Angular code in TypeScript, it makes sense to\nbring in the TypeScript compiler even before you begin upgrading.</p>\n<p>You'll also start to gradually phase out the Bower package manager in favor\nof NPM, installing all new dependencies using NPM, and eventually removing Bower from the project.</p>\n<p>Begin by installing TypeScript to the project.</p>\n<code-example format=\"\">\n  npm i typescript --save-dev\n</code-example>\n<p>Install type definitions for the existing libraries that\nyou're using but that don't come with prepackaged types: AngularJS and the\nJasmine unit test framework.</p>\n<code-example format=\"\">\n  npm install @types/jasmine @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n</code-example>\n<p>You should also configure the TypeScript compiler with a <code>tsconfig.json</code> in the project directory\nas described in the <a href=\"guide/typescript-configuration\">TypeScript Configuration</a> guide.\nThe <code>tsconfig.json</code> file tells the TypeScript compiler how to turn your TypeScript files\ninto ES5 code bundled into CommonJS modules.</p>\n<p>Finally, you should add some npm scripts in <code>package.json</code> to compile the TypeScript files to\nJavaScript (based on the <code>tsconfig.json</code> configuration file):</p>\n<code-example format=\"\">\n  \"script\": {\n    \"tsc\": \"tsc\",\n    \"tsc:w\": \"tsc -w\",\n    ...\n</code-example>\n<p>Now launch the TypeScript compiler from the command line in watch mode:</p>\n<code-example format=\"\">\n  npm run tsc:w\n</code-example>\n<p>Keep this process running in the background, watching and recompiling as you make changes.</p>\n<p>Next, convert your current JavaScript files into TypeScript. Since\nTypeScript is a super-set of ECMAScript 2015, which in turn is a super-set\nof ECMAScript 5, you can simply switch the file extensions from <code>.js</code> to <code>.ts</code>\nand everything will work just like it did before. As the TypeScript compiler\nruns, it emits the corresponding <code>.js</code> file for every <code>.ts</code> file and the\ncompiled JavaScript is what actually gets executed. If you start\nthe project HTTP server with <code>npm start</code>, you should see the fully functional\napplication in your browser.</p>\n<p>Now that you have TypeScript though, you can start benefiting from some of its\nfeatures. There's a lot of value the language can provide to AngularJS applications.</p>\n<p>For one thing, TypeScript is a superset of ES2015. Any app that has previously\nbeen written in ES5 - like the PhoneCat example has - can with TypeScript\nstart incorporating all of the JavaScript features that are new to ES2015.\nThese include things like <code>let</code>s and <code>const</code>s, arrow functions, default function\nparameters, and destructuring assignments.</p>\n<p>Another thing you can do is start adding <em>type safety</em> to your code. This has\nactually partially already happened because of the AngularJS typings you installed.\nTypeScript are checking that you are calling AngularJS APIs correctly when you do\nthings like register components to Angular modules.</p>\n<p>But you can also start adding <em>type annotations</em> to get even more\nout of TypeScript's type system. For instance, you can annotate the checkmark\nfilter so that it explicitly expects booleans as arguments. This makes it clearer\nwhat the filter is supposed to do.</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/core/checkmark/checkmark.filter.ts\" title=\"app/core/checkmark/checkmark.filter.ts\">\nangular.\n  module('core').\n  filter('checkmark', function() {\n    return function(input: boolean) {\n      return input ? '\\u2713' : '\\u2718';\n    };\n  });\n\n\n</code-example>\n<p>In the <code>Phone</code> service, you can explicitly annotate the <code>$resource</code> service dependency\nas an <code>angular.resource.IResourceService</code> - a type defined by the AngularJS typings.</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/core/phone/phone.service.ts\" title=\"app/core/phone/phone.service.ts\">\nangular.\n  module('core.phone').\n  factory('Phone', ['$resource',\n    function($resource: angular.resource.IResourceService) {\n      return $resource('phones/:phoneId.json', {}, {\n        query: {\n          method: 'GET',\n          params: {phoneId: 'phones'},\n          isArray: true\n        }\n      });\n    }\n  ]);\n\n\n</code-example>\n<p>You can apply the same trick to the application's route configuration file in <code>app.config.ts</code>,\nwhere you are using the location and route services. By annotating them accordingly TypeScript\ncan verify you're calling their APIs with the correct kinds of arguments.</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/app.config.ts\" title=\"app/app.config.ts\">\nangular.\n  module('phonecatApp').\n  config(['$locationProvider', '$routeProvider',\n    function config($locationProvider: angular.ILocationProvider,\n                    $routeProvider: angular.route.IRouteProvider) {\n      $locationProvider.hashPrefix('!');\n\n      $routeProvider.\n        when('/phones', {\n          template: '&#x3C;phone-list>&#x3C;/phone-list>'\n        }).\n        when('/phones/:phoneId', {\n          template: '&#x3C;phone-detail>&#x3C;/phone-detail>'\n        }).\n        otherwise('/phones');\n    }\n  ]);\n\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>The <a href=\"https://www.npmjs.com/package/@types/angular\">AngularJS 1.x type definitions</a>\nyou installed are not officially maintained by the Angular team,\nbut are quite comprehensive. It is possible to make an AngularJS 1.x application\nfully type-annotated with the help of these definitions.</p>\n<p>If this is something you wanted to do, it would be a good idea to enable\nthe <code>noImplicitAny</code> configuration option in <code>tsconfig.json</code>. This would\ncause the TypeScript compiler to display a warning when there's any code that\ndoes not yet have type annotations. You could use it as a guide to inform\nus about how close you are to having a fully annotated project.</p>\n</div>\n<p>Another TypeScript feature you can make use of is <em>classes</em>. In particular, you\ncan turn component controllers into classes. That way they'll be a step\ncloser to becoming Angular component classes, which will make life\neasier once you upgrade.</p>\n<p>AngularJS expects controllers to be constructor functions. That's exactly what\nES2015/TypeScript classes are under the hood, so that means you can just plug in a\nclass as a component controller and AngularJS will happily use it.</p>\n<p>Here's what the new class for the phone list component controller looks like:</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-list/phone-list.component.ts\" title=\"app/phone-list/phone-list.component.ts\">\nclass PhoneListController {\n  phones: any[];\n  orderProp: string;\n  query: string;\n\n  static $inject = ['Phone'];\n  constructor(Phone: any) {\n    this.phones = Phone.query();\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<p>What was previously done in the controller function is now done in the class\nconstructor function. The dependency injection annotations are attached\nto the class using a static property <code>$inject</code>. At runtime this becomes the\n<code>PhoneListController.$inject</code> property.</p>\n<p>The class additionally declares three members: The array of phones, the name of\nthe current sort key, and the search query. These are all things you have already\nbeen attaching to the controller but that weren't explicitly declared anywhere.\nThe last one of these isn't actually used in the TypeScript code since it's only\nreferred to in the template, but for the sake of clarity you should define all of the\ncontroller members.</p>\n<p>In the Phone detail controller, you'll have two members: One for the phone\nthat the user is looking at and another for the URL of the currently displayed image:</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.ts\" title=\"app/phone-detail/phone-detail.component.ts\">\nclass PhoneDetailController {\n  phone: any;\n  mainImageUrl: string;\n\n  static $inject = ['$routeParams', 'Phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, Phone: any) {\n    let phoneId = $routeParams['phoneId'];\n    this.phone = Phone.get({phoneId}, (phone: any) => {\n      this.setImage(phone.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p>This makes the controller code look a lot more like Angular already. You're\nall set to actually introduce Angular into the project.</p>\n<p>If you had any AngularJS services in the project, those would also be\na good candidate for converting to classes, since like controllers,\nthey're also constructor functions. But you only have the <code>Phone</code> factory\nin this project, and that's a bit special since it's an <code>ngResource</code>\nfactory. So you won't be doing anything to it in the preparation stage.\nYou'll instead turn it directly into an Angular service.</p>\n<h3 id=\"installing-angular\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#installing-angular\"><i class=\"material-icons\">link</i></a>Installing Angular</h3>\n<p>Having completed the preparation work, get going with the Angular\nupgrade of PhoneCat. You'll do this incrementally with the help of\n<a href=\"guide/upgrade#upgrading-with-ngupgrade\">ngUpgrade</a> that comes with Angular.\nBy the time you're done, you'll be able to remove AngularJS from the project\ncompletely, but the key is to do this piece by piece without breaking the application.</p>\n<div class=\"alert is-important\">\n<p>The project also contains some animations.\nYou won't upgrade them in this version of the guide.\nTurn to the <a href=\"guide/animations\">Angular animations</a> guide to learn about that.</p>\n</div>\n<p>Install Angular into the project, along with the SystemJS module loader.\nTake a look at the results of the <a href=\"guide/setup\">Setup</a> instructions\nand get the following configurations from there:</p>\n<ul>\n<li>Add Angular and the other new dependencies to <code>package.json</code></li>\n<li>The SystemJS configuration file <code>systemjs.config.js</code> to the project root directory.</li>\n</ul>\n<p>Once these are done, run:</p>\n<code-example format=\"\">\n  npm install\n</code-example>\n<p>Soon you can load Angular dependencies into the application via <code>index.html</code>,\nbut first you need to do some directory path adjustments.\nYou'll need to load files from <code>node_modules</code> and the project root instead of\nfrom the <code>/app</code> directory as you've been doing to this point.</p>\n<p>Move the <code>app/index.html</code> file to the project root directory. Then change the\ndevelopment server root path in <code>package.json</code> to also point to the project root\ninstead of <code>app</code>:</p>\n<code-example format=\"\">\n  \"start\": \"http-server ./ -a localhost -p 8000 -c-1\",\n</code-example>\n<p>Now you're able to serve everything from the project root to the web browser. But you do <em>not</em>\nwant to have to change all the image and data paths used in the application code to match\nthe development setup. For that reason, you'll add a <code>&#x3C;base></code> tag to <code>index.html</code>, which will\ncause relative URLs to be resolved back to the <code>/app</code> directory:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"base\" title=\"index.html\">\n&#x3C;base href=\"/app/\">\n\n</code-example>\n<p>Now you can load Angular via SystemJS. You'll add the Angular polyfills and the\nSystemJS config to the end of the <code>&#x3C;head></code> section, and then you'll use <code>System.import</code>\nto load the actual application:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"angular\" title=\"index.html\">\n&#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n&#x3C;script src=\"/node_modules/zone.js/dist/zone.js\">&#x3C;/script>\n&#x3C;script src=\"/node_modules/systemjs/dist/system.src.js\">&#x3C;/script>\n&#x3C;script src=\"/systemjs.config.js\">&#x3C;/script>\n&#x3C;script>\n  System.import('/app');\n&#x3C;/script>\n\n</code-example>\n<p>You also need to make a couple of adjustments\nto the <code>systemjs.config.js</code> file installed during <a href=\"guide/setup\">setup</a>.</p>\n<p>Point the browser to the project root when loading things through SystemJS,\ninstead of using the  <code>&#x3C;base></code> URL.</p>\n<p>Install the <code>upgrade</code> package via <code>npm install @angular/upgrade --save</code>\nand add a mapping for the <code>@angular/upgrade/static</code> package.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/systemjs.config.1.js\" region=\"paths\" title=\"systemjs.config.js\">\n  System.config({\n    paths: {\n      // paths serve as alias\n      'npm:': '/node_modules/'\n    },\n    map: {\n      'ng-loader': '../src/systemjs-angular-loader.js',\n      app: '/app',\n/* . . . */\n      '@angular/upgrade/static': 'npm:@angular/upgrade/bundles/upgrade-static.umd.js',\n/* . . . */\n    },\n\n</code-example>\n<h3 id=\"creating-the-appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#creating-the-appmodule\"><i class=\"material-icons\">link</i></a>Creating the <em>AppModule</em></h3>\n<p>Now create the root <code><a href=\"api/core/NgModule\">NgModule</a></code> class called <code>AppModule</code>.\nThere is already a file named <code>app.module.ts</code> that holds the AngularJS module.\nRename it to <code>app.module.ajs.ts</code> and update the corresponding script name in the <code>index.html</code> as well.\nThe file contents remain:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ajs.ts\" title=\"app.module.ajs.ts\">\n'use strict';\n\n// Define the `phonecatApp` AngularJS module\nangular.module('phonecatApp', [\n  'ngAnimate',\n  'ngRoute',\n  'core',\n  'phoneDetail',\n  'phoneList',\n]);\n\n\n</code-example>\n<p>Now create a new <code>app.module.ts</code> with the minimum <code><a href=\"api/core/NgModule\">NgModule</a></code> class:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"bare\" title=\"app.module.ts\">\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n  ],\n})\nexport class AppModule {\n}\n\n</code-example>\n<h3 id=\"bootstrapping-a-hybrid-phonecat\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-a-hybrid-phonecat\"><i class=\"material-icons\">link</i></a>Bootstrapping a hybrid PhoneCat</h3>\n<p>Next, you'll bootstrap the application as a <em>hybrid application</em>\nthat supports both AngularJS and Angular components. After that,\nyou can start converting the individual pieces to Angular.</p>\n<p>The application is currently bootstrapped using the AngularJS <code>ng-app</code> directive\nattached to the <code>&#x3C;html></code> element of the host page. This will no longer work in the hybrid\napp. Switch to the <a href=\"guide/upgrade#bootstrapping-hybrid-applications\">ngUpgrade bootstrap</a> method\ninstead.</p>\n<p>First, remove the <code>ng-app</code> attribute from <code>index.html</code>.\nThen import <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> in the <code>AppModule</code>, and override it's <code>ngDoBootstrap</code> method:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"upgrademodule\" title=\"app/app.module.ts\">\nimport { UpgradeModule } from '@angular/upgrade/static';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n  ],\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>Note that you are bootstrapping the AngularJS module from inside <code>ngDoBootstrap</code>.\nThe arguments are the same as you would pass to <code>angular.bootstrap</code> if you were manually\nbootstrapping AngularJS: the root element of the application; and an array of the\nAngularJS 1.x modules that you want to load.</p>\n<p>Finally, bootstrap the <code>AppModule</code> in <code>src/main.ts</code>.\nThis file has been configured as the application entrypoint in <code>systemjs.config.js</code>,\nso it is already being loaded by the browser.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main.ts\" region=\"bootstrap\" title=\"app/main.ts\">\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app.module';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n</code-example>\n<p>Now you're running both AngularJS and Angular at the same time. That's pretty\nexciting! You're not running any actual Angular components yet. That's next.</p>\n<div class=\"l-sub-section\">\n<h4 id=\"why-declare-angular-as-angulariangularstatic\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#why-declare-angular-as-angulariangularstatic\"><i class=\"material-icons\">link</i></a>Why declare <em>angular</em> as <em>angular.IAngularStatic</em>?</h4>\n<p><code>@types/angular</code> is declared as a UMD module, and due to the way\n<a href=\"https://github.com/Microsoft/TypeScript/wiki/What&#x27;s-new-in-TypeScript#support-for-umd-module-definitions\">UMD typings</a>\nwork, once you have an ES6 <code>import</code> statement in a file all UMD typed modules must also be\nimported via <code>import</code> statements instead of being globally available.</p>\n<p>AngularJS is currently loaded by a script tag in <code>index.html</code>, which means that the whole app\nhas access to it as a global and uses the same instance of the <code>angular</code> variable.\nIf you used <code>import * as angular from 'angular'</code> instead, you'd also have to\nload every file in the AngularJS app to use ES2015 modules in order to ensure AngularJS was being\nloaded correctly.</p>\n<p>This is a considerable effort and it often isn't worth it, especially since you are in the\nprocess of moving your code to Angular.\nInstead, declare <code>angular</code> as <code>angular.IAngularStatic</code> to indicate it is a global variable\nand still have full typing support.</p>\n</div>\n<h3 id=\"upgrading-the-phone-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-the-phone-service\"><i class=\"material-icons\">link</i></a>Upgrading the Phone service</h3>\n<p>The first piece you'll port over to Angular is the <code>Phone</code> service, which\nresides in <code>app/core/phone/phone.service.ts</code> and makes it possible for components\nto load phone information from the server. Right now it's implemented with\nngResource and you're using it for two things:</p>\n<ul>\n<li>For loading the list of all phones into the phone list component.</li>\n<li>For loading the details of a single phone into the phone detail component.</li>\n</ul>\n<p>You can replace this implementation with an Angular service class, while\nkeeping the controllers in AngularJS land.</p>\n<p>In the new version, you import the Angular HTTP module and call its <code><a href=\"api/http/Http\">Http</a></code> service instead of <code>ngResource</code>.</p>\n<p>Re-open the <code>app.module.ts</code> file, import and add <code><a href=\"api/http/HttpModule\">HttpModule</a></code> to the <code>imports</code> array of the <code>AppModule</code>:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"httpmodule\" title=\"app.module.ts\">\nimport { HttpModule } from '@angular/http';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n    HttpModule,\n  ],\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>Now you're ready to upgrade the Phone service itself. Replace the ngResource-based\nservice in <code>phone.service.ts</code> with a TypeScript class decorated as <code>@Injectable</code>:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"classdef\" title=\"app/core/phone/phone.service.ts (skeleton)\" linenums=\"false\">\n@Injectable()\nexport class Phone {\n/* . . . */\n}\n\n</code-example>\n<p>The <code>@Injectable</code> decorator will attach some dependency injection metadata\nto the class, letting Angular know about its dependencies. As described\nby the <a href=\"guide/dependency-injection\">Dependency Injection Guide</a>,\nthis is a marker decorator you need to use for classes that have no other\nAngular decorators but still need to have their dependencies injected.</p>\n<p>In its constructor the class expects to get the <code><a href=\"api/http/Http\">Http</a></code> service. It will\nbe injected to it and it is stored as a private field. The service is then\nused in the two instance methods, one of which loads the list of all phones,\nand the other loads the details of a specified phone:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"fullclass\" title=\"app/core/phone/phone.service.ts\">\n@Injectable()\nexport class Phone {\n  constructor(private http: Http) { }\n  query(): Observable&#x3C;PhoneData[]> {\n    return this.http.get(`phones/phones.json`)\n      .map((res: Response) => res.json());\n  }\n  get(id: string): Observable&#x3C;PhoneData> {\n    return this.http.get(`phones/${id}.json`)\n      .map((res: Response) => res.json());\n  }\n}\n\n</code-example>\n<p>The methods now return Observables of type <code>PhoneData</code> and <code>PhoneData[]</code>. This is\na type you don't have yet. Add a simple interface for it:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"phonedata-interface\" title=\"app/core/phone/phone.service.ts (interface)\" linenums=\"false\">\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n</code-example>\n<p><code>@angular/upgrade/static</code> has a <code><a href=\"api/upgrade/static/downgradeInjectable\">downgradeInjectable</a></code> method for the purpose of making\nAngular services available to AngularJS code. Use it to plug in the <code>Phone</code> service:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"downgrade-injectable\" title=\"app/core/phone/phone.service.ts (downgrade)\" linenums=\"false\">\ndeclare var angular: angular.IAngularStatic;\nimport { downgradeInjectable } from '@angular/upgrade/static';\n/* . . . */\n@Injectable()\nexport class Phone {\n/* . . . */\n}\n\nangular.module('core.phone')\n  .factory('phone', downgradeInjectable(Phone));\n\n</code-example>\n<p>Here's the full, final code for the service:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" title=\"app/core/phone/phone.service.ts\">\nimport { Injectable } from '@angular/core';\nimport { Http, Response } from '@angular/http';\nimport { Observable } from 'rxjs/Rx';\n\ndeclare var angular: angular.IAngularStatic;\nimport { downgradeInjectable } from '@angular/upgrade/static';\n\nimport 'rxjs/add/operator/map';\n\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n@Injectable()\nexport class Phone {\n  constructor(private http: Http) { }\n  query(): Observable&#x3C;PhoneData[]> {\n    return this.http.get(`phones/phones.json`)\n      .map((res: Response) => res.json());\n  }\n  get(id: string): Observable&#x3C;PhoneData> {\n    return this.http.get(`phones/${id}.json`)\n      .map((res: Response) => res.json());\n  }\n}\n\nangular.module('core.phone')\n  .factory('phone', downgradeInjectable(Phone));\n\n\n</code-example>\n<p>Notice that you're importing the <code>map</code> operator of the RxJS <code>Observable</code> separately.\nDo this for every RxJS operator.</p>\n<p>The new <code>Phone</code> service has the same features as the original, <code>ngResource</code>-based service.\nBecause it's an Angular service, you register it with the <code><a href=\"api/core/NgModule\">NgModule</a></code> providers:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phone\" title=\"app.module.ts\">\nimport { Phone } from './core/phone/phone.service';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n    HttpModule,\n  ],\n  providers: [\n    Phone,\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>Now that you are loading <code>phone.service.ts</code> through an import that is resolved\nby SystemJS, you should <strong>remove the &#x3C;script> tag</strong> for the service from <code>index.html</code>.\nThis is something you'll do to all components as you upgrade them. Simultaneously\nwith the AngularJS to Angular upgrade you're also migrating code from scripts to modules.</p>\n<p>At this point, you can switch the two components to use the new service\ninstead of the old one.  While you <code>$inject</code> it as the downgraded <code>phone</code> factory,\nit's really an instance of the <code>Phone</code> class and you annotate its type accordingly:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ajs.ts\" title=\"app/phone-list/phone-list.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneListController {\n  phones: PhoneData[];\n  orderProp: string;\n\n  static $inject = ['phone'];\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones => {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'app/phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ajs.ts\" title=\"app/phone-detail/phone-detail.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneDetailController {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  static $inject = ['$routeParams', 'phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, phone: Phone) {\n    let phoneId = $routeParams['phoneId'];\n    phone.get(phoneId).subscribe(data => {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p>Now there are two AngularJS components using an Angular service!\nThe components don't need to be aware of this, though the fact that the\nservice returns Observables and not Promises is a bit of a giveaway.\nIn any case, what you've achieved is a migration of a service to Angular\nwithout having to yet migrate the components that use it.</p>\n<div class=\"alert is-helpful\">\n<p>You could use the <code>toPromise</code> method of <code>Observable</code> to turn those\nObservables into Promises in the service. In many cases that reduce\nthe number of changes to the component controllers.</p>\n</div>\n<h3 id=\"upgrading-components\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-components\"><i class=\"material-icons\">link</i></a>Upgrading Components</h3>\n<p>Upgrade the AngularJS components to Angular components next.\nDo it one component at a time while still keeping the application in hybrid mode.\nAs you make these conversions, you'll also define your first Angular <em>pipes</em>.</p>\n<p>Look at the phone list component first. Right now it contains a TypeScript\ncontroller class and a component definition object. You can morph this into\nan Angular component by just renaming the controller class and turning the\nAngularJS component definition object into an Angular <code>@Component</code> decorator.\nYou can then also remove the static <code>$inject</code> property from the class:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"initialclass\" title=\"app/phone-list/phone-list.component.ts\">\nimport { Component } from '@angular/core';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@Component({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  phones: PhoneData[];\n  query: string;\n  orderProp: string;\n\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones => {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n/* . . . */\n}\n\n</code-example>\n<p>The <code>selector</code> attribute is a CSS selector that defines where on the page the component\nshould go. In AngularJS you do matching based on component names, but in Angular you\nhave these explicit selectors. This one will match elements with the name <code>phone-list</code>,\njust like the AngularJS version did.</p>\n<p>Now convert the template of this component into Angular syntax.\nThe search controls replace the AngularJS <code>$ctrl</code> expressions\nwith Angular's two-way <code>[(ngModel)]</code> binding syntax:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"controls\" title=\"app/phone-list/phone-list.template.html (search controls)\" linenums=\"false\">\n&#x3C;p>\n  Search:\n  &#x3C;input [(ngModel)]=\"query\" />\n&#x3C;/p>\n\n&#x3C;p>\n  Sort by:\n  &#x3C;select [(ngModel)]=\"orderProp\">\n    &#x3C;option value=\"name\">Alphabetical&#x3C;/option>\n    &#x3C;option value=\"age\">Newest&#x3C;/option>\n  &#x3C;/select>\n&#x3C;/p>\n\n</code-example>\n<p>Replace the list's <code>ng-repeat</code> with an <code>*ngFor</code> as\n<a href=\"guide/template-syntax#directives\">described in the Template Syntax page</a>.\nReplace the image tag's <code>ng-src</code> with a binding to the native <code>src</code> property.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"list\" title=\"app/phone-list/phone-list.template.html (phones)\" linenums=\"false\">\n&#x3C;ul class=\"phones\">\n  &#x3C;li *ngFor=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\">\n    &#x3C;a href=\"/#!/phones/{{phone.id}}\" class=\"thumb\">\n      &#x3C;img [src]=\"phone.imageUrl\" [alt]=\"phone.name\" />\n    &#x3C;/a>\n    &#x3C;a href=\"/#!/phones/{{phone.id}}\" class=\"name\">{{phone.name}}&#x3C;/a>\n    &#x3C;p>{{phone.snippet}}&#x3C;/p>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<h4 id=\"no-angular-filter-or-orderby-filters\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#no-angular-filter-or-orderby-filters\"><i class=\"material-icons\">link</i></a>No Angular <em>filter</em> or <em>orderBy</em> filters</h4>\n<p>The built-in AngularJS <code>filter</code> and <code>orderBy</code> filters do not exist in Angular,\nso you need to do the filtering and sorting yourself.</p>\n<p>You replaced the <code>filter</code> and <code>orderBy</code> filters with bindings to the <code>getPhones()</code> controller method,\nwhich implements the filtering and ordering logic inside the component itself.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"getphones\" title=\"app/phone-list/phone-list.component.ts\">\ngetPhones(): PhoneData[] {\n  return this.sortPhones(this.filterPhones(this.phones));\n}\n\nprivate filterPhones(phones: PhoneData[]) {\n  if (phones &#x26;&#x26; this.query) {\n    return phones.filter(phone => {\n      let name = phone.name.toLowerCase();\n      let snippet = phone.snippet.toLowerCase();\n      return name.indexOf(this.query) >= 0 || snippet.indexOf(this.query) >= 0;\n    });\n  }\n  return phones;\n}\n\nprivate sortPhones(phones: PhoneData[]) {\n  if (phones &#x26;&#x26; this.orderProp) {\n    return phones\n      .slice(0) // Make a copy\n      .sort((a, b) => {\n        if (a[this.orderProp] &#x3C; b[this.orderProp]) {\n          return -1;\n        } else if ([b[this.orderProp] &#x3C; a[this.orderProp]]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n  }\n  return phones;\n}\n\n</code-example>\n<p>Now you need to downgrade the Angular component so you can use it in AngularJS.\nInstead of registering a component, you register a <code>phoneList</code> <em>directive</em>,\na downgraded version of the Angular component.</p>\n<p>The <code>as angular.IDirectiveFactory</code> cast tells the TypeScript compiler\nthat the return value of the <code><a href=\"api/upgrade/static/downgradeComponent\">downgradeComponent</a></code> method is a directive factory.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"downgrade-component\" title=\"app/phone-list/phone-list.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { downgradeComponent } from '@angular/upgrade/static';\n\n/* . . . */\n@Component({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n/* . . . */\n}\n\nangular.module('phoneList')\n  .directive(\n    'phoneList',\n    downgradeComponent({component: PhoneListComponent}) as angular.IDirectiveFactory\n  );\n\n</code-example>\n<p>The new <code>PhoneListComponent</code> uses the Angular <code>ngModel</code> directive, located in the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code>.\nAdd the <code><a href=\"api/forms/FormsModule\">FormsModule</a></code> to <code><a href=\"api/core/NgModule\">NgModule</a></code> imports, declare the new <code>PhoneListComponent</code> and\nfinally add it to <code>entryComponents</code> since you downgraded it:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonelist\" title=\"app.module.ts\">\nimport { FormsModule } from '@angular/forms';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n    HttpModule,\n    FormsModule,\n  ],\n  declarations: [\n    PhoneListComponent,\n  ],\n  entryComponents: [\n    PhoneListComponent,\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>Remove the &#x3C;script> tag for the phone list component from <code>index.html</code>.</p>\n<p>Now set the remaining <code>phone-detail.component.ts</code> as follows:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ts\" title=\"app/phone-detail/phone-detail.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { downgradeComponent } from '@angular/upgrade/static';\n\nimport { Component } from '@angular/core';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { RouteParams } from '../ajs-upgraded-providers';\n\n@Component({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html',\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(routeParams: RouteParams, phone: Phone) {\n    phone.get(routeParams['phoneId']).subscribe(phone => {\n      this.phone = phone;\n      this.setImage(phone.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.module('phoneDetail')\n  .directive(\n    'phoneDetail',\n    downgradeComponent({component: PhoneDetailComponent}) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<p>This is similar to the phone list component.\nThe new wrinkle is the <code>RouteParams</code> type annotation that identifies the <code>routeParams</code> dependency.</p>\n<p>The AngularJS injector has an AngularJS router dependency called <code>$routeParams</code>,\nwhich was injected into <code>PhoneDetails</code> when it was still an AngularJS controller.\nYou intend to inject it into the new <code>PhoneDetailsComponent</code>.</p>\n<p>Unfortunately, AngularJS dependencies are not automatically available to Angular components.\nYou must upgrade this service via a <a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">factory provider</a>\nto make <code>$routeParams</code> an Angular injectable.\nDo that in a new file called <code>ajs-upgraded-providers.ts</code> and import it in <code>app.module.ts</code>:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/ajs-upgraded-providers.ts\" title=\"app/ajs-upgraded-providers.ts\">\nexport abstract class RouteParams {\n  [key: string]: string;\n}\n\nexport function routeParamsFactory(i: any) {\n  return i.get('$routeParams');\n}\n\nexport const routeParamsProvider = {\n  provide: RouteParams,\n  useFactory: routeParamsFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"routeparams\" title=\"app/app.module.ts ($routeParams)\" linenums=\"false\">\nimport { routeParamsProvider } from './ajs-upgraded-providers';\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n\n</code-example>\n<p>Convert the phone detail component template into Angular syntax as follows:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.template.html\" title=\"app/phone-detail/phone-detail.template.html\">\n&#x3C;div *ngIf=\"phone\">\n  &#x3C;div class=\"phone-images\">\n    &#x3C;img [src]=\"img\" class=\"phone\"\n        [ngClass]=\"{'selected': img === mainImageUrl}\"\n        *ngFor=\"let img of phone.images\" />\n  &#x3C;/div>\n\n  &#x3C;h1>{{phone.name}}&#x3C;/h1>\n\n  &#x3C;p>{{phone.description}}&#x3C;/p>\n\n  &#x3C;ul class=\"phone-thumbs\">\n    &#x3C;li *ngFor=\"let img of phone.images\">\n      &#x3C;img [src]=\"img\" (click)=\"setImage(img)\" />\n    &#x3C;/li>\n  &#x3C;/ul>\n\n  &#x3C;ul class=\"specs\">\n    &#x3C;li>\n      &#x3C;span>Availability and Networks&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Availability&#x3C;/dt>\n        &#x3C;dd *ngFor=\"let availability of phone.availability\">{{availability}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Battery&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Type&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.type}}&#x3C;/dd>\n        &#x3C;dt>Talk Time&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.talkTime}}&#x3C;/dd>\n        &#x3C;dt>Standby time (max)&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.standbyTime}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Storage and Memory&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>RAM&#x3C;/dt>\n        &#x3C;dd>{{phone.storage?.ram}}&#x3C;/dd>\n        &#x3C;dt>Internal Storage&#x3C;/dt>\n        &#x3C;dd>{{phone.storage?.flash}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Connectivity&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Network Support&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.cell}}&#x3C;/dd>\n        &#x3C;dt>WiFi&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.wifi}}&#x3C;/dd>\n        &#x3C;dt>Bluetooth&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.bluetooth}}&#x3C;/dd>\n        &#x3C;dt>Infrared&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.infrared | checkmark}}&#x3C;/dd>\n        &#x3C;dt>GPS&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.gps | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Android&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>OS Version&#x3C;/dt>\n        &#x3C;dd>{{phone.android?.os}}&#x3C;/dd>\n        &#x3C;dt>UI&#x3C;/dt>\n        &#x3C;dd>{{phone.android?.ui}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Size and Weight&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Dimensions&#x3C;/dt>\n        &#x3C;dd *ngFor=\"let dim of phone.sizeAndWeight?.dimensions\">{{dim}}&#x3C;/dd>\n        &#x3C;dt>Weight&#x3C;/dt>\n        &#x3C;dd>{{phone.sizeAndWeight?.weight}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Display&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Screen size&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.screenSize}}&#x3C;/dd>\n        &#x3C;dt>Screen resolution&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.screenResolution}}&#x3C;/dd>\n        &#x3C;dt>Touch screen&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.touchScreen | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Hardware&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>CPU&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.cpu}}&#x3C;/dd>\n        &#x3C;dt>USB&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.usb}}&#x3C;/dd>\n        &#x3C;dt>Audio / headphone jack&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.audioJack}}&#x3C;/dd>\n        &#x3C;dt>FM Radio&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.fmRadio | checkmark}}&#x3C;/dd>\n        &#x3C;dt>Accelerometer&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.accelerometer | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Camera&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Primary&#x3C;/dt>\n        &#x3C;dd>{{phone.camera?.primary}}&#x3C;/dd>\n        &#x3C;dt>Features&#x3C;/dt>\n        &#x3C;dd>{{phone.camera?.features?.join(', ')}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Additional Features&#x3C;/span>\n      &#x3C;dd>{{phone.additionalFeatures}}&#x3C;/dd>\n    &#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/div>\n\n\n</code-example>\n<p>There are several notable changes here:</p>\n<ul>\n<li>\n<p>You've removed the <code>$ctrl.</code> prefix from all expressions.</p>\n</li>\n<li>\n<p>You've replaced <code>ng-src</code> with property\nbindings for the standard <code>src</code> property.</p>\n</li>\n<li>\n<p>You're using the property binding syntax around <code>ng-class</code>. Though Angular\ndoes have <a href=\"guide/template-syntax#directives\">a very similar <code>ngClass</code></a>\nas AngularJS does, its value is not magically evaluated as an expression.\nIn Angular, you always specify  in the template when an attribute's value is\na property expression, as opposed to a literal string.</p>\n</li>\n<li>\n<p>You've replaced <code>ng-repeat</code>s with <code>*ngFor</code>s.</p>\n</li>\n<li>\n<p>You've replaced <code>ng-click</code> with an event binding for the standard <code>click</code>.</p>\n</li>\n<li>\n<p>You've wrapped the whole template in an <code>ngIf</code> that causes it only to be\nrendered when there is a phone present. You need this because when the component\nfirst loads, you don't have <code>phone</code> yet and the expressions will refer to a\nnon-existing value. Unlike in AngularJS, Angular expressions do not fail silently\nwhen you try to refer to properties on undefined objects. You need to be explicit\nabout cases where this is expected.</p>\n</li>\n</ul>\n<p>Add <code>PhoneDetailComponent</code> component to the <code><a href=\"api/core/NgModule\">NgModule</a></code> <em>declarations</em> and <em>entryComponents</em>:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonedetail\" title=\"app.module.ts\">\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n    HttpModule,\n    FormsModule,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n  ],\n  entryComponents: [\n    PhoneListComponent,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>You should now also remove the phone detail component &#x3C;script> tag from <code>index.html</code>.</p>\n<h4 id=\"add-the-checkmarkpipe\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-checkmarkpipe\"><i class=\"material-icons\">link</i></a>Add the <em>CheckmarkPipe</em></h4>\n<p>The AngularJS directive had a <code>checkmark</code> <em>filter</em>.\nTurn that into an Angular <strong>pipe</strong>.</p>\n<p>There is no upgrade method to convert filters into pipes.\nYou won't miss it.\nIt's easy to turn the filter function into an equivalent Pipe class.\nThe implementation is the same as before, repackaged in the <code>transform</code> method.\nRename the file to <code>checkmark.pipe.ts</code> to conform with Angular conventions:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.ts\" title=\"app/core/checkmark/checkmark.pipe.ts\" linenums=\"false\">\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({name: 'checkmark'})\nexport class CheckmarkPipe implements PipeTransform {\n  transform(input: boolean) {\n    return input ? '\\u2713' : '\\u2718';\n  }\n}\n\n\n</code-example>\n<p>Now import and declare the newly created pipe and\nremove the filter &#x3C;script> tag from <code>index.html</code>:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"checkmarkpipe\" title=\"app.module.ts\">\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    UpgradeModule,\n    HttpModule,\n    FormsModule,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n    CheckmarkPipe\n  ],\n  entryComponents: [\n    PhoneListComponent,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: UpgradeModule) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<h3 id=\"aot-compile-the-hybrid-app\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#aot-compile-the-hybrid-app\"><i class=\"material-icons\">link</i></a>AOT compile the hybrid app</h3>\n<p>To use AOT with a hybrid app, you have to first set it up like any other Angular application,\nas shown in <a href=\"guide/aot-compiler\">the Ahead-of-time Compilation chapter</a>.</p>\n<p>Then change <code>main-aot.ts</code> to bootstrap the <code>AppComponentFactory</code> that was generated\nby the AOT compiler:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\" title=\"app/main-aot.ts\">\nimport { platformBrowser } from '@angular/platform-browser';\n\nimport { AppModuleNgFactory } from '../aot/app/app.module.ngfactory';\n\nplatformBrowser().bootstrapModuleFactory(AppModuleNgFactory);\n\n\n</code-example>\n<p>You need to load all the AngularJS files you already use in <code>index.html</code> in <code>aot/index.html</code>\nas well:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/aot/index.html\" title=\"aot/index.html\">\n&#x3C;!doctype html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n\n    &#x3C;base href=\"/app/\">\n\n    &#x3C;title>Google Phone Gallery&#x3C;/title>\n    &#x3C;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.animations.css\" />\n\n    &#x3C;script src=\"https://code.jquery.com/jquery-2.2.4.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-animate.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-resource.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-route.js\">&#x3C;/script>\n\n    &#x3C;script src=\"app.module.ajs.js\">&#x3C;/script>\n    &#x3C;script src=\"app.config.js\">&#x3C;/script>\n    &#x3C;script src=\"app.animations.js\">&#x3C;/script>\n    &#x3C;script src=\"core/core.module.js\">&#x3C;/script>\n    &#x3C;script src=\"core/phone/phone.module.js\">&#x3C;/script>\n    &#x3C;script src=\"phone-list/phone-list.module.js\">&#x3C;/script>\n    &#x3C;script src=\"phone-detail/phone-detail.module.js\">&#x3C;/script>\n\n    &#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/zone.js/dist/zone.min.js\">&#x3C;/script>\n\n    &#x3C;script>window.module = 'aot';&#x3C;/script>\n  &#x3C;/head>\n\n  &#x3C;body>\n    &#x3C;div class=\"view-container\">\n      &#x3C;div ng-view class=\"view-frame\">&#x3C;/div>\n    &#x3C;/div>\n  &#x3C;/body>\n  &#x3C;script src=\"/dist/build.js\">&#x3C;/script>\n&#x3C;/html>\n\n\n</code-example>\n<p>These files need to be copied together with the polyfills. The files the application\nneeds at runtime, like the <code>.json</code> phone lists and images, also need to be copied.</p>\n<p>Install <code>fs-extra</code> via <code>npm install fs-extra --save-dev</code> for better file copying, and change\n<code>copy-dist-files.js</code> to the following:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/copy-dist-files.js\" title=\"copy-dist-files.js\">\nvar fsExtra = require('fs-extra');\nvar resources = [\n  // polyfills\n  'node_modules/core-js/client/shim.min.js',\n  'node_modules/zone.js/dist/zone.min.js',\n  // css\n  'app/app.css',\n  'app/app.animations.css',\n  // images and json files\n  'app/img/',\n  'app/phones/',\n  // app files\n  'app/app.module.ajs.js',\n  'app/app.config.js',\n  'app/app.animations.js',\n  'app/core/core.module.js',\n  'app/core/phone/phone.module.js',\n  'app/phone-list/phone-list.module.js',\n  'app/phone-detail/phone-detail.module.js'\n];\nresources.map(function(sourcePath) {\n  var destPath = `aot/${sourcePath}`;\n  fsExtra.copySync(sourcePath, destPath);\n});\n\n\n</code-example>\n<p>And that's all you need to use AOT while upgrading your app!</p>\n<h3 id=\"adding-the-angular-router-and-bootstrap\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#adding-the-angular-router-and-bootstrap\"><i class=\"material-icons\">link</i></a>Adding The Angular Router And Bootstrap</h3>\n<p>At this point, you've replaced all AngularJS application components with\ntheir Angular counterparts, even though you're still serving them from the AngularJS router.</p>\n<h4 id=\"add-the-angular-router\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-angular-router\"><i class=\"material-icons\">link</i></a>Add the Angular router</h4>\n<p>Angular has an <a href=\"guide/router\">all-new router</a>.</p>\n<p>Like all routers, it needs a place in the UI to display routed views.\nFor Angular that's the <code>&#x3C;router-outlet></code> and it belongs in a <em>root component</em>\nat the top of the applications component tree.</p>\n<p>You don't yet have such a root component, because the app is still managed as an AngularJS app.\nCreate a new <code>app.component.ts</code> file with the following <code>AppComponent</code> class:</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app.component.ts\" title=\"app/app.component.ts\">\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'phonecat-app',\n  template: '&#x3C;router-outlet>&#x3C;/router-outlet>'\n})\nexport class AppComponent { }\n\n\n</code-example>\n<p>It has a simple template that only includes the `<router-outlet>.\nThis component just renders the contents of the active route and nothing else.</router-outlet></p>\n<p>The selector tells Angular to plug this root component into the <code>&#x3C;phonecat-app></code>\nelement on the host web page when the application launches.</p>\n<p>Add this <code>&#x3C;phonecat-app></code> element to the <code>index.html</code>.\nIt replaces the old AngularJS <code>ng-view</code> directive:</p>\n<code-example path=\"upgrade-phonecat-3-final/index.html\" region=\"appcomponent\" title=\"index.html (body)\" linenums=\"false\">\n&#x3C;body>\n  &#x3C;phonecat-app>&#x3C;/phonecat-app>\n&#x3C;/body>\n\n</code-example>\n<h4 id=\"create-the-routing-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-the-routing-module\"><i class=\"material-icons\">link</i></a>Create the <em>Routing Module</em></h4>\n<p>A router needs configuration whether it's the AngularJS or Angular or any other router.</p>\n<p>The details of Angular router configuration are best left to the <a href=\"guide/router\">Routing documentation</a>\nwhich recommends that you create a <code><a href=\"api/core/NgModule\">NgModule</a></code> dedicated to router configuration\n(called a <em>Routing Module</em>).</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app-routing.module.ts\" title=\"app/app-routing.module.ts\">\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { APP_BASE_HREF, HashLocationStrategy, LocationStrategy } from '@angular/common';\n\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent }   from './phone-list/phone-list.component';\n\nconst routes: Routes = [\n  { path: '', redirectTo: 'phones', pathMatch: 'full' },\n  { path: 'phones',          component: PhoneListComponent },\n  { path: 'phones/:phoneId', component: PhoneDetailComponent }\n];\n\n@NgModule({\n  imports: [ RouterModule.forRoot(routes) ],\n  exports: [ RouterModule ],\n  providers: [\n    { provide: APP_BASE_HREF, useValue: '!' },\n    { provide: LocationStrategy, useClass: HashLocationStrategy },\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p>This module defines a <code>routes</code> object with two routes to the two phone components\nand a default route for the empty path.\nIt passes the <code>routes</code> to the <code>RouterModule.forRoot</code> method which does the rest.</p>\n<p>A couple of extra providers enable routing with \"hash\" URLs such as <code>#!/phones</code>\ninstead of the default \"push state\" strategy.</p>\n<p>Now update the <code>AppModule</code> to import this <code>AppRoutingModule</code> and also the\ndeclare the root <code>AppComponent</code> as the bootstrap component.\nThat tells Angular that it should bootstrap the app with the <em>root</em> <code>AppComponent</code> and\ninsert it's view into the host web page.</p>\n<p>You must also remove the bootstrap of the AngularJS module from <code>ngDoBootstrap()</code> in <code>app.module.ts</code>\nand the <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> import.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app.module.ts\" title=\"app/app.module.ts\">\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { FormsModule } from '@angular/forms';\nimport { HttpModule } from '@angular/http';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent }     from './app.component';\nimport { CheckmarkPipe }    from './core/checkmark/checkmark.pipe';\nimport { Phone }            from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent }   from './phone-list/phone-list.component';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p>And since you are routing to <code>PhoneListComponent</code> and <code>PhoneDetailComponent</code> directly rather than\nusing a route template with a <code>&#x3C;phone-list></code> or <code>&#x3C;phone-detail></code> tag, you can do away with their\nAngular selectors as well.</p>\n<h4 id=\"generate-links-for-each-phone\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#generate-links-for-each-phone\"><i class=\"material-icons\">link</i></a>Generate links for each phone</h4>\n<p>You no longer have to hardcode the links to phone details in the phone list.\nYou can generate data bindings for each phone's <code>id</code> to the <code>routerLink</code> directive\nand let that directive construct the appropriate URL to the <code>PhoneDetailComponent</code>:</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.template.html\" region=\"list\" title=\"app/phone-list/phone-list.template.html (list with links)\" linenums=\"false\">\n&#x3C;ul class=\"phones\">\n  &#x3C;li *ngFor=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\">\n    &#x3C;a [routerLink]=\"['/phones', phone.id]\" class=\"thumb\">\n      &#x3C;img [src]=\"phone.imageUrl\" [alt]=\"phone.name\" />\n    &#x3C;/a>\n    &#x3C;a [routerLink]=\"['/phones', phone.id]\" class=\"name\">{{phone.name}}&#x3C;/a>\n    &#x3C;p>{{phone.snippet}}&#x3C;/p>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>See the <a href=\"guide/router\">Routing</a> page for details.</p>\n</div><br>\n<h4 id=\"use-route-parameters\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#use-route-parameters\"><i class=\"material-icons\">link</i></a>Use route parameters</h4>\n<p>The Angular router passes route parameters differently.\nCorrect the <code>PhoneDetail</code> component constructor to expect an injected <code><a href=\"api/router/ActivatedRoute\">ActivatedRoute</a></code> object.\nExtract the <code>phoneId</code> from the <code>ActivatedRoute.snapshot.params</code> and fetch the phone data as before:</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.ts\" title=\"app/phone-detail/phone-detail.component.ts\">\nimport { Component }      from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@Component({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html'\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(activatedRoute: ActivatedRoute, phone: Phone) {\n    phone.get(activatedRoute.snapshot.paramMap.get('phoneId'))\n      .subscribe((p: PhoneData) => {\n        this.phone = p;\n        this.setImage(p.images[0]);\n      });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\n\n</code-example>\n<p>You are now running a pure Angular application!</p>\n<h3 id=\"say-goodbye-to-angularjs\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#say-goodbye-to-angularjs\"><i class=\"material-icons\">link</i></a>Say Goodbye to AngularJS</h3>\n<p>It is time to take off the training wheels and let the application begin\nits new life as a pure, shiny Angular app. The remaining tasks all have to\ndo with removing code - which of course is every programmer's favorite task!</p>\n<p>The application is still bootstrapped as a hybrid app.\nThere's no need for that anymore.</p>\n<p>Switch the bootstrap method of the application from the <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> to the Angular way.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/main.ts\" title=\"main.ts\">\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n\n</code-example>\n<p>If you haven't already, remove all references to the <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> from <code>app.module.ts</code>,\nas well as any <a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">factory provider</a>\nfor AngularJS services, and the <code>app/ajs-upgraded-providers.ts</code> file.</p>\n<p>Also remove any <code>downgradeInjectable()</code> or <code>downgradeComponent()</code> you find,\ntogether with the associated AngularJS factory or directive declarations.\nSince you no longer have downgraded components, you no longer list them\nin <code>entryComponents</code>.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app.module.ts\" title=\"app.module.ts\">\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { FormsModule } from '@angular/forms';\nimport { HttpModule } from '@angular/http';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent }     from './app.component';\nimport { CheckmarkPipe }    from './core/checkmark/checkmark.pipe';\nimport { Phone }            from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent }   from './phone-list/phone-list.component';\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpModule,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p>You may also completely remove the following files. They are AngularJS\nmodule configuration files and not needed in Angular:</p>\n<ul>\n<li><code>app/app.module.ajs.ts</code></li>\n<li><code>app/app.config.ts</code></li>\n<li><code>app/core/core.module.ts</code></li>\n<li><code>app/core/phone/phone.module.ts</code></li>\n<li><code>app/phone-detail/phone-detail.module.ts</code></li>\n<li><code>app/phone-list/phone-list.module.ts</code></li>\n</ul>\n<p>The external typings for AngularJS may be uninstalled as well. The only ones\nyou still need are for Jasmine and Angular polyfills.\nThe <code>@angular/upgrade</code> package and it's mapping in <code>systemjs.config.js</code> can also go.</p>\n<code-example format=\"\">\n  npm uninstall @angular/upgrade --save\n  npm uninstall @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n</code-example>\n<p>Finally, from <code>index.html</code>, remove all references to AngularJS scripts and jQuery.\nWhen you're done, this is what it should look like:</p>\n<code-example path=\"upgrade-phonecat-3-final/index.html\" region=\"full\" title=\"index.html\">\n&#x3C;!doctype html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n    &#x3C;base href=\"/app/\">\n    &#x3C;title>Google Phone Gallery&#x3C;/title>\n    &#x3C;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.css\" />\n\n    &#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/zone.js/dist/zone.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/systemjs/dist/system.src.js\">&#x3C;/script>\n    &#x3C;script src=\"/systemjs.config.js\">&#x3C;/script>\n    &#x3C;script>\n      System.import('/app');\n    &#x3C;/script>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;phonecat-app>&#x3C;/phonecat-app>\n  &#x3C;/body>\n&#x3C;/html>\n\n</code-example>\n<p>That is the last you'll see of AngularJS! It has served us well but now\nit's time to say goodbye.</p>\n<h2 id=\"appendix-upgrading-phonecat-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#appendix-upgrading-phonecat-tests\"><i class=\"material-icons\">link</i></a>Appendix: Upgrading PhoneCat Tests</h2>\n<p>Tests can not only be retained through an upgrade process, but they can also be\nused as a valuable safety measure when ensuring that the application does not\nbreak during the upgrade. E2E tests are especially useful for this purpose.</p>\n<h3 id=\"e2e-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#e2e-tests\"><i class=\"material-icons\">link</i></a>E2E Tests</h3>\n<p>The PhoneCat project has both E2E Protractor tests and some Karma unit tests in it.\nOf these two, E2E tests can be dealt with much more easily: By definition,\nE2E tests access the application from the <em>outside</em> by interacting with\nthe various UI elements the app puts on the screen. E2E tests aren't really that\nconcerned with the internal structure of the application components. That\nalso means that, although you modify the project quite a bit during the upgrade, the E2E\ntest suite should keep passing with just minor modifications. You\ndidn't change how the application behaves from the user's point of view.</p>\n<p>During TypeScript conversion, there is nothing to do to keep E2E tests\nworking. But when you change the bootstrap to that of a Hybrid app,\nyou must make a few changes.</p>\n<p>Update the <code>protractor-conf.js</code> to sync with hybrid apps:</p>\n<code-example format=\"\">\n  ng12Hybrid: true\n</code-example>\n<p>When you start to upgrade components and their templates to Angular, you'll make more changes\nbecause the E2E tests have matchers that are specific to AngularJS.\nFor PhoneCat you need to make the following changes in order to make things work with Angular:</p>\n<table>\n  <tbody><tr>\n    <th>\n      Previous code\n    </th>\n    <th>\n      New code\n    </th>\n    <th>\n      Notes\n    </th>\n  </tr>\n  <tr>\n    <td>\n<p>      <code>by.repeater('phone in $ctrl.phones').column('phone.name')</code></p>\n    </td>\n    <td>\n<p>      <code>by.css('.phones .name')</code></p>\n    </td>\n    <td>\n<p>      The repeater matcher relies on AngularJS <code>ng-repeat</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p>      <code>by.repeater('phone in $ctrl.phones')</code></p>\n    </td>\n    <td>\n<p>      <code>by.css('.phones li')</code></p>\n    </td>\n    <td>\n<p>      The repeater matcher relies on AngularJS <code>ng-repeat</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p>      <code>by.model('$ctrl.query')</code></p>\n    </td>\n    <td>\n<p>      <code>by.css('input')</code></p>\n    </td>\n    <td>\n<p>      The model matcher relies on AngularJS <code>ng-model</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p>      <code>by.model('$ctrl.orderProp')</code></p>\n    </td>\n    <td>\n<p>      <code>by.css('select')</code></p>\n    </td>\n    <td>\n<p>      The model matcher relies on AngularJS <code>ng-model</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p>      <code>by.binding('$ctrl.phone.name')</code></p>\n    </td>\n    <td>\n<p>      <code>by.css('h1')</code></p>\n    </td>\n    <td>\n<p>      The binding matcher relies on AngularJS data binding</p>\n    </td>\n  </tr>\n</tbody></table>\n<p>When the bootstrap method is switched from that of <code><a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a></code> to\npure Angular, AngularJS ceases to exist on the page completely.\nAt this point, you need to tell Protractor that it should not be looking for\nan AngularJS app anymore, but instead it should find <em>Angular apps</em> from\nthe page.</p>\n<p>Replace the <code>ng12Hybrid</code> previously added with the following in <code>protractor-conf.js</code>:</p>\n<code-example format=\"\">\n  useAllAngular2AppRoots: true,\n</code-example>\n<p>Also, there are a couple of Protractor API calls in the PhoneCat test code that\nare using the AngularJS <code>$location</code> service under the hood. As that\nservice is no longer present after the upgrade, replace those calls with ones\nthat use WebDriver's generic URL APIs instead. The first of these is\nthe redirection spec:</p>\n<code-example path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"redirect\" title=\"e2e-tests/scenarios.ts\">\nit('should redirect `index.html` to `index.html#!/phones', function() {\n  browser.get('index.html');\n  browser.waitForAngular();\n  browser.getCurrentUrl().then(function(url: string) {\n    expect(url.endsWith('/phones')).toBe(true);\n  });\n});\n\n</code-example>\n<p>And the second is the phone links spec:</p>\n<code-example path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"links\" title=\"e2e-tests/scenarios.ts\">\nit('should render phone specific links', function() {\n  let query = element(by.css('input'));\n  query.sendKeys('nexus');\n  element.all(by.css('.phones li a')).first().click();\n  browser.getCurrentUrl().then(function(url: string) {\n    expect(url.endsWith('/phones/nexus-s')).toBe(true);\n  });\n});\n\n</code-example>\n<h3 id=\"unit-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#unit-tests\"><i class=\"material-icons\">link</i></a>Unit Tests</h3>\n<p>For unit tests, on the other hand, more conversion work is needed. Effectively\nthey need to be <em>upgraded</em> along with the production code.</p>\n<p>During TypeScript conversion no changes are strictly necessary. But it may be\na good idea to convert the unit test code into TypeScript as well.</p>\n<p>For instance, in the phone detail component spec, you can use ES2015\nfeatures like arrow functions and block-scoped variables and benefit from the type\ndefinitions of the AngularJS services you're consuming:</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.spec.ts\" title=\"app/phone-detail/phone-detail.component.spec.ts\">\ndescribe('phoneDetail', () => {\n\n  // Load the module that contains the `phoneDetail` component before each test\n  beforeEach(angular.mock.module('phoneDetail'));\n\n  // Test the controller\n  describe('PhoneDetailController', () => {\n    let $httpBackend: angular.IHttpBackendService;\n    let ctrl: any;\n    let xyzPhoneData = {\n      name: 'phone xyz',\n      images: ['image/url1.png', 'image/url2.png']\n    };\n\n    beforeEach(inject(($componentController: any,\n                       _$httpBackend_: angular.IHttpBackendService,\n                       $routeParams: angular.route.IRouteParamsService) => {\n      $httpBackend = _$httpBackend_;\n      $httpBackend.expectGET('phones/xyz.json').respond(xyzPhoneData);\n\n      $routeParams['phoneId'] = 'xyz';\n\n      ctrl = $componentController('phoneDetail');\n    }));\n\n    it('should fetch the phone details', () => {\n      jasmine.addCustomEqualityTester(angular.equals);\n\n      expect(ctrl.phone).toEqual({});\n\n      $httpBackend.flush();\n      expect(ctrl.phone).toEqual(xyzPhoneData);\n    });\n\n  });\n\n});\n\n\n</code-example>\n<p>Once you start the upgrade process and bring in SystemJS, configuration changes\nare needed for Karma. You need to let SystemJS load all the new Angular code,\nwhich can be done with the following kind of shim file:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma-test-shim.1.js\" title=\"karma-test-shim.js\">\n// /*global jasmine, __karma__, window*/\nError.stackTraceLimit = 0; // \"No stacktrace\"\" is usually best for app testing.\n\n// Uncomment to get full stacktrace output. Sometimes helpful, usually not.\n// Error.stackTraceLimit = Infinity; //\n\njasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n\nvar builtPath = '/base/app/';\n\n__karma__.loaded = function () { };\n\nfunction isJsFile(path) {\n  return path.slice(-3) == '.js';\n}\n\nfunction isSpecFile(path) {\n  return /\\.spec\\.(.*\\.)?js$/.test(path);\n}\n\nfunction isBuiltFile(path) {\n  return isJsFile(path) &#x26;&#x26; (path.substr(0, builtPath.length) == builtPath);\n}\n\nvar allSpecFiles = Object.keys(window.__karma__.files)\n  .filter(isSpecFile)\n  .filter(isBuiltFile);\n\nSystem.config({\n  baseURL: '/base',\n  // Extend usual application package list with test folder\n  packages: { 'testing': { main: 'index.js', defaultExtension: 'js' } },\n\n  // Assume npm: is set in `paths` in systemjs.config\n  // Map the angular testing umd bundles\n  map: {\n    '@angular/core/testing': 'npm:@angular/core/bundles/core-testing.umd.js',\n    '@angular/common/testing': 'npm:@angular/common/bundles/common-testing.umd.js',\n    '@angular/compiler/testing': 'npm:@angular/compiler/bundles/compiler-testing.umd.js',\n    '@angular/platform-browser/testing': 'npm:@angular/platform-browser/bundles/platform-browser-testing.umd.js',\n    '@angular/platform-browser-dynamic/testing': 'npm:@angular/platform-browser-dynamic/bundles/platform-browser-dynamic-testing.umd.js',\n    '@angular/http/testing': 'npm:@angular/http/bundles/http-testing.umd.js',\n    '@angular/router/testing': 'npm:@angular/router/bundles/router-testing.umd.js',\n    '@angular/forms/testing': 'npm:@angular/forms/bundles/forms-testing.umd.js',\n  },\n});\n\nSystem.import('systemjs.config.js')\n  .then(importSystemJsExtras)\n  .then(initTestBed)\n  .then(initTesting);\n\n/** Optional SystemJS configuration extras. Keep going w/o it */\nfunction importSystemJsExtras(){\n  return System.import('systemjs.config.extras.js')\n  .catch(function(reason) {\n    console.log(\n      'Warning: System.import could not load the optional \"systemjs.config.extras.js\". Did you omit it by accident? Continuing without it.'\n    );\n    console.log(reason);\n  });\n}\n\nfunction initTestBed(){\n  return Promise.all([\n    System.import('@angular/core/testing'),\n    System.import('@angular/platform-browser-dynamic/testing')\n  ])\n\n  .then(function (providers) {\n    var coreTesting    = providers[0];\n    var browserTesting = providers[1];\n\n    coreTesting.TestBed.initTestEnvironment(\n      browserTesting.BrowserDynamicTestingModule,\n      browserTesting.platformBrowserDynamicTesting());\n  })\n}\n\n// Import all spec files and start karma\nfunction initTesting () {\n  return Promise.all(\n    allSpecFiles.map(function (moduleName) {\n      return System.import(moduleName);\n    })\n  )\n  .then(__karma__.start, __karma__.error);\n}\n\n\n</code-example>\n<p>The shim first loads the SystemJS configuration, then Angular's test support libraries,\nand then the application's spec files themselves.</p>\n<p>Karma configuration should then be changed so that it uses the application root dir\nas the base directory, instead of <code>app</code>.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"basepath\" title=\"karma.conf.js\">\nbasePath: './',\n\n</code-example>\n<p>Once done, you can load SystemJS and other dependencies, and also switch the configuration\nfor loading application files so that they are <em>not</em> included to the page by Karma. You'll let\nthe shim and SystemJS load them.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"files\" title=\"karma.conf.js\">\n// System.js for module loading\n'node_modules/systemjs/dist/system.src.js',\n\n// Polyfills\n'node_modules/core-js/client/shim.js',\n\n// zone.js\n'node_modules/zone.js/dist/zone.js',\n'node_modules/zone.js/dist/long-stack-trace-zone.js',\n'node_modules/zone.js/dist/proxy.js',\n'node_modules/zone.js/dist/sync-test.js',\n'node_modules/zone.js/dist/jasmine-patch.js',\n'node_modules/zone.js/dist/async-test.js',\n'node_modules/zone.js/dist/fake-async-test.js',\n\n// RxJs.\n{ pattern: 'node_modules/rxjs/**/*.js', included: false, watched: false },\n{ pattern: 'node_modules/rxjs/**/*.js.map', included: false, watched: false },\n\n// Angular itself and the testing library\n{pattern: 'node_modules/@angular/**/*.js', included: false, watched: false},\n{pattern: 'node_modules/@angular/**/*.js.map', included: false, watched: false},\n\n{pattern: 'systemjs.config.js', included: false, watched: false},\n'karma-test-shim.js',\n\n{pattern: 'app/**/*.module.js', included: false, watched: true},\n{pattern: 'app/*!(.module|.spec).js', included: false, watched: true},\n{pattern: 'app/!(bower_components)/**/*!(.module|.spec).js', included: false, watched: true},\n{pattern: 'app/**/*.spec.js', included: false, watched: true},\n\n{pattern: '**/*.html', included: false, watched: true},\n\n</code-example>\n<p>Since the HTML templates of Angular components will be loaded as well, you must help\nKarma out a bit so that it can route them to the right paths:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"html\" title=\"karma.conf.js\">\n// proxied base paths for loading assets\nproxies: {\n  // required for component assets fetched by Angular's compiler\n  \"/phone-detail\": '/base/app/phone-detail',\n  \"/phone-list\": '/base/app/phone-list'\n},\n\n</code-example>\n<p>The unit test files themselves also need to be switched to Angular when their production\ncounterparts are switched. The specs for the checkmark pipe are probably the most straightforward,\nas the pipe has no dependencies:</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.spec.ts\" title=\"app/core/checkmark/checkmark.pipe.spec.ts\">\nimport { CheckmarkPipe } from './checkmark.pipe';\n\ndescribe('CheckmarkPipe', function() {\n\n  it('should convert boolean values to unicode checkmark or cross', function () {\n    const checkmarkPipe = new CheckmarkPipe();\n    expect(checkmarkPipe.transform(true)).toBe('\\u2713');\n    expect(checkmarkPipe.transform(false)).toBe('\\u2718');\n  });\n});\n\n\n</code-example>\n<p>The unit test for the phone service is a bit more involved. You need to switch from the mocked-out\nAngularJS <code>$httpBackend</code> to a mocked-out Angular Http backend.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.spec.ts\" title=\"app/core/phone/phone.service.spec.ts\">\nimport { inject, TestBed } from '@angular/core/testing';\nimport {\n  Http,\n  BaseRequestOptions,\n  ResponseOptions,\n  Response\n} from '@angular/http';\nimport { MockBackend, MockConnection } from '@angular/http/testing';\nimport { Phone, PhoneData } from './phone.service';\n\ndescribe('Phone', function() {\n  let phone: Phone;\n  let phonesData: PhoneData[] = [\n    {name: 'Phone X', snippet: '', images: []},\n    {name: 'Phone Y', snippet: '', images: []},\n    {name: 'Phone Z', snippet: '', images: []}\n  ];\n  let mockBackend: MockBackend;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      providers: [\n        Phone,\n        MockBackend,\n        BaseRequestOptions,\n        { provide: Http,\n          useFactory: (backend: MockBackend, options: BaseRequestOptions) => new Http(backend, options),\n          deps: [MockBackend, BaseRequestOptions]\n        }\n      ]\n    });\n  });\n\n  beforeEach(inject([MockBackend, Phone], (_mockBackend_: MockBackend, _phone_: Phone) => {\n    mockBackend = _mockBackend_;\n    phone = _phone_;\n  }));\n\n  it('should fetch the phones data from `/phones/phones.json`', (done: () => void) => {\n    mockBackend.connections.subscribe((conn: MockConnection) => {\n      conn.mockRespond(new Response(new ResponseOptions({body: JSON.stringify(phonesData)})));\n    });\n    phone.query().subscribe(result => {\n      expect(result).toEqual(phonesData);\n      done();\n    });\n  });\n\n});\n\n\n\n</code-example>\n<p>For the component specs, you can mock out the <code>Phone</code> service itself, and have it provide\ncanned phone data. You use Angular's component unit testing APIs for both components.</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.spec.ts\" title=\"app/phone-detail/phone-detail.component.spec.ts\">\nimport { ActivatedRoute } from '@angular/router';\n\nimport { Observable } from 'rxjs/Rx';\n\nimport { async, TestBed } from '@angular/core/testing';\n\nimport { PhoneDetailComponent } from './phone-detail.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { CheckmarkPipe } from '../core/checkmark/checkmark.pipe';\n\nfunction xyzPhoneData(): PhoneData {\n  return {\n    name: 'phone xyz',\n    snippet: '',\n    images: ['image/url1.png', 'image/url2.png']\n  };\n}\n\nclass MockPhone {\n  get(id: string): Observable&#x3C;PhoneData> {\n    return Observable.of(xyzPhoneData());\n  }\n}\n\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n\ndescribe('PhoneDetailComponent', () => {\n\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: ActivatedRoute, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n  it('should fetch phone detail', () => {\n    const fixture = TestBed.createComponent(PhoneDetailComponent);\n    fixture.detectChanges();\n    let compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain(xyzPhoneData().name);\n  });\n\n});\n\n\n</code-example>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.spec.ts\" title=\"app/phone-list/phone-list.component.spec.ts\">\nimport { NO_ERRORS_SCHEMA } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\nimport { Observable } from 'rxjs/Rx';\nimport { async, ComponentFixture, TestBed } from '@angular/core/testing';\nimport { SpyLocation } from '@angular/common/testing';\n\nimport { PhoneListComponent } from './phone-list.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\nclass MockPhone {\n  query(): Observable&#x3C;PhoneData[]> {\n    return Observable.of([\n      {name: 'Nexus S', snippet: '', images: []},\n      {name: 'Motorola DROID', snippet: '', images: []}\n    ]);\n  }\n}\n\nlet fixture: ComponentFixture&#x3C;PhoneListComponent>;\n\ndescribe('PhoneList', () => {\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ PhoneListComponent ],\n      providers: [\n        { provide: ActivatedRoute, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) },\n        { provide: Location, useClass: SpyLocation },\n        { provide: Phone, useClass: MockPhone },\n      ],\n      schemas: [ NO_ERRORS_SCHEMA ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n  it('should create \"phones\" model with 2 phones fetched from xhr', () => {\n    fixture.detectChanges();\n    let compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelectorAll('.phone-list-item').length).toBe(2);\n    expect(\n      compiled.querySelector('.phone-list-item:nth-child(1)').textContent\n    ).toContain('Motorola DROID');\n    expect(\n      compiled.querySelector('.phone-list-item:nth-child(2)').textContent\n    ).toContain('Nexus S');\n  });\n\n  xit('should set the default value of orderProp model', () => {\n    fixture.detectChanges();\n    let compiled = fixture.debugElement.nativeElement;\n    expect(\n      compiled.querySelector('select option:last-child').selected\n    ).toBe(true);\n  });\n\n});\n\n\n</code-example>\n<p>Finally, revisit both of the component tests when you switch to the Angular\nrouter. For the details component, provide a mock of Angular <code><a href=\"api/router/ActivatedRoute\">ActivatedRoute</a></code> object\ninstead of using the AngularJS <code>$routeParams</code>.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.spec.ts\" region=\"activatedroute\" title=\"app/phone-detail/phone-detail.component.spec.ts\">\nimport { ActivatedRoute } from '@angular/router';\n\n/* . . . */\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n/* . . . */\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: ActivatedRoute, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n</code-example>\n<p>And for the phone list component, a few adjustments to the router make\nthe <code>RouteLink</code> directives work.</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.component.spec.ts\" region=\"routestuff\" title=\"app/phone-list/phone-list.component.spec.ts\">\nimport { NO_ERRORS_SCHEMA } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\nimport { Observable } from 'rxjs/Rx';\nimport { async, ComponentFixture, TestBed } from '@angular/core/testing';\nimport { SpyLocation } from '@angular/common/testing';\n\nimport { PhoneListComponent } from './phone-list.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n/* . . . */\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ PhoneListComponent ],\n      providers: [\n        { provide: ActivatedRoute, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) },\n        { provide: Location, useClass: SpyLocation },\n        { provide: Phone, useClass: MockPhone },\n      ],\n      schemas: [ NO_ERRORS_SCHEMA ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n</code-example>\n\n</div>"
}