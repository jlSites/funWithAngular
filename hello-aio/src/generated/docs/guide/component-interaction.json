{
  "id": "guide/component-interaction",
  "title": "Component Interaction",
  "contents": "\n<div class=\"content\">\n<h1 id=\"component-interaction\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#component-interaction\"><i class=\"material-icons\">link</i></a>Component Interaction</h1>\n<a id=\"top\"></a>\n<p>This cookbook contains recipes for common component communication scenarios\nin which two or more components share information.\n<a id=\"toc\"></a></p>\n<!--\n\n# Contents\n\n* [Pass data from parent to child with input binding](guide/component-interaction#parent-to-child)\n* [Intercept input property changes with a setter](guide/component-interaction#parent-to-child-setter)\n* [Intercept input property changes with `ngOnChanges()`](guide/component-interaction#parent-to-child-on-changes)\n* [Parent calls an `@ViewChild()`](guide/component-interaction#parent-to-view-child)\n* [Parent and children communicate via a service](guide/component-interaction#bidirectional-service)\n\n-->\n<p><strong>See the <live-example name=\"component-interaction\"></live-example></strong>.</p>\n<a id=\"parent-to-child\"></a>\n<h2 id=\"pass-data-from-parent-to-child-with-input-binding\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#pass-data-from-parent-to-child-with-input-binding\"><i class=\"material-icons\">link</i></a>Pass data from parent to child with input binding</h2>\n<p><code>HeroChildComponent</code> has two <strong><em>input properties</em></strong>,\ntypically adorned with <a href=\"guide/template-syntax#inputs-outputs\">@Input decorations</a>.</p>\n<code-example path=\"component-interaction/src/app/hero-child.component.ts\" title=\"component-interaction/src/app/hero-child.component.ts\">\nimport { Component, Input } from '@angular/core';\n\nimport { Hero } from './hero';\n\n@Component({\n  selector: 'hero-child',\n  template: `\n    &#x3C;h3>{{hero.name}} says:&#x3C;/h3>\n    &#x3C;p>I, {{hero.name}}, am at your service, {{masterName}}.&#x3C;/p>\n  `\n})\nexport class HeroChildComponent {\n  @Input() hero: Hero;\n  @Input('master') masterName: string;\n}\n\n</code-example>\n<p>The second <code>@Input</code> aliases the child component property name <code>masterName</code> as <code>'master'</code>.</p>\n<p>The <code>HeroParentComponent</code> nests the child <code>HeroChildComponent</code> inside an <code>*ngFor</code> repeater,\nbinding its <code>master</code> string property to the child's <code>master</code> alias,\nand each iteration's <code>hero</code> instance to the child's <code>hero</code> property.</p>\n<code-example path=\"component-interaction/src/app/hero-parent.component.ts\" title=\"component-interaction/src/app/hero-parent.component.ts\">\nimport { Component } from '@angular/core';\n\nimport { HEROES } from './hero';\n\n@Component({\n  selector: 'hero-parent',\n  template: `\n    &#x3C;h2>{{master}} controls {{heroes.length}} heroes&#x3C;/h2>\n    &#x3C;hero-child *ngFor=\"let hero of heroes\"\n      [hero]=\"hero\"\n      [master]=\"master\">\n    &#x3C;/hero-child>\n  `\n})\nexport class HeroParentComponent {\n  heroes = HEROES;\n  master = 'Master';\n}\n\n</code-example>\n<p>The running application displays three heroes:</p>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/parent-to-child.png\" alt=\"Parent-to-child\" width=\"272\" height=\"267\">\n</figure>\n<h3 class=\"no-toc\" id=\"test-it\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it\"><i class=\"material-icons\">link</i></a>Test it</h3>\n<p>E2E test that all children were instantiated and displayed as expected:</p>\n<code-example path=\"component-interaction/e2e-spec.ts\" region=\"parent-to-child\" title=\"component-interaction/e2e-spec.ts\">\n// ...\nlet _heroNames = ['Mr. IQ', 'Magneta', 'Bombasto'];\nlet _masterName = 'Master';\n\nit('should pass properties to children properly', function () {\n  let parent = element.all(by.tagName('hero-parent')).get(0);\n  let heroes = parent.all(by.tagName('hero-child'));\n\n  for (let i = 0; i &#x3C; _heroNames.length; i++) {\n    let childTitle = heroes.get(i).element(by.tagName('h3')).getText();\n    let childDetail = heroes.get(i).element(by.tagName('p')).getText();\n    expect(childTitle).toEqual(_heroNames[i] + ' says:');\n    expect(childDetail).toContain(_masterName);\n  }\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<a id=\"parent-to-child-setter\"></a>\n<h2 id=\"intercept-input-property-changes-with-a-setter\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#intercept-input-property-changes-with-a-setter\"><i class=\"material-icons\">link</i></a>Intercept input property changes with a setter</h2>\n<p>Use an input property setter to intercept and act upon a value from the parent.</p>\n<p>The setter of the <code>name</code> input property in the child <code>NameChildComponent</code>\ntrims the whitespace from a name and replaces an empty value with default text.</p>\n<code-example path=\"component-interaction/src/app/name-child.component.ts\" title=\"component-interaction/src/app/name-child.component.ts\">\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'name-child',\n  template: '&#x3C;h3>\"{{name}}\"&#x3C;/h3>'\n})\nexport class NameChildComponent {\n  private _name = '';\n\n  @Input()\n  set name(name: string) {\n    this._name = (name &#x26;&#x26; name.trim()) || '&#x3C;no name set>';\n  }\n\n  get name(): string { return this._name; }\n}\n\n</code-example>\n<p>Here's the <code>NameParentComponent</code> demonstrating name variations including a name with all spaces:</p>\n<code-example path=\"component-interaction/src/app/name-parent.component.ts\" title=\"component-interaction/src/app/name-parent.component.ts\">\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'name-parent',\n  template: `\n  &#x3C;h2>Master controls {{names.length}} names&#x3C;/h2>\n  &#x3C;name-child *ngFor=\"let name of names\" [name]=\"name\">&#x3C;/name-child>\n  `\n})\nexport class NameParentComponent {\n  // Displays 'Mr. IQ', '&#x3C;no name set>', 'Bombasto'\n  names = ['Mr. IQ', '   ', '  Bombasto  '];\n}\n\n</code-example>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/setter.png\" alt=\"Parent-to-child-setter\" width=\"322\" height=\"193\">\n</figure>\n<h3 class=\"no-toc\" id=\"test-it-1\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-1\"><i class=\"material-icons\">link</i></a>Test it</h3>\n<p>E2E tests of input property setter with empty and non-empty names:</p>\n<code-example path=\"component-interaction/e2e-spec.ts\" region=\"parent-to-child-setter\" title=\"component-interaction/e2e-spec.ts\">\n// ...\nit('should display trimmed, non-empty names', function () {\n  let _nonEmptyNameIndex = 0;\n  let _nonEmptyName = '\"Mr. IQ\"';\n  let parent = element.all(by.tagName('name-parent')).get(0);\n  let hero = parent.all(by.tagName('name-child')).get(_nonEmptyNameIndex);\n\n  let displayName = hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(_nonEmptyName);\n});\n\nit('should replace empty name with default name', function () {\n  let _emptyNameIndex = 1;\n  let _defaultName = '\"&#x3C;no name set>\"';\n  let parent = element.all(by.tagName('name-parent')).get(0);\n  let hero = parent.all(by.tagName('name-child')).get(_emptyNameIndex);\n\n  let displayName = hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(_defaultName);\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<a id=\"parent-to-child-on-changes\"></a>\n<h2 id=\"intercept-input-property-changes-with-ngonchanges\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#intercept-input-property-changes-with-ngonchanges\"><i class=\"material-icons\">link</i></a>Intercept input property changes with <em>ngOnChanges()</em></h2>\n<p>Detect and act upon changes to input property values with the <code>ngOnChanges()</code> method of the <code><a href=\"api/core/OnChanges\">OnChanges</a></code> lifecycle hook interface.</p>\n<div class=\"l-sub-section\">\n<p>You may prefer this approach to the property setter when watching multiple, interacting input properties.</p>\n<p>Learn about <code>ngOnChanges()</code> in the <a href=\"guide/lifecycle-hooks\">LifeCycle Hooks</a> chapter.</p>\n</div>\n<p>This <code>VersionChildComponent</code> detects changes to the <code>major</code> and <code>minor</code> input properties and composes a log message reporting these changes:</p>\n<code-example path=\"component-interaction/src/app/version-child.component.ts\" title=\"component-interaction/src/app/version-child.component.ts\">\nimport { Component, Input, OnChanges, SimpleChange } from '@angular/core';\n\n@Component({\n  selector: 'version-child',\n  template: `\n    &#x3C;h3>Version {{major}}.{{minor}}&#x3C;/h3>\n    &#x3C;h4>Change log:&#x3C;/h4>\n    &#x3C;ul>\n      &#x3C;li *ngFor=\"let change of changeLog\">{{change}}&#x3C;/li>\n    &#x3C;/ul>\n  `\n})\nexport class VersionChildComponent implements OnChanges {\n  @Input() major: number;\n  @Input() minor: number;\n  changeLog: string[] = [];\n\n  ngOnChanges(changes: {[propKey: string]: SimpleChange}) {\n    let log: string[] = [];\n    for (let propName in changes) {\n      let changedProp = changes[propName];\n      let to = JSON.stringify(changedProp.currentValue);\n      if (changedProp.isFirstChange()) {\n        log.push(`Initial value of ${propName} set to ${to}`);\n      } else {\n        let from = JSON.stringify(changedProp.previousValue);\n        log.push(`${propName} changed from ${from} to ${to}`);\n      }\n    }\n    this.changeLog.push(log.join(', '));\n  }\n}\n\n</code-example>\n<p>The <code>VersionParentComponent</code> supplies the <code>minor</code> and <code>major</code> values and binds buttons to methods that change them.</p>\n<code-example path=\"component-interaction/src/app/version-parent.component.ts\" title=\"component-interaction/src/app/version-parent.component.ts\">\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'version-parent',\n  template: `\n    &#x3C;h2>Source code version&#x3C;/h2>\n    &#x3C;button (click)=\"newMinor()\">New minor version&#x3C;/button>\n    &#x3C;button (click)=\"newMajor()\">New major version&#x3C;/button>\n    &#x3C;version-child [major]=\"major\" [minor]=\"minor\">&#x3C;/version-child>\n  `\n})\nexport class VersionParentComponent {\n  major = 1;\n  minor = 23;\n\n  newMinor() {\n    this.minor++;\n  }\n\n  newMajor() {\n    this.major++;\n    this.minor = 0;\n  }\n}\n\n</code-example>\n<p>Here's the output of a button-pushing sequence:</p>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/parent-to-child-on-changes.gif\" alt=\"Parent-to-child-onchanges\" width=\"481\" height=\"264\">\n</figure>\n<h3 class=\"no-toc\" id=\"test-it-2\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-2\"><i class=\"material-icons\">link</i></a>Test it</h3>\n<p>Test that <strong><em>both</em></strong> input properties are set initially and that button clicks trigger\nthe expected <code>ngOnChanges</code> calls and values:</p>\n<code-example path=\"component-interaction/e2e-spec.ts\" region=\"parent-to-child-onchanges\" title=\"component-interaction/e2e-spec.ts\">\n// ...\n// Test must all execute in this exact order\nit('should set expected initial values', function () {\n  let actual = getActual();\n\n  let initialLabel = 'Version 1.23';\n  let initialLog = 'Initial value of major set to 1, Initial value of minor set to 23';\n\n  expect(actual.label).toBe(initialLabel);\n  expect(actual.count).toBe(1);\n  expect(actual.logs.get(0).getText()).toBe(initialLog);\n});\n\nit('should set expected values after clicking \\'Minor\\' twice', function () {\n  let repoTag = element(by.tagName('version-parent'));\n  let newMinorButton = repoTag.all(by.tagName('button')).get(0);\n\n  newMinorButton.click().then(function() {\n    newMinorButton.click().then(function() {\n      let actual = getActual();\n\n      let labelAfter2Minor = 'Version 1.25';\n      let logAfter2Minor = 'minor changed from 24 to 25';\n\n      expect(actual.label).toBe(labelAfter2Minor);\n      expect(actual.count).toBe(3);\n      expect(actual.logs.get(2).getText()).toBe(logAfter2Minor);\n    });\n  });\n});\n\nit('should set expected values after clicking \\'Major\\' once', function () {\n  let repoTag = element(by.tagName('version-parent'));\n  let newMajorButton = repoTag.all(by.tagName('button')).get(1);\n\n  newMajorButton.click().then(function() {\n    let actual = getActual();\n\n    let labelAfterMajor = 'Version 2.0';\n    let logAfterMajor = 'major changed from 1 to 2, minor changed from 25 to 0';\n\n    expect(actual.label).toBe(labelAfterMajor);\n    expect(actual.count).toBe(4);\n    expect(actual.logs.get(3).getText()).toBe(logAfterMajor);\n  });\n});\n\nfunction getActual() {\n  let versionTag = element(by.tagName('version-child'));\n  let label = versionTag.element(by.tagName('h3')).getText();\n  let ul = versionTag.element((by.tagName('ul')));\n  let logs = ul.all(by.tagName('li'));\n\n  return {\n    label: label,\n    logs: logs,\n    count: logs.count()\n  };\n}\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<a id=\"child-to-parent\"></a>\n<h2 id=\"parent-listens-for-child-event\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#parent-listens-for-child-event\"><i class=\"material-icons\">link</i></a>Parent listens for child event</h2>\n<p>The child component exposes an <code><a href=\"api/core/EventEmitter\">EventEmitter</a></code> property with which it <code>emits</code> events when something happens.\nThe parent binds to that event property and reacts to those events.</p>\n<p>The child's <code><a href=\"api/core/EventEmitter\">EventEmitter</a></code> property is an <strong><em>output property</em></strong>,\ntypically adorned with an <a href=\"guide/template-syntax#inputs-outputs\">@Output decoration</a>\nas seen in this <code>VoterComponent</code>:</p>\n<code-example path=\"component-interaction/src/app/voter.component.ts\" title=\"component-interaction/src/app/voter.component.ts\">\nimport { Component, EventEmitter, Input, Output } from '@angular/core';\n\n@Component({\n  selector: 'my-voter',\n  template: `\n    &#x3C;h4>{{name}}&#x3C;/h4>\n    &#x3C;button (click)=\"vote(true)\"  [disabled]=\"voted\">Agree&#x3C;/button>\n    &#x3C;button (click)=\"vote(false)\" [disabled]=\"voted\">Disagree&#x3C;/button>\n  `\n})\nexport class VoterComponent {\n  @Input()  name: string;\n  @Output() onVoted = new EventEmitter&#x3C;boolean>();\n  voted = false;\n\n  vote(agreed: boolean) {\n    this.onVoted.emit(agreed);\n    this.voted = true;\n  }\n}\n\n</code-example>\n<p>Clicking a button triggers emission of a <code>true</code> or <code>false</code>, the boolean <em>payload</em>.</p>\n<p>The parent <code>VoteTakerComponent</code> binds an event handler called <code>onVoted()</code> that responds to the child event\npayload <code>$event</code> and updates a counter.</p>\n<code-example path=\"component-interaction/src/app/votetaker.component.ts\" title=\"component-interaction/src/app/votetaker.component.ts\">\nimport { Component }      from '@angular/core';\n\n@Component({\n  selector: 'vote-taker',\n  template: `\n    &#x3C;h2>Should mankind colonize the Universe?&#x3C;/h2>\n    &#x3C;h3>Agree: {{agreed}}, Disagree: {{disagreed}}&#x3C;/h3>\n    &#x3C;my-voter *ngFor=\"let voter of voters\"\n      [name]=\"voter\"\n      (onVoted)=\"onVoted($event)\">\n    &#x3C;/my-voter>\n  `\n})\nexport class VoteTakerComponent {\n  agreed = 0;\n  disagreed = 0;\n  voters = ['Mr. IQ', 'Ms. Universe', 'Bombasto'];\n\n  onVoted(agreed: boolean) {\n    agreed ? this.agreed++ : this.disagreed++;\n  }\n}\n\n</code-example>\n<p>The framework passes the event argument—represented by <code>$event</code>—to the handler method,\nand the method processes it:</p>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/child-to-parent.gif\" alt=\"Child-to-parent\" width=\"418\" height=\"342\">\n</figure>\n<h3 class=\"no-toc\" id=\"test-it-3\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-3\"><i class=\"material-icons\">link</i></a>Test it</h3>\n<p>Test that clicking the <em>Agree</em> and <em>Disagree</em> buttons update the appropriate counters:</p>\n<code-example path=\"component-interaction/e2e-spec.ts\" region=\"child-to-parent\" title=\"component-interaction/e2e-spec.ts\">\n// ...\nit('should not emit the event initially', function () {\n  let voteLabel = element(by.tagName('vote-taker'))\n    .element(by.tagName('h3')).getText();\n  expect(voteLabel).toBe('Agree: 0, Disagree: 0');\n});\n\nit('should process Agree vote', function () {\n  let agreeButton1 = element.all(by.tagName('my-voter')).get(0)\n    .all(by.tagName('button')).get(0);\n  agreeButton1.click().then(function() {\n    let voteLabel = element(by.tagName('vote-taker'))\n      .element(by.tagName('h3')).getText();\n    expect(voteLabel).toBe('Agree: 1, Disagree: 0');\n  });\n});\n\nit('should process Disagree vote', function () {\n  let agreeButton1 = element.all(by.tagName('my-voter')).get(1)\n    .all(by.tagName('button')).get(1);\n  agreeButton1.click().then(function() {\n    let voteLabel = element(by.tagName('vote-taker'))\n      .element(by.tagName('h3')).getText();\n    expect(voteLabel).toBe('Agree: 1, Disagree: 1');\n  });\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<h2 id=\"parent-interacts-with-child-via-local-variable\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#parent-interacts-with-child-via-local-variable\"><i class=\"material-icons\">link</i></a>Parent interacts with child via <em>local variable</em></h2>\n<p>A parent component cannot use data binding to read child properties\nor invoke child methods. You can do both\nby creating a template reference variable for the child element\nand then reference that variable <em>within the parent template</em>\nas seen in the following example.</p>\n<a id=\"countdown-timer-example\"></a>\n<p>The following is a child <code>CountdownTimerComponent</code> that repeatedly counts down to zero and launches a rocket.\nIt has <code>start</code> and <code>stop</code> methods that control the clock and it displays a\ncountdown status message in its own template.</p>\n<code-example path=\"component-interaction/src/app/countdown-timer.component.ts\" title=\"component-interaction/src/app/countdown-timer.component.ts\">\nimport { Component, OnDestroy, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'countdown-timer',\n  template: '&#x3C;p>{{message}}&#x3C;/p>'\n})\nexport class CountdownTimerComponent implements OnInit, OnDestroy {\n\n  intervalId = 0;\n  message = '';\n  seconds = 11;\n\n  clearTimer() { clearInterval(this.intervalId); }\n\n  ngOnInit()    { this.start(); }\n  ngOnDestroy() { this.clearTimer(); }\n\n  start() { this.countDown(); }\n  stop()  {\n    this.clearTimer();\n    this.message = `Holding at T-${this.seconds} seconds`;\n  }\n\n  private countDown() {\n    this.clearTimer();\n    this.intervalId = window.setInterval(() => {\n      this.seconds -= 1;\n      if (this.seconds === 0) {\n        this.message = 'Blast off!';\n      } else {\n        if (this.seconds &#x3C; 0) { this.seconds = 10; } // reset\n        this.message = `T-${this.seconds} seconds and counting`;\n      }\n    }, 1000);\n  }\n}\n\n\n</code-example>\n<p>The <code>CountdownLocalVarParentComponent</code> that hosts the timer component is as follows:</p>\n<code-example path=\"component-interaction/src/app/countdown-parent.component.ts\" region=\"lv\" title=\"component-interaction/src/app/countdown-parent.component.ts\">\nimport { Component }                from '@angular/core';\nimport { CountdownTimerComponent }  from './countdown-timer.component';\n\n@Component({\n  selector: 'countdown-parent-lv',\n  template: `\n  &#x3C;h3>Countdown to Liftoff (via local variable)&#x3C;/h3>\n  &#x3C;button (click)=\"timer.start()\">Start&#x3C;/button>\n  &#x3C;button (click)=\"timer.stop()\">Stop&#x3C;/button>\n  &#x3C;div class=\"seconds\">{{timer.seconds}}&#x3C;/div>\n  &#x3C;countdown-timer #timer>&#x3C;/countdown-timer>\n  `,\n  styleUrls: ['demo.css']\n})\nexport class CountdownLocalVarParentComponent { }\n\n</code-example>\n<p>The parent component cannot data bind to the child's\n<code>start</code> and <code>stop</code> methods nor to its <code>seconds</code> property.</p>\n<p>You can place a local variable, <code>#timer</code>, on the tag <code>&#x3C;countdown-timer></code> representing the child component.\nThat gives you a reference to the child component and the ability to access\n<em>any of its properties or methods</em> from within the parent template.</p>\n<p>This example wires parent buttons to the child's <code>start</code> and <code>stop</code> and\nuses interpolation to display the child's <code>seconds</code> property.</p>\n<p>Here we see the parent and child working together.</p>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/countdown-timer-anim.gif\" alt=\"countdown timer\" width=\"212\" height=\"172\">\n</figure>\n<a id=\"countdown-tests\"></a>\n<h3 class=\"no-toc\" id=\"test-it-4\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-4\"><i class=\"material-icons\">link</i></a>Test it</h3>\n<p>Test that the seconds displayed in the parent template\nmatch the seconds displayed in the child's status message.\nTest also that clicking the <em>Stop</em> button pauses the countdown timer:</p>\n<code-example path=\"component-interaction/e2e-spec.ts\" region=\"countdown-timer-tests\" title=\"component-interaction/e2e-spec.ts\">\n// ...\nit('timer and parent seconds should match', function () {\n  let parent = element(by.tagName(parentTag));\n  let message = parent.element(by.tagName('countdown-timer')).getText();\n  browser.sleep(10); // give `seconds` a chance to catchup with `message`\n  let seconds = parent.element(by.className('seconds')).getText();\n  expect(message).toContain(seconds);\n});\n\nit('should stop the countdown', function () {\n  let parent = element(by.tagName(parentTag));\n  let stopButton = parent.all(by.tagName('button')).get(1);\n\n  stopButton.click().then(function() {\n    let message = parent.element(by.tagName('countdown-timer')).getText();\n    expect(message).toContain('Holding');\n  });\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<a id=\"parent-to-view-child\"></a>\n<h2 id=\"parent-calls-an-viewchild\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#parent-calls-an-viewchild\"><i class=\"material-icons\">link</i></a>Parent calls an <em>@ViewChild()</em></h2>\n<p>The <em>local variable</em> approach is simple and easy. But it is limited because\nthe parent-child wiring must be done entirely within the parent template.\nThe parent component <em>itself</em> has no access to the child.</p>\n<p>You can't use the <em>local variable</em> technique if an instance of the parent component <em>class</em>\nmust read or write child component values or must call child component methods.</p>\n<p>When the parent component <em>class</em> requires that kind of access,\n<strong><em>inject</em></strong> the child component into the parent as a <em>ViewChild</em>.</p>\n<p>The following example illustrates this technique with the same\n<a href=\"guide/component-interaction#countdown-timer-example\">Countdown Timer</a> example.\nNeither its appearance nor its behavior will change.\nThe child <a href=\"guide/component-interaction#countdown-timer-example\">CountdownTimerComponent</a> is the same as well.</p>\n<div class=\"l-sub-section\">\n<p>The switch from the <em>local variable</em> to the <em>ViewChild</em> technique\nis solely for the purpose of demonstration.</p>\n</div>\n<p>Here is the parent, <code>CountdownViewChildParentComponent</code>:</p>\n<code-example path=\"component-interaction/src/app/countdown-parent.component.ts\" region=\"vc\" title=\"component-interaction/src/app/countdown-parent.component.ts\">\nimport { AfterViewInit, ViewChild } from '@angular/core';\nimport { Component }                from '@angular/core';\nimport { CountdownTimerComponent }  from './countdown-timer.component';\n\n@Component({\n  selector: 'countdown-parent-vc',\n  template: `\n  &#x3C;h3>Countdown to Liftoff (via ViewChild)&#x3C;/h3>\n  &#x3C;button (click)=\"start()\">Start&#x3C;/button>\n  &#x3C;button (click)=\"stop()\">Stop&#x3C;/button>\n  &#x3C;div class=\"seconds\">{{ seconds() }}&#x3C;/div>\n  &#x3C;countdown-timer>&#x3C;/countdown-timer>\n  `,\n  styleUrls: ['demo.css']\n})\nexport class CountdownViewChildParentComponent implements AfterViewInit {\n\n  @ViewChild(CountdownTimerComponent)\n  private timerComponent: CountdownTimerComponent;\n\n  seconds() { return 0; }\n\n  ngAfterViewInit() {\n    // Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...\n    // but wait a tick first to avoid one-time devMode\n    // unidirectional-data-flow-violation error\n    setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);\n  }\n\n  start() { this.timerComponent.start(); }\n  stop() { this.timerComponent.stop(); }\n}\n\n</code-example>\n<p>It takes a bit more work to get the child view into the parent component <em>class</em>.</p>\n<p>First, you have to import references to the <code><a href=\"api/core/ViewChild\">ViewChild</a></code> decorator and the <code><a href=\"api/core/AfterViewInit\">AfterViewInit</a></code> lifecycle hook.</p>\n<p>Next, inject the child <code>CountdownTimerComponent</code> into the private <code>timerComponent</code> property\nvia the <code>@ViewChild</code> property decoration.</p>\n<p>The <code>#timer</code> local variable is gone from the component metadata.\nInstead, bind the buttons to the parent component's own <code>start</code> and <code>stop</code> methods and\npresent the ticking seconds in an interpolation around the parent component's <code>seconds</code> method.</p>\n<p>These methods access the injected timer component directly.</p>\n<p>The <code>ngAfterViewInit()</code> lifecycle hook is an important wrinkle.\nThe timer component isn't available until <em>after</em> Angular displays the parent view.\nSo it displays <code>0</code> seconds initially.</p>\n<p>Then Angular calls the <code>ngAfterViewInit</code> lifecycle hook at which time it is <em>too late</em>\nto update the parent view's display of the countdown seconds.\nAngular's unidirectional data flow rule prevents updating the parent view's\nin the same cycle. The app has to <em>wait one turn</em> before it can display the seconds.</p>\n<p>Use <code>setTimeout()</code> to wait one tick and then revise the <code>seconds()</code> method so\nthat it takes future values from the timer component.</p>\n<h3 class=\"no-toc\" id=\"test-it-5\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-5\"><i class=\"material-icons\">link</i></a>Test it</h3>\nUse [the same countdown timer tests](guide/component-interaction#countdown-tests) as before.\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<a id=\"bidirectional-service\"></a>\n<h2 id=\"parent-and-children-communicate-via-a-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#parent-and-children-communicate-via-a-service\"><i class=\"material-icons\">link</i></a>Parent and children communicate via a service</h2>\n<p>A parent component and its children share a service whose interface enables bi-directional communication\n<em>within the family</em>.</p>\n<p>The scope of the service instance is the parent component and its children.\nComponents outside this component subtree have no access to the service or their communications.</p>\n<p>This <code>MissionService</code> connects the <code>MissionControlComponent</code> to multiple <code>AstronautComponent</code> children.</p>\n<code-example path=\"component-interaction/src/app/mission.service.ts\" title=\"component-interaction/src/app/mission.service.ts\">\nimport { Injectable } from '@angular/core';\nimport { Subject }    from 'rxjs/Subject';\n\n@Injectable()\nexport class MissionService {\n\n  // Observable string sources\n  private missionAnnouncedSource = new Subject&#x3C;string>();\n  private missionConfirmedSource = new Subject&#x3C;string>();\n\n  // Observable string streams\n  missionAnnounced$ = this.missionAnnouncedSource.asObservable();\n  missionConfirmed$ = this.missionConfirmedSource.asObservable();\n\n  // Service message commands\n  announceMission(mission: string) {\n    this.missionAnnouncedSource.next(mission);\n  }\n\n  confirmMission(astronaut: string) {\n    this.missionConfirmedSource.next(astronaut);\n  }\n}\n\n</code-example>\n<p>The <code>MissionControlComponent</code> both provides the instance of the service that it shares with its children\n(through the <code>providers</code> metadata array) and injects that instance into itself through its constructor:</p>\n<code-example path=\"component-interaction/src/app/missioncontrol.component.ts\" title=\"component-interaction/src/app/missioncontrol.component.ts\">\nimport { Component }          from '@angular/core';\n\nimport { MissionService }     from './mission.service';\n\n@Component({\n  selector: 'mission-control',\n  template: `\n    &#x3C;h2>Mission Control&#x3C;/h2>\n    &#x3C;button (click)=\"announce()\">Announce mission&#x3C;/button>\n    &#x3C;my-astronaut *ngFor=\"let astronaut of astronauts\"\n      [astronaut]=\"astronaut\">\n    &#x3C;/my-astronaut>\n    &#x3C;h3>History&#x3C;/h3>\n    &#x3C;ul>\n      &#x3C;li *ngFor=\"let event of history\">{{event}}&#x3C;/li>\n    &#x3C;/ul>\n  `,\n  providers: [MissionService]\n})\nexport class MissionControlComponent {\n  astronauts = ['Lovell', 'Swigert', 'Haise'];\n  history: string[] = [];\n  missions = ['Fly to the moon!',\n              'Fly to mars!',\n              'Fly to Vegas!'];\n  nextMission = 0;\n\n  constructor(private missionService: MissionService) {\n    missionService.missionConfirmed$.subscribe(\n      astronaut => {\n        this.history.push(`${astronaut} confirmed the mission`);\n      });\n  }\n\n  announce() {\n    let mission = this.missions[this.nextMission++];\n    this.missionService.announceMission(mission);\n    this.history.push(`Mission \"${mission}\" announced`);\n    if (this.nextMission >= this.missions.length) { this.nextMission = 0; }\n  }\n}\n\n</code-example>\n<p>The <code>AstronautComponent</code> also injects the service in its constructor.\nEach <code>AstronautComponent</code> is a child of the <code>MissionControlComponent</code> and therefore receives its parent's service instance:</p>\n<code-example path=\"component-interaction/src/app/astronaut.component.ts\" title=\"component-interaction/src/app/astronaut.component.ts\">\nimport { Component, Input, OnDestroy } from '@angular/core';\n\nimport { MissionService } from './mission.service';\nimport { Subscription }   from 'rxjs/Subscription';\n\n@Component({\n  selector: 'my-astronaut',\n  template: `\n    &#x3C;p>\n      {{astronaut}}: &#x3C;strong>{{mission}}&#x3C;/strong>\n      &#x3C;button\n        (click)=\"confirm()\"\n        [disabled]=\"!announced || confirmed\">\n        Confirm\n      &#x3C;/button>\n    &#x3C;/p>\n  `\n})\nexport class AstronautComponent implements OnDestroy {\n  @Input() astronaut: string;\n  mission = '&#x3C;no mission announced>';\n  confirmed = false;\n  announced = false;\n  subscription: Subscription;\n\n  constructor(private missionService: MissionService) {\n    this.subscription = missionService.missionAnnounced$.subscribe(\n      mission => {\n        this.mission = mission;\n        this.announced = true;\n        this.confirmed = false;\n    });\n  }\n\n  confirm() {\n    this.confirmed = true;\n    this.missionService.confirmMission(this.astronaut);\n  }\n\n  ngOnDestroy() {\n    // prevent memory leak when component destroyed\n    this.subscription.unsubscribe();\n  }\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>Notice that this example captures the <code>subscription</code> and <code>unsubscribe()</code> when the <code>AstronautComponent</code> is destroyed.\nThis is a memory-leak guard step. There is no actual risk in this app because the\nlifetime of a <code>AstronautComponent</code> is the same as the lifetime of the app itself.\nThat <em>would not</em> always be true in a more complex application.</p>\n<p>You don't add this guard to the <code>MissionControlComponent</code> because, as the parent,\nit controls the lifetime of the <code>MissionService</code>.</p>\n</div>\n<p>The <em>History</em> log demonstrates that messages travel in both directions between\nthe parent <code>MissionControlComponent</code> and the <code>AstronautComponent</code> children,\nfacilitated by the service:</p>\n<figure>\n  <img src=\"generated/images/guide/component-interaction/bidirectional-service.gif\" alt=\"bidirectional-service\" width=\"310\" height=\"346\">\n</figure>\n<h3 class=\"no-toc\" id=\"test-it-6\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-6\"><i class=\"material-icons\">link</i></a>Test it</h3>\n<p>Tests click buttons of both the parent <code>MissionControlComponent</code> and the <code>AstronautComponent</code> children\nand verify that the history meets expectations:</p>\n<code-example path=\"component-interaction/e2e-spec.ts\" region=\"bidirectional-service\" title=\"component-interaction/e2e-spec.ts\">\n// ...\nit('should announce a mission', function () {\n  let missionControl = element(by.tagName('mission-control'));\n  let announceButton = missionControl.all(by.tagName('button')).get(0);\n  announceButton.click().then(function () {\n    let history = missionControl.all(by.tagName('li'));\n    expect(history.count()).toBe(1);\n    expect(history.get(0).getText()).toMatch(/Mission.* announced/);\n  });\n});\n\nit('should confirm the mission by Lovell', function () {\n  testConfirmMission(1, 2, 'Lovell');\n});\n\nit('should confirm the mission by Haise', function () {\n  testConfirmMission(3, 3, 'Haise');\n});\n\nit('should confirm the mission by Swigert', function () {\n  testConfirmMission(2, 4, 'Swigert');\n});\n\nfunction testConfirmMission(buttonIndex: number, expectedLogCount: number, astronaut: string) {\n  let _confirmedLog = ' confirmed the mission';\n  let missionControl = element(by.tagName('mission-control'));\n  let confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex);\n  confirmButton.click().then(function () {\n    let history = missionControl.all(by.tagName('li'));\n    expect(history.count()).toBe(expectedLogCount);\n    expect(history.get(expectedLogCount - 1).getText()).toBe(astronaut + _confirmedLog);\n  });\n}\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n\n</div>"
}