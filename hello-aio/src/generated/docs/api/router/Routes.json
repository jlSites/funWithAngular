{
  "id": "api/router/Routes",
  "title": "Routes",
  "contents": "<article>\n  <header class=\"api-header\">\n    <h1 class=\"no-toc\" id=\"routes\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/Routes#routes\"><i class=\"material-icons\">link</i></a>Routes</h1>\n    <label class=\"api-type-label type-alias\">type-alias</label>\n    \n    \n    <label class=\"api-status-label stable\">stable</label>\n    <span class=\"version\"></span>\n  </header>\n\n  \n  <!-- INFO BAR -->\n<section class=\"info-bar\">\n\n<table class=\"is-full-width\">\n<tbody>\n<tr>\n  <th>npm Package</th>\n  <td><a href=\"https://www.npmjs.com/package/@angular/router\">@angular/router</a></td>\n</tr>\n<tr>\n  <th>Module</th>\n  <td><code>import { Routes } from <a href=\"api/router\">@angular/router</a>;</code></td>\n</tr>\n<tr>\n  <th>Source</th>\n  <td><a href=\"https://github.com/angular/angular/tree/4.3.0-rc.0/packages/router/src/config.ts#L13-L255\">router/src/config.ts</a></td>\n</tr>\n\n</tbody>\n</table>\n\n  \n<div class=\"what-it-does info-banner\">\n  <p>Represents router configuration.</p>\n\n</div>\n\n  \n  \n  \n  <code-example language=\"ts\" hidecopy=\"true\">\n  type Routes = Route[];\n  </code-example>\n\n  \n\n  \n  \n<section class=\"description\">\n  <h2 id=\"description\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/Routes#description\"><i class=\"material-icons\">link</i></a>Description</h2>\n  <p><code><a href=\"api/router/Routes\">Routes</a></code> is an array of route configurations. Each one has the following properties:</p>\n<ul>\n<li><code>path</code> is a string that uses the route matcher DSL.</li>\n<li><code>pathMatch</code> is a string that specifies the matching strategy.</li>\n<li><code>matcher</code> defines a custom strategy for path matching and supersedes <code>path</code> and <code>pathMatch</code>.</li>\n<li><code>component</code> is a component type.</li>\n<li><code>redirectTo</code> is the url fragment which will replace the current matched segment.</li>\n<li><code>outlet</code> is the name of the outlet the component should be placed into.</li>\n<li><code>canActivate</code> is an array of DI tokens used to look up CanActivate handlers. See\n<a href=\"api/router/CanActivate\"><code><a href=\"api/router/CanActivate\">CanActivate</a></code></a> for more info.</li>\n<li><code>canActivateChild</code> is an array of DI tokens used to look up CanActivateChild handlers. See\n<a href=\"api/router/CanActivateChild\"><code><a href=\"api/router/CanActivateChild\">CanActivateChild</a></code></a> for more info.</li>\n<li><code>canDeactivate</code> is an array of DI tokens used to look up CanDeactivate handlers. See\n<a href=\"api/router/CanDeactivate\"><code><a href=\"api/router/CanDeactivate\">CanDeactivate</a></code></a> for more info.</li>\n<li><code>canLoad</code> is an array of DI tokens used to look up CanLoad handlers. See\n<a href=\"api/router/CanLoad\"><code><a href=\"api/router/CanLoad\">CanLoad</a></code></a> for more info.</li>\n<li><code>data</code> is additional data provided to the component via <code><a href=\"api/router/ActivatedRoute\">ActivatedRoute</a></code>.</li>\n<li><code>resolve</code> is a map of DI tokens used to look up data resolvers. See <a href=\"api/router/Resolve\"><code><a href=\"api/router/Resolve\">Resolve</a></code></a> for more\ninfo.</li>\n<li><code>runGuardsAndResolvers</code> defines when guards and resolvers will be run. By default they run only\nwhen the matrix parameters of the route change. When set to <code>paramsOrQueryParamsChange</code> they\nwill also run when query params change. And when set to <code>always</code>, they will run every time.</li>\n<li><code>children</code> is an array of child route definitions.</li>\n<li><code>loadChildren</code> is a reference to lazy loaded child routes. See <a href=\"api/router/LoadChildren\"><code><a href=\"api/router/LoadChildren\">LoadChildren</a></code></a> for more\ninfo.</li>\n</ul>\n<h3 id=\"simple-configuration\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/Routes#simple-configuration\"><i class=\"material-icons\">link</i></a>Simple Configuration</h3>\n<code-example>\n[{\n  path: 'team/:id',\n component: Team,\n  children: [{\n    path: 'user/:name',\n    component: User\n  }]\n}]\n</code-example>\n<p>When navigating to <code>/team/11/user/bob</code>, the router will create the team component with the user\ncomponent in it.</p>\n<h3 id=\"multiple-outlets\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/Routes#multiple-outlets\"><i class=\"material-icons\">link</i></a>Multiple Outlets</h3>\n<code-example>\n[{\n  path: 'team/:id',\n  component: Team\n}, {\n  path: 'chat/:user',\n  component: Chat\n  outlet: 'aux'\n}]\n</code-example>\n<p>When navigating to <code>/team/11(aux:chat/jim)</code>, the router will create the team component next to\nthe chat component. The chat component will be placed into the aux outlet.</p>\n<h3 id=\"wild-cards\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/Routes#wild-cards\"><i class=\"material-icons\">link</i></a>Wild Cards</h3>\n<code-example>\n[{\n  path: '**',\n  component: Sink\n}]\n</code-example>\n<p>Regardless of where you navigate to, the router will instantiate the sink component.</p>\n<h3 id=\"redirects\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/Routes#redirects\"><i class=\"material-icons\">link</i></a>Redirects</h3>\n<code-example>\n[{\n  path: 'team/:id',\n  component: Team,\n  children: [{\n    path: 'legacy/user/:name',\n    redirectTo: 'user/:name'\n  }, {\n    path: 'user/:name',\n    component: User\n  }]\n}]\n</code-example>\n<p>When navigating to '/team/11/legacy/user/jim', the router will change the url to\n'/team/11/user/jim', and then will instantiate the team component with the user component\nin it.</p>\n<p>If the <code>redirectTo</code> value starts with a '/', then it is an absolute redirect. E.g., if in the\nexample above we change the <code>redirectTo</code> to <code>/user/:name</code>, the result url will be '/user/jim'.</p>\n<h3 id=\"empty-path\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/Routes#empty-path\"><i class=\"material-icons\">link</i></a>Empty Path</h3>\n<p>Empty-path route configurations can be used to instantiate components that do not 'consume'\nany url segments. Let's look at the following configuration:</p>\n<code-example>\n[{\n  path: 'team/:id',\n  component: Team,\n  children: [{\n    path: '',\n    component: AllUsers\n  }, {\n    path: 'user/:name',\n    component: User\n  }]\n}]\n</code-example>\n<p>When navigating to <code>/team/11</code>, the router will instantiate the AllUsers component.</p>\n<p>Empty-path routes can have children.</p>\n<code-example>\n[{\n  path: 'team/:id',\n  component: Team,\n  children: [{\n    path: '',\n    component: WrapperCmp,\n    children: [{\n      path: 'user/:name',\n      component: User\n    }]\n  }]\n}]\n</code-example>\n<p>When navigating to <code>/team/11/user/jim</code>, the router will instantiate the wrapper component with\nthe user component in it.</p>\n<p>An empty path route inherits its parent's params and data. This is because it cannot have its\nown params, and, as a result, it often uses its parent's params and data as its own.</p>\n<h3 id=\"matching-strategy\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/Routes#matching-strategy\"><i class=\"material-icons\">link</i></a>Matching Strategy</h3>\n<p>By default the router will look at what is left in the url, and check if it starts with\nthe specified path (e.g., <code>/team/11/user</code> starts with <code>team/:id</code>).</p>\n<p>We can change the matching strategy to make sure that the path covers the whole unconsumed url,\nwhich is akin to <code>unconsumedUrl === path</code> or <code>$</code> regular expressions.</p>\n<p>This is particularly important when redirecting empty-path routes.</p>\n<code-example>\n[{\n  path: '',\n  pathMatch: 'prefix', //default\n  redirectTo: 'main'\n}, {\n  path: 'main',\n  component: Main\n}]\n</code-example>\n<p>Since an empty path is a prefix of any url, even when navigating to '/main', the router will\nstill apply the redirect.</p>\n<p>If <code>pathMatch: full</code> is provided, the router will apply the redirect if and only if navigating to\n'/'.</p>\n<code-example>\n[{\n  path: '',\n  pathMatch: 'full',\n  redirectTo: 'main'\n}, {\n  path: 'main',\n  component: Main\n}]\n</code-example>\n<h3 id=\"componentless-routes\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/Routes#componentless-routes\"><i class=\"material-icons\">link</i></a>Componentless Routes</h3>\n<p>It is useful at times to have the ability to share parameters between sibling components.</p>\n<p>Say we have two components--ChildCmp and AuxCmp--that we want to put next to each other and both\nof them require some id parameter.</p>\n<p>One way to do that would be to have a bogus parent component, so both the siblings can get the id\nparameter from it. This is not ideal. Instead, you can use a componentless route.</p>\n<code-example>\n[{\n   path: 'parent/:id',\n   children: [\n     { path: 'a', component: MainChild },\n     { path: 'b', component: AuxChild, outlet: 'aux' }\n   ]\n}]\n</code-example>\n<p>So when navigating to <code>parent/10/(a//aux:b)</code>, the route will instantiate the main child and aux\nchild components next to each other. In this example, the application component\nhas to have the primary and aux outlets defined.</p>\n<p>The router will also merge the <code>params</code>, <code>data</code>, and <code>resolve</code> of the componentless parent into\nthe <code>params</code>, <code>data</code>, and <code>resolve</code> of the children. This is done because there is no component\nthat can inject the activated route of the componentless parent.</p>\n<p>This is especially useful when child components are defined as follows:</p>\n<code-example>\n[{\n   path: 'parent/:id',\n   children: [\n     { path: '', component: MainChild },\n     { path: '', component: AuxChild, outlet: 'aux' }\n   ]\n}]\n</code-example>\n<p>With this configuration in place, navigating to '/parent/10' will create the main child and aux\ncomponents.</p>\n<h3 id=\"lazy-loading\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/router/Routes#lazy-loading\"><i class=\"material-icons\">link</i></a>Lazy Loading</h3>\n<p>Lazy loading speeds up our application load time by splitting it into multiple bundles, and\nloading them on demand. The router is designed to make lazy loading simple and easy. Instead of\nproviding the children property, you can provide the <code>loadChildren</code> property, as follows:</p>\n<code-example>\n[{\n  path: 'team/:id',\n  component: Team,\n  loadChildren: 'team'\n}]\n</code-example>\n<p>The router will use registered NgModuleFactoryLoader to fetch an NgModule associated with 'team'.\nThen it will extract the set of routes defined in that NgModule, and will transparently add\nthose routes to the main configuration.</p>\n\n</section>\n\n\n\n\n</section></article>"
}